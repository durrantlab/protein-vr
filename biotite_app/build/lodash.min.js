(function () {
/**
 * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    //Creates a parts array for a relName where first part is plugin ID,
    //second part is resource ID. Assumes relName has already been normalized.
    function makeRelParts(relName) {
        return relName ? splitPrefix(relName) : [];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relParts) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0],
            relResourceName = relParts[1];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relResourceName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
            } else {
                name = normalize(name, relResourceName);
            }
        } else {
            name = normalize(name, relResourceName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i, relParts,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;
        relParts = makeRelParts(relName);

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, makeRelParts(callback)).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("external/almond", function(){});

// A place to put variables that need to be accessed from multiple places.
// This module is a place to store "global" variables.
define('Vars',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Also some constants
    exports.TRANSPORT_DURATION = 11;
    exports.MAX_DIST_TO_MOL_ON_TELEPORT = 1.5;
    exports.MIN_DIST_TO_MOL_ON_TELEPORT = 1.0;
    exports.MAX_VERTS_PER_SUBMESH = 2000; // This is kind of an arbitrary number.
    exports.BUTTON_SPHERE_RADIUS = 1.2; // the radius of the spheres around buttons used to detect clicks.
    exports.MENU_RADIUS = 2.5; // 3 is comfortable, but doesn't work in crowded environments.
    exports.MENU_MARGIN = 0.05; // 0.15;  // 0.1;
    exports.PAD_MOVE_SPEED = 0.01;
    exports.VR_CONTROLLER_TRIGGER_DELAY_TIME = 500; // time to wait between triggers.
    exports.VR_CONTROLLER_PAD_ROTATION_DELAY_TIME = 750; // time to wait between triggers.
    exports.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET = 0.1;
    exports.MAX_TELEPORT_DIST = 15;
    exports.TRANSPARENT_FLOOR_ALPHA = 0.05; // 0.02;
    // IOS doesn't support a lot of features!
    exports.IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window["MSStream"];
    /**
     * Setup the Vars.
     * @returns void
     */
    function setup() {
        exports.canvas = document.getElementById("renderCanvas");
        // Generate the BABYLON 3D engine
        exports.engine = new BABYLON.Engine(exports.canvas, true);
        if (true) { // true means use manifest files.
            BABYLON.Database.IDBStorageEnabled = true;
        }
        else {
            exports.engine.enableOfflineSupport = false;
        }
        exports.scene = new BABYLON.Scene(exports.engine);
        // For debugging
        window["scene"] = exports.scene;
    }
    exports.setup = setup;
    /**
     * Determines the camera height from the active camera.
     * @returns void
     */
    function determineCameraHeightFromActiveCamera() {
        // Get the camera height. But I don't think this variable is every
        // actually used anywhere...
        if (exports.cameraHeight === undefined) {
            // Calculate the camera height from it's position.
            var ray = new BABYLON.Ray(exports.scene.activeCamera.position, new BABYLON.Vector3(0, -1, 0), 50);
            var pickingInfo = exports.scene.pickWithRay(ray, function (mesh) {
                return (mesh.name === "ground");
            });
            exports.cameraHeight = pickingInfo.distance;
        }
    }
    exports.determineCameraHeightFromActiveCamera = determineCameraHeightFromActiveCamera;
    /**
     * Sets the camera height.
     * @param  {number} height  The height.
     * @returns void
     */
    function setCameraHeight(height) {
        exports.cameraHeight = height;
    }
    exports.setCameraHeight = setCameraHeight;
    /**
     * Modifies the parameters, adding in default values where values are missing,
     * for example. Also saves the updated params to the module-level params
     * variable.
     * @param  {Object<string,*>} initParams The initial parameters.
     */
    function setupVR(initParams) {
        // Create the vr helper. See http://doc.babylonjs.com/how_to/webvr_helper
        var params = {
            // "createDeviceOrientationCamera": false,  // This makes phone ignore motion sensor. No good.
            "createDeviceOrientationCamera": true,
        };
        if (exports.scene.getEngine().getCaps().multiview) {
            // Much faster according to
            // https://doc.babylonjs.com/how_to/multiview, but not supported in
            // all browsers.
            params["useMultiview"] = true;
        }
        exports.vrHelper = exports.scene.createDefaultVRExperience(params);
        // Hide the vrHelper icon initially.
        document.getElementById("babylonVRiconbtn").style.opacity = "0.0"; // Non IE;
        document.getElementById("babylonVRiconbtn").style.filter = "alpha(opacity=0)"; // IE;
        window["vrHelper"] = exports.vrHelper;
        // console.log(window.vrHelper);
        // Save the parameter to params (module-level variable).
        exports.vrVars = initParams;
        // Whether the menu system is active. True by default.
        exports.vrVars.menuActive = true;
    }
    exports.setupVR = setupVR;
});

// This sets up the non vr camera. Not everyone has a vr headset.
define('Cameras/NonVRCamera',["require", "exports", "../Vars"], function (require, exports, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var nonVRCamera;
    var lastCameraPosAboveGroundMesh = new BABYLON.Vector3(0, 0, 0);
    /**
     * Sets up the nonVR camera (not everyone has a VR headset).
     * @returns void
     */
    function setup() {
        setupNonVRCameraObj();
    }
    exports.setup = setup;
    /**
     * Sets up the camera object.
     * @returns void
     */
    function setupNonVRCameraObj() {
        // The VRHelper already created a camera. Need to set it up.
        nonVRCamera = Vars.scene.activeCamera;
        // Enable navigation via both WASD and the arrows keys.
        nonVRCamera.keysUp = [87, 38];
        nonVRCamera.keysDown = [83, 40];
        nonVRCamera.keysLeft = [65, 37];
        nonVRCamera.keysRight = [68, 39];
        // Turn on gravity. Note: Turning this on causes problems, and it doesn't
        // seem to be necessary. Well, it does help with arrow/wsad navigation
        // (can't fly off).
        // Vars.scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
        Vars.scene.gravity = new BABYLON.Vector3(0, -0.1, 0);
        nonVRCamera.applyGravity = true;
        // Enable collision detection. Note that the second paramerter is a
        // radius.
        setCameraElipsoid();
        // Turn on collisions as appropriate. Note that groundMesh collisions are
        // enabled in Navigation.
        // scene.workerCollisions = true;
        Vars.scene.collisionsEnabled = true;
        nonVRCamera.checkCollisions = true;
        // Slow the camera.
        nonVRCamera.speed = 0.1;
        // Make sure orientation is default
        // nonVRCamera.rotation = new BABYLON.Vector3(0, 0, 0);
        nonVRCamera.attachControl(Vars.canvas, true);
        // Position the camera on the floor. See
        // http://www.html5gamedevs.com/topic/30837-gravity-camera-stops-falling/
        nonVRCamera._updatePosition();
    }
    /**
     * Sets up the collision elipsoid around the non-VR camera.
     * @returns void
     */
    function setCameraElipsoid() {
        // Depends on camera height.
        nonVRCamera.ellipsoid = new BABYLON.Vector3(1.0, 0.5 * Vars.cameraHeight, 1.0);
    }
    exports.setCameraElipsoid = setCameraElipsoid;
});

define('Cameras/Setup',["require", "exports", "../Vars", "./NonVRCamera"], function (require, exports, Vars, NonVRCamera) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Runs after the babylon scene is loaded.
    function setup() {
        // You need to make the camera from the babylon file active. First, get
        // the babylon camera.
        exports.cameraFromBabylonFile = Vars.scene.cameras.filter(function (c) { return c.name.indexOf("VR") === -1; })[0];
        // If true, sets up device orientation camera. Otherwise, just use one in
        // babylonjs file.
        if (true) {
            // Create a device orientation camera that matches the one loaded from
            // the babylon file.
            var DevOrCamera = new BABYLON.DeviceOrientationCamera("DevOr_camera", exports.cameraFromBabylonFile.position.clone(), Vars.scene, true);
            DevOrCamera.rotation = exports.cameraFromBabylonFile.rotation;
            // DevOrCamera.resetToCurrentRotation();
            // For debugging.
            // window["cameraFromBabylonFile"] = cameraFromBabylonFile;
            // window["DevOrCamera"] = DevOrCamera;
            // Update the active camera to be the device orientation one.
            Vars.scene.activeCamera = DevOrCamera; // cameraFromBabylonFile
            // Make sure device orientation camera pointing in direction of
            // original camera.
            Vars.scene.activeCamera.rotationQuaternion = BABYLON.Quaternion.FromEulerVector(exports.cameraFromBabylonFile.rotation);
        }
        else {
            Vars.scene.activeCamera = exports.cameraFromBabylonFile;
        }
        // Get the camera height.
        Vars.determineCameraHeightFromActiveCamera();
        // Setup the default (nonVR) camera.
        NonVRCamera.setup();
    }
    exports.setup = setup;
});

// This module has functions for storing various important points in the
// scene. Note that the camera location is in CommonCamera, not here.
define('Navigation/Points',["require", "exports", "../Cameras/CommonCamera", "../Vars", "./Pickables"], function (require, exports, CommonCamera, Vars, Pickables) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pointWayOffScreen = new BABYLON.Vector3(-1000, 1000, 1000);
    exports.groundPointBelowCamera = new BABYLON.Vector3(0, 0, 0);
    exports.groundPointBelowStarePt = new BABYLON.Vector3(0, 0, 0);
    exports.curStarePt = new BABYLON.Vector3(0, 0, 0);
    function setCurStarePt(pt) {
        exports.curStarePt.copyFrom(pt);
    }
    exports.setCurStarePt = setCurStarePt;
    /**
     * Sets up the key points detection. Stare point, point below the camera, etc.
     * @returns void
     */
    function setup() {
        // Constantly update the stare point info. Also, position the tracking
        // mesh.
        Vars.scene.registerBeforeRender(function () {
            // Get the stare point. Here because it should be updated with every
            // frame.
            setStarePointInfo();
            cancelStareIfFarAway();
            Vars.vrVars.navTargetMesh.position.copyFrom(exports.curStarePt);
            // Hide Vars.vrVars.navTargetMesh if it's on padNavSphereAroundCamera.
            if (Pickables.curPickedMesh !== undefined) {
                Vars.vrVars.navTargetMesh.isVisible = Pickables.curPickedMesh !== Pickables.padNavSphereAroundCamera;
            }
            // Also the point on the ground below the camera should be updated
            // every turn of the render loop (to position the menu button).
            var pickedGroundPt = groundPointPickingInfo(CommonCamera.getCameraPosition()).pickedPoint;
            if (pickedGroundPt) {
                exports.groundPointBelowCamera = pickedGroundPt;
            }
            // Also the point on the ground below the stare point.
            pickedGroundPt = groundPointPickingInfo(exports.curStarePt).pickedPoint;
            if (pickedGroundPt) {
                exports.groundPointBelowStarePt = pickedGroundPt;
            }
        });
    }
    exports.setup = setup;
    /**
     * Gets the point where the user is looking (or pointing with controllers).
     * @returns void
     */
    function setStarePointInfo() {
        // This function runs with ever turn of the render loop. Set's information
        // about what you're looking/pointing at. Info saved to curStarePt
        var ray;
        if (Vars.vrVars.navMode === 3 /* NoVR */) {
            // No VR yet. So it's outside the realm of the VRHelper. Calculate
            // it using the looking direction.
            // Get a ray extending out in the direction of the stare.
            ray = Vars.scene.activeCamera.getForwardRay();
        }
        else if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // Find the valid gazetracker mesh.
            var gazeTrackerMesh = void 0;
            if (Vars.vrVars.navMode === 1 /* VRWithControllers */) {
                gazeTrackerMesh = Vars.vrHelper.rightControllerGazeTrackerMesh;
                if (!gazeTrackerMesh) {
                    gazeTrackerMesh = Vars.vrHelper.leftControllerGazeTrackerMesh;
                }
            }
            else if (Vars.vrVars.navMode === 2 /* VRNoControllers */) {
                gazeTrackerMesh = Vars.vrHelper.gazeTrackerMesh;
            }
            if (!gazeTrackerMesh) {
                console.log("error!");
                return;
            }
            if (!gazeTrackerMesh.isVisible) {
                setCurStarePt(exports.pointWayOffScreen);
            }
            else {
                setCurStarePt(gazeTrackerMesh.absolutePosition);
            }
            // Construct a ray from the camera to the stare obj
            var camPos = CommonCamera.getCameraPosition();
            // ray = new BABYLON.Ray(camPos, curStarePt.subtract(camPos), 1000);
            ray = new BABYLON.Ray(camPos, exports.curStarePt.subtract(camPos));
        }
        else {
            console.log("Unexpected error.");
        }
        setPickPointAndObjInScene(ray);
    }
    exports.setStarePointInfo = setStarePointInfo;
    /**
     * Cancel the stare point if it's very far away.
     * @returns void
     */
    function cancelStareIfFarAway() {
        if (exports.curStarePt === undefined) {
            setCurStarePt(exports.pointWayOffScreen);
            Pickables.setCurPickedMesh(undefined);
        }
        else {
            var dist = BABYLON.Vector3.Distance(CommonCamera.getCameraPosition(), exports.curStarePt);
            if (dist > 10) {
                setCurStarePt(exports.pointWayOffScreen);
                Pickables.setCurPickedMesh(undefined);
            }
        }
    }
    /**
     * Sets the pick point and object currently looking at.
     * @param  {*}       ray	          The looking ray.
     * @param  {boolean} [updatePos=true] Whether to update the position.
     * @returns void
     */
    function setPickPointAndObjInScene(ray, updatePos) {
        if (updatePos === void 0) { updatePos = true; }
        // Determines where the specified ray intersects a pickable object.
        var pickingInfo = Vars.scene.pickWithRay(ray, function (mesh) {
            return Pickables.checkIfMeshPickable(mesh);
        });
        if ((pickingInfo.hit) && (pickingInfo.distance < Vars.MAX_TELEPORT_DIST)) {
            // It does hit the floor or some other pickable object. Return the
            // point.
            if (updatePos) {
                setCurStarePt(pickingInfo.pickedPoint);
            }
            Pickables.setCurPickedMesh(pickingInfo.pickedMesh);
        }
        else {
            // It doesn't hit the floor or is too far away, so return null.
            setCurStarePt(exports.pointWayOffScreen);
            Pickables.setCurPickedMesh(undefined);
        }
    }
    /**
     * Gets the picking info for the point on the ground below a specified point.
     * @param   {*}              pt  The specified point.
     * @returns Object<string,*> The picking info, projected onto the ground.
     */
    function groundPointPickingInfo(pt) {
        var ray = new BABYLON.Ray(pt, new BABYLON.Vector3(0, -1, 0), 50);
        var pickingInfo = Vars.scene.pickWithRay(ray, function (mesh) {
            return (mesh.id === Vars.vrVars.groundMesh.id);
        });
        return pickingInfo;
    }
    exports.groundPointPickingInfo = groundPointPickingInfo;
});

// These functions include camera functions common to all kinds of cameras.
define('Cameras/CommonCamera',["require", "exports", "../Navigation/Points", "../Vars"], function (require, exports, Points, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var forwardVec = new BABYLON.Vector3(1, 0, 0);
    var upVec = new BABYLON.Vector3(1, 0, 0);
    // let activeCamPos = new BABYLON.Vector3(0, 0, 0);
    /**
     * Gets the location of the camera. If VR camera, gets the left eye.
     * @returns * The camera location.
     */
    function getCameraPosition() {
        // If it's a VR camera, you need to make an adjustment.
        var activeCam = Vars.scene.activeCamera;
        var activeCamPos = activeCam.position.clone();
        if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // VR camera, so get eye position.
            if (activeCam.leftCamera) {
                activeCamPos.copyFrom(activeCam.leftCamera.globalPosition);
            }
            else {
                console.log("Prob here");
            }
        }
        return activeCamPos;
    }
    exports.getCameraPosition = getCameraPosition;
    /**
     * Sets the camera location. Accounts for difference between eye and camera
     * pos if VR camera.
     * @param  {*} pt The new location.
     * @returns void
     */
    function setCameraPosition(pt) {
        if (Vars.vrVars.navMode === 3 /* NoVR */) {
            // A regular camera. Just move it there.
            var activeCam = Vars.scene.activeCamera;
            activeCam.position.copyFrom(pt);
        }
        else if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // Not ever tested... not sure it works...
            var activeCam = Vars.vrHelper.webVRCamera;
            // A VR camera. Need to account for the fact that the eye might not be
            // at the same place as the camera.
            activeCam.position.copyFrom(pt.subtract(getVecFromEyeToCamera()));
        }
    }
    exports.setCameraPosition = setCameraPosition;
    /**
     * Gets the camera rotation
     * @returns * The rotation.
     */
    function getCameraRotationY() {
        if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // Complicated in the case of a VR camera.
            var groundPtVec = Points.groundPointBelowStarePt.subtract(Points.groundPointBelowCamera);
            var angle = BABYLON.Vector3.GetAngleBetweenVectors(groundPtVec, forwardVec, upVec);
            if (groundPtVec.z < 0) {
                angle = -angle;
            }
            // Make sure the angle is between 0 and 2 * Math.PI
            while (angle < 0) {
                angle = angle + 2 * Math.PI;
            }
            while (angle > 2 * Math.PI) {
                angle = angle - 2 * Math.PI;
            }
            angle = angle + Math.PI * 0.5;
            return angle;
        }
        else {
            // This is much simplier with a non-VR camera.
            var activeCam = Vars.scene.activeCamera;
            var activeCamRot = activeCam.rotation.clone();
            return activeCamRot.y; // + Math.PI * 0.5;
        }
    }
    exports.getCameraRotationY = getCameraRotationY;
    /**
     * Gets the vector from the camera location to the eye location. For a VR
     * camera, these can be different.
     * @returns * The vector.
     */
    function getVecFromEyeToCamera() {
        if (Vars.vrVars.navMode === 3 /* NoVR */) {
            // Not in VR mode? Then there is no eye.
            return new BABYLON.Vector3(0, 0, 0);
        }
        // Note that some VR cameras don't track position, only orientation.
        // Google cardboard is an example.
        var activeCam = Vars.vrHelper.webVRCamera;
        var deltaVec;
        if (activeCam.leftCamera) {
            var leftEyePos = activeCam.leftCamera.globalPosition;
            deltaVec = leftEyePos.subtract(activeCam.position);
        }
        else {
            deltaVec = new BABYLON.Vector3(0, 0, 0);
        }
        return deltaVec;
    }
    exports.getVecFromEyeToCamera = getVecFromEyeToCamera;
});

// Functions to handle molecule shadows.
define('Mols/Shadows',["require", "exports", "../Vars"], function (require, exports, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Setup the shadow generator that casts a shadow from the molecule meshes.
     * @returns void
     */
    function setupShadowGenerator() {
        // Get the light that will cast the shadows.
        var light = Vars.scene.lights[0];
        var shadowInf = getBlurDarknessFromLightName();
        shadowInf.T = 0;
        shadowInf.blur = 2;
        // Set up the shadow generator.
        // Below gives error on iphone sometimes...
        if (!Vars.IOS) {
            exports.shadowGenerator = new BABYLON.ShadowGenerator(4096, light);
            exports.shadowGenerator.useBlurExponentialShadowMap = true;
            exports.shadowGenerator.setDarkness(shadowInf.darkness);
            // If using kernal, do below.
            exports.shadowGenerator.useKernelBlur = true; // Very good shadows, but more expensive.
            exports.shadowGenerator.blurKernel = shadowInf.blur; // Degree of bluriness.
            // If not using kernal, do below
            // shadowGenerator.blurScale = 7;  // Good for surfaces and ribbon.
            // shadowGenerator.blurBoxOffset = 5;
            // Will make debugging easier.
            window.shadowGenerator = exports.shadowGenerator;
            // Old parameters not used:
            // shadowGenerator.usePoissonSampling = true;  // Good but slow.
        }
        else {
            console.log("iOS, so not generating shadows... causes an error... See https://forum.babylonjs.com/t/issues-between-shadowgenerator-and-ios-osx/795");
        }
    }
    exports.setupShadowGenerator = setupShadowGenerator;
    /**
     * Gets the blur and darkness to use on shadows and molecule lighting.
     * @returns Object<string,number>
     */
    function getBlurDarknessFromLightName() {
        var light = Vars.scene.lights[0];
        // Set some default values for the shadows.
        var blur = 64;
        var darkness = 0.9625; // Lower numbers are darker.
        // Now overwrite those values if reason to do so in the name of the light.
        var blurMatches = light.name.match(/blur_([0-9\.]+)/g);
        if (blurMatches !== null) {
            blur = parseFloat(blurMatches[0].substr(5));
        }
        var darknessMatches = light.name.match(/dark_([0-9\.]+)/g);
        if (darknessMatches !== null) {
            darkness = parseFloat(darknessMatches[0].substr(5));
        }
        return { blur: blur, darkness: darkness };
    }
    exports.getBlurDarknessFromLightName = getBlurDarknessFromLightName;
    /**
     * Sets up the shadow-catcher mesh.
     * @returns void
     */
    function setupShadowCatchers() {
        // Go through and find the shdow catchers
        for (var idx in Vars.scene.meshes) {
            if (Vars.scene.meshes.hasOwnProperty(idx)) {
                var mesh = Vars.scene.meshes[idx];
                if ((mesh.name.toLowerCase().indexOf("shadowcatcher") !== -1) || (mesh.name.toLowerCase().indexOf("shadow_catcher") !== -1)) {
                    // Make the material
                    mesh.material = new BABYLON.ShadowOnlyMaterial("shadow_catch" + idx.toString(), Vars.scene);
                    mesh.material.activeLight = Vars.scene.lights[0];
                    // mesh.material.alpha = 0.1;
                    // It can receive shadows.
                    mesh.receiveShadows = true;
                }
            }
        }
    }
    exports.setupShadowCatchers = setupShadowCatchers;
});

define('Scene/Optimizations',["require", "exports", "../Mols/Shadows", "../Vars"], function (require, exports, Shadows, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Setup the optimizations.
     * @returns void
     */
    function setup() {
        // Turn on scene optimizer
        BABYLON.SceneOptimizer.OptimizeAsync(Vars.scene, 
        // BABYLON.SceneOptimizerOptions.HighDegradationAllowed(),
        sceneOptimizerParameters());
        // Assume no part of the scene goes on to empty (skybox?)
        Vars.scene.autoClear = false; // Color buffer
        Vars.scene.autoClearDepthAndStencil = false;
        // Modify some meshes
        for (var idx in Vars.scene.meshes) {
            if (Vars.scene.meshes.hasOwnProperty(idx)) {
                var mesh = Vars.scene.meshes[idx];
                // Meshes that contain the word "baked" should be shadeless
                if ((mesh.name.indexOf("baked") !== -1) && (mesh.material !== undefined)) {
                    // Make material shadeless
                    mesh.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
                    mesh.material.specularColor = new BABYLON.Color3(0, 0, 0);
                    mesh.material.emissiveTexture = mesh.material.diffuseTexture;
                    mesh.material.diffuseTexture = null;
                    // Material won't be changing. But apparently this is no
                    // longer a needed optimization:
                    // http://www.html5gamedevs.com/topic/37540-when-is-it-safe-to-freeze-materials/
                    // mesh.material.freeze();
                    // Assume no change in location (because that would require
                    // recalculating shadows)
                    mesh.freezeWorldMatrix();
                }
            }
        }
    }
    exports.setup = setup;
    /**
     * Gets the number of vertices in a mesh.
     * @param  {*} mesh The mesh.
     * @returns number|null  The number of vertices.
     */
    function getNumVertices(mesh) {
        // First, get the number of vertexes.
        var numVertexes;
        if (mesh !== undefined) {
            var vertexData = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (vertexData === null) {
                return null;
            } // Something like __root__
            numVertexes = vertexData.length / 3;
        }
        else {
            numVertexes = 0;
        }
        return numVertexes;
    }
    /**
     * Optimize the ability to pick meshes, using octrees.
     * @param  {*} mesh The mesh.
     * @returns void
     */
    function optimizeMeshPicking(mesh) {
        // First, get the number of vertexes.
        var numVertexes = getNumVertices(mesh);
        if (numVertexes === null) {
            return;
        } // Something like __root__
        // If there are very few vertexes, don't use this optimization. This
        // prevents it's use on button spheres, for example.
        if (numVertexes < 100) {
            return;
        }
        // Now get the number of submeshes to use.
        var numSubMeshes = 1 + Math.floor(numVertexes / Vars.MAX_VERTS_PER_SUBMESH);
        // Subdivide the mesh if necessary.
        if (numSubMeshes > 1) {
            mesh.subdivide(numSubMeshes);
        }
        // Now use octree for picking and collisions.
        // mesh.createOrUpdateSubmeshesOctree(64, 2);  // Messes up culling on protein all sticks.
        // mesh.useOctreeForCollisions = true;
    }
    exports.optimizeMeshPicking = optimizeMeshPicking;
    /**
     * Freeze the properties on a mesh, so they don't need to be recalculated.
     * @param  {*}       mesh	                The mesh.
     * @param  {boolean} [freezeMaterial=true]  Whether to freeze the material.
     * @param  {boolean} [worldMatrix=true]     Whether to freeze the world matrix.
     * @returns void
     */
    function freezeMeshProps(mesh, freezeMaterial, worldMatrix) {
        if (freezeMaterial === void 0) { freezeMaterial = true; }
        if (worldMatrix === void 0) { worldMatrix = true; }
        if (freezeMaterial) {
            mesh.material.freeze();
            // material.unfreeze();
        }
        // if (worldMatrix) {
        // TODO: Why doesn't this work?
        // mesh.freezeWorldMatrix();
        // mesh.unfreezeWorldMatrix();
        // }
    }
    exports.freezeMeshProps = freezeMeshProps;
    /**
     * Update the environment shadows. They are frozen otherwise.
     * @returns void
     */
    function updateEnvironmentShadows() {
        if (Shadows.shadowGenerator) {
            // Update the shadows. They are frozen otherwise.
            Vars.scene.lights[0].autoUpdateExtends = true;
            Shadows.shadowGenerator.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
            Vars.scene.lights[0].autoUpdateExtends = false;
        }
    }
    exports.updateEnvironmentShadows = updateEnvironmentShadows;
    /**
     * Prepares scene-optimizer paramters.
     * @returns * The parameters.
     */
    function sceneOptimizerParameters() {
        // See https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
        // The goal here is to maintain a frame rate of 60. Check every two
        // seconds. Very similar to HighDegradationAllowed
        var result = new BABYLON.SceneOptimizerOptions(25, 2000);
        var priority = 0;
        result.optimizations.push(new BABYLON.ShadowsOptimization(priority));
        // The below won't make a difference for my scenes anyway...
        // result.optimizations.push(new BABYLON.MergeMeshesOptimization(priority));
        result.optimizations.push(new BABYLON.LensFlaresOptimization(priority));
        result.optimizations.push(new BABYLON.PostProcessesOptimization(priority));
        result.optimizations.push(new BABYLON.ParticlesOptimization(priority));
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new RemoveSurfaces(priority)); // Remove surfaces
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new BABYLON.TextureOptimization(priority, 512));
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new BABYLON.RenderTargetsOptimization(priority));
        result.optimizations.push(new BABYLON.TextureOptimization(priority, 256));
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new BABYLON.HardwareScalingOptimization(priority, 4));
        result.optimizations.push(new SimplifyMeshes(priority, 500)); // Simplify meshes.
        result.optimizations.push(new ReportOptimizationChange(priority));
        return result;
    }
    /**
     * Entirely remove a mesh.
     * @param  {*} mesh The mesh to remove.
     * @returns void
     */
    function removeMeshEntirely(mesh) {
        if (mesh !== null) {
            mesh.dispose();
        }
        mesh = null;
    }
    exports.removeMeshEntirely = removeMeshEntirely;
    /**
     * Remove the surface mesh (it takes a lot of resources).
     * @param  {number} priority The priority of this optimization.
     * @returns void
     */
    function ReportOptimizationChange(priority) {
        var _this = this;
        if (typeof priority === "undefined") {
            priority = 0;
        }
        this["priority"] = priority;
        this["apply"] = function (scene) {
            console.log("Optimization priority:", _this["priority"]);
            console.log("FPS:", Vars.engine.getFps());
            console.log("");
            return true;
        };
        this["getDescription"] = function () {
            return "Reports the current priority. For debugging.";
        };
    }
    /**
     * Remove the surface mesh (it takes a lot of resources).
     * @param  {number} priority The priority of this optimization.
     * @returns void
     */
    function RemoveSurfaces(priority) {
        if (typeof priority === "undefined") {
            priority = 0;
        }
        this["priority"] = priority;
        this["apply"] = function (scene) {
            // Delete the surface mesh. Note that it will still be visible in the
            // main menu, but oh well.
            var surfaces = Vars.scene.getMeshByName("surfaces.wrl");
            removeMeshEntirely(surfaces);
            // Failed attempty below, but perhaps worth revisiting in the future.
            // VoiceCommands.showOrHideModel("", "surface", false);
            // VoiceCommands.interpretHideShowCommands(["surface"], true);
            return true;
        };
        this["getDescription"] = function () {
            return "Removes surface representations.";
        };
    }
    /**
     * A scene optimization to decimate the big meshes.
     * @param  {number} priority                  The priority of this
     *                                            optimization.
     * @param  {number} minNumVertsThatIsProblem  The target number of vertices.
     * @param  {number} [decimationLevel=]        The decimation level. If not
     *                                            specified, calculated from
     *                                            minNumVertsThatIsProblem.
     */
    function SimplifyMeshes(priority, minNumVertsThatIsProblem, decimationLevel) {
        if (decimationLevel === void 0) { decimationLevel = undefined; }
        if (typeof priority === "undefined") {
            priority = 0;
        }
        this["priority"] = priority;
        this["apply"] = function (scene) {
            var meshesToConsider = [];
            for (var meshIdx in Vars.scene.meshes) {
                if (Vars.scene.meshes.hasOwnProperty(meshIdx)) {
                    var mesh = Vars.scene.meshes[meshIdx];
                    // If it's decimated, skip it. It will be deleted and
                    // recreated.
                    if (mesh.name.indexOf("Decimated") !== -1) {
                        continue;
                    }
                    // For now, skip it if it was a wrl file in origin (because
                    // simplification erases colors).
                    // if (mesh.name.indexOf(".wrl") === -1) { continue; }
                    // mesh.material.wireframe = true;
                    // Get the number of vertexes.
                    var numVertexes = getNumVertices(mesh);
                    if (numVertexes === null) {
                        continue;
                    } // Something like __root__
                    if (numVertexes < minNumVertsThatIsProblem) {
                        continue;
                    }
                    meshesToConsider.push([
                        numVertexes, mesh,
                        (decimationLevel === undefined) ? 1. - minNumVertsThatIsProblem / numVertexes : decimationLevel,
                    ]);
                    // Simplify the mesh. See
                    // https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
                    // You used to be able to simplify a mesh without LOD.
                    // let decimator = new BABYLON.QuadraticErrorSimplification(mesh);
                    // simplify({
                    //     "decimationIterations": 100,
                    //     "aggressiveness": 7,
                    //     // "syncIterations": ?  // Just keep default. Not sure what this is.
                    // }, () => { return; });
                }
            }
            // Order the meshes from the one with most vertices to the one with
            // least (prioritize bad ones).
            meshesToConsider.sort(function (a, b) { return b[0] - a[0]; });
            // Simplify those meshes.
            for (var _i = 0, meshesToConsider_1 = meshesToConsider; _i < meshesToConsider_1.length; _i++) {
                var meshToConsider = meshesToConsider_1[_i];
                var mesh = meshToConsider[1];
                var decimationLvel = meshToConsider[2];
                // Remove the existing LODs if they exist.
                while (mesh.getLODLevels().length > 0) {
                    var firstLODMesh = mesh.getLODLevels()[0]["mesh"];
                    mesh.removeLODLevel(firstLODMesh);
                    removeMeshEntirely(firstLODMesh);
                }
                // https://doc.babylonjs.com/api/classes/babylon.mesh#simplify
                mesh.simplify([{ "quality": decimationLvel, "distance": 0.001 }], false, BABYLON.SimplificationType.QUADRATIC, function () {
                    // console.log("GGG2", mesh.name, mesh.getLODLevels().length);
                    // let simpMesh = mesh.getLODLevels()[0]["mesh"];
                    // removeMeshEntirely(mesh);
                    // console.log(simpMesh);
                    // window["mesh"] = mesh;
                    // console.log(mesh.name, decimationLvel);
                });
            }
            return true;
        };
        this["getDescription"] = function () {
            return "Simplifies the geometry of complex objects in the scene.";
        };
    }
});

// This module handles all things navigation related.
define('Navigation/Navigation',["require", "exports", "../Cameras/CommonCamera", "../Cameras/NonVRCamera", "../Scene/Optimizations", "../Vars", "./Pickables", "./Points"], function (require, exports, CommonCamera, NonVRCamera, Optimizations, Vars, Pickables, Points) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // ***** TODO: WORK ON THIS:
    // export let interactingObjs = [];
    // export function addInteractingObj(mesh) { interactingObjs.push(mesh); }
    var currentlyTeleporting = false;
    /**
     * Setup the navigation system.
     * @returns void
     */
    function setup() {
        // Allways collide with a floor mesh.
        Vars.vrVars.groundMesh = Vars.scene.getMeshByID(Vars.vrVars.groundMeshName);
        if (Vars.vrVars.groundMesh === null) {
            alert("No mesh named " + Vars.vrVars.groundMeshName);
        }
        Vars.vrVars.groundMesh.checkCollisions = true;
        // The ground should generally be hidden. There's a chance it could be
        // turned into glass too. See Mols.
        Vars.vrVars.groundMesh.visibility = 0;
        Optimizations.optimizeMeshPicking(Vars.vrVars.groundMesh);
        Pickables.makeMeshMouseClickable({
            callBack: actOnStareTrigger,
            mesh: Vars.vrVars.groundMesh,
        });
        // Initially, no VR.
        Vars.vrVars.navMode = 3 /* NoVR */;
        // Setup triggers.
        setupTriggers();
        // Keep track up critical points in the scene (like stare points).
        Points.setup();
        // Create a div to intercept clicks if needed. Add clear div over canvas.
        setupCaptureMouseClicksOutsideBabylon();
        // Constantly monitor the position of the camera. If it's no longer over
        // the floor, move it back to its previous position.
        keepCameraOverFloor();
    }
    exports.setup = setup;
    var lastCameraPt;
    /**
     * Check and make sure the camera is over the ground. If not, move it back so
     * it is over the ground.
     * @returns void
     */
    function keepCameraOverFloor() {
        // lastCameraPt = Vars.scene.activeCamera.position.clone();
        lastCameraPt = CommonCamera.getCameraPosition();
        Vars.scene.registerBeforeRender(function () {
            // let cameraPt = Vars.scene.activeCamera.position.clone();
            var cameraPt = CommonCamera.getCameraPosition(); // cloned pt.
            var groundPointBelowCamera = Points.groundPointPickingInfo(cameraPt);
            if (groundPointBelowCamera.pickedMesh === null) {
                // You're not above the ground! This shouldn't happen, but it can
                // occasionally. Return the camera to its previous position. One
                // example is if you're using the controllers on a HTC vive to
                // navigate (forward/backward).
                // console.log("Reverting camera position..");
                // Vars.scene.activeCamera.position = lastCameraPt;
                CommonCamera.setCameraPosition(lastCameraPt);
            }
            else {
                lastCameraPt = cameraPt;
            }
            // console.log(groundPointBelowCamera);
        });
    }
    /**
     * Sets up additional triggers.
     * @returns void
     */
    function setupTriggers() {
        // Space always triggers
        var body = jQuery("body");
        body.keypress(function (e) {
            if (e.charCode === 32) {
                // Space bar
                actOnStareTrigger();
            }
        });
        // Mouse clicks are handled elsewhere...
    }
    var lastTrigger = 0;
    /**
     * Triggers an action, based on the mesh you're currently looking at.
     * @returns void
     */
    function actOnStareTrigger() {
        // There is a refractory period to prevent rapid trigger fires.
        var curTime = new Date().getTime();
        if (curTime - lastTrigger < 250) {
            return;
        }
        else {
            lastTrigger = curTime;
        }
        // Click, space, or something. You need to decide how to act.
        switch (Pickables.getCategoryOfCurMesh()) {
            case 2 /* Ground */:
                // It's the ground, so teleport there.
                console.log("teleport");
                teleport();
                break;
            case 4 /* Molecule */:
                // It's a molecule, so increase the height.
                grow();
                break;
            case 3 /* Button */:
                // It's a button. Click function is attached to the mesh (see
                // GUI.ts).
                Pickables.curPickedMesh.clickFunc();
            default:
                // None.
                break;
        }
    }
    exports.actOnStareTrigger = actOnStareTrigger;
    /**
     * Teleport to a given location.
     * @param  {*}         [newLoc=undefined] The new location. Uses stare point
     *                                        if no location given.
     * @param  {Function}  [callBack=]        The callback function once teleport
     *                                        is done.
     * @returns void
     */
    function teleport(newLoc, callBack) {
        if (newLoc === void 0) { newLoc = undefined; }
        if (callBack === void 0) { callBack = undefined; }
        currentlyTeleporting = true;
        if (callBack === undefined) {
            callBack = function () { return; };
        }
        // Hide the bigger nav mesh. It will appear again elsewhere.
        Vars.vrHelper.gazeTrackerMesh.isVisible = false;
        // Animate the transition to the new location.
        var animationCameraTeleportation = new BABYLON.Animation("animationCameraTeleportation", "position", 90, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
        // The start location.
        var startLoc = CommonCamera.getCameraPosition();
        // Get the new location.
        if (newLoc === undefined) {
            // If it's not defined, use the current stare point.
            newLoc = new BABYLON.Vector3(Points.curStarePt.x, Points.curStarePt.y + Vars.cameraHeight, Points.curStarePt.z);
        }
        // Correct if VR camera.
        var eyeToCamVec = CommonCamera.getVecFromEyeToCamera();
        newLoc = newLoc.subtract(eyeToCamVec);
        startLoc = startLoc.subtract(eyeToCamVec);
        // Animate to new location.
        var animationCameraTeleportationKeys = [
            { "frame": 0, "value": startLoc },
            { "frame": Vars.TRANSPORT_DURATION, "value": newLoc },
        ];
        animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);
        var activeCamera = Vars.scene.activeCamera;
        activeCamera.animations = [];
        activeCamera.animations.push(animationCameraTeleportation);
        Vars.scene.beginAnimation(activeCamera, 0, Vars.TRANSPORT_DURATION, false, 1, function () {
            // Animation finished callback.
            currentlyTeleporting = false;
            Vars.vrHelper.gazeTrackerMesh.isVisible = true;
            // Erase animation
            activeCamera.animations = [];
            callBack();
        });
    }
    /**
     * Teleport and grow. Fires if you click on a molecular mesh.
     * @returns void
     */
    function grow() {
        // let ptBelowStarePt = Points.groundPointPickingInfo(Points.curStarePt).pickedPoint;
        var ptBelowStarePt = Points.groundPointBelowStarePt;
        // Get the vector form the stare point to the camera.
        var cameraPos = CommonCamera.getCameraPosition();
        var vecStarePtCamera = Points.curStarePt.subtract(cameraPos);
        var vecStarePtDist = vecStarePtCamera.length();
        var newPt;
        if (0.1 * vecStarePtDist < Vars.MIN_DIST_TO_MOL_ON_TELEPORT) {
            // Teleporting 90% of the way would put you too close to the target.
            newPt = Points.curStarePt.subtract(vecStarePtCamera.normalize().scale(Vars.MIN_DIST_TO_MOL_ON_TELEPORT));
        }
        else if (0.1 * vecStarePtDist > Vars.MAX_DIST_TO_MOL_ON_TELEPORT) {
            // Teleporting 90% of the way would put you too far from the target.
            newPt = Points.curStarePt.subtract(vecStarePtCamera.normalize().scale(Vars.MAX_DIST_TO_MOL_ON_TELEPORT));
        }
        else if (0.1 * vecStarePtDist < Vars.MAX_DIST_TO_MOL_ON_TELEPORT) {
            // Teleporting 90% of the way would put you in the sweet spot. Do
            // that.
            newPt = cameraPos.add(vecStarePtCamera.scale(0.9));
        }
        // Now tweak the height to match the point exactly (not on the line
        // between camera and point).
        newPt.y = Points.curStarePt.y;
        // You need to make sure the new point isn't within the button sphere at
        // your feet. If not, you could get trapped.
        if (newPt.y - ptBelowStarePt.y < 0.5 * Vars.BUTTON_SPHERE_RADIUS + 0.1) {
            newPt.y = ptBelowStarePt.y + 0.5 * Vars.BUTTON_SPHERE_RADIUS + 0.1;
        }
        // Set the new height. 0.01 is important so elipse doesn't get caught on
        // new ground.
        Vars.setCameraHeight(Points.curStarePt.y - ptBelowStarePt.y);
        teleport(newPt, function () {
            // Make sure the collision elipsoid surrounding the non-VR camera
            // matches the new height.
            NonVRCamera.setCameraElipsoid();
        });
    }
    var captureMouseClicksDiv = undefined;
    var currentlyCapturingMouseClicks = false;
    /**
     * Setup the ability to capture clicks.
     * @returns void
     */
    function setupCaptureMouseClicksOutsideBabylon() {
        // Unfortunately, when you click on phones it takes away control from the
        // orientation sensor. Babylon.js claims to have fixed this, but I don't
        // think it is fixed: https://github.com/BabylonJS/Babylon.js/pull/6042
        // I'm going to detect if it's currently reading from the orientation
        // sensor and throw up a div to capture clicks if it is. A hackish
        // solution that works.
        // Setup div to intercept clicks if needed. Add clear div over canvas.
        captureMouseClicksDiv = jQuery("#capture-clicks");
        // captureMouseClicksDiv = jQuery("#renderCanvas");
        // Make it clickable.
        captureMouseClicksDiv.click(function () {
            console.log("clicked!");
            actOnStareTrigger();
        });
        // captureMouseClicksDiv.on("pointerdown", () => {
        //     alert("hello!");
        // });
        Vars.scene.registerBeforeRender(function () {
            checkCaptureMouseClicksOutsideBabylon();
        });
    }
    /**
     * Checks if you should currently be capturing clicks. TODO: Should you be
     * checking this with every render? I don't know that it can change, so maybe
     * you just need to check it once?
     * @returns void
     */
    function checkCaptureMouseClicksOutsideBabylon() {
        var deviceOrientation = Vars.scene.activeCamera.inputs.attached.deviceOrientation;
        var deviceBeingOriented;
        if (!deviceOrientation) {
            // On htc vive, deviceOrientation does not exist.
            deviceBeingOriented = false;
        }
        else {
            // Check other devices (whether in browser or in cardboard, etc).
            deviceBeingOriented = (deviceOrientation._alpha !== 0) ||
                (deviceOrientation._beta !== 0) ||
                (deviceOrientation._gamma !== 0);
        }
        if (deviceBeingOriented && !currentlyCapturingMouseClicks) {
            currentlyCapturingMouseClicks = true;
            captureMouseClicksDiv.show();
            // console.log("show");
        }
        else if (!deviceBeingOriented && currentlyCapturingMouseClicks) {
            currentlyCapturingMouseClicks = false;
            captureMouseClicksDiv.hide();
            // console.log("hide");
        }
        else {
            // console.log("confused");
            // console.log(deviceBeingOriented);
            // console.log(currentlyCapturingMouseClicks);
        }
    }
});

// This module includes functions to manage which meshes in the scene are
// pickable.
define('Navigation/Pickables',["require", "exports", "../Cameras/CommonCamera", "../Scene/Optimizations", "../Vars", "./Navigation"], function (require, exports, CommonCamera, Optimizations, Vars, Navigation) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var pickableMeshes = [];
    var pickableButtons = [];
    var pickableMolecules = [];
    /**
     * Sets the currently picked mesh.
     * @param  {*} mesh The mesh.
     */
    function setCurPickedMesh(mesh) { exports.curPickedMesh = mesh; }
    exports.setCurPickedMesh = setCurPickedMesh;
    /**
     * Sets up the pickables.
     * @returns void
     */
    function setup() {
        pickableMeshes.push(Vars.vrVars.groundMesh);
    }
    exports.setup = setup;
    /**
     * Adds a mesh to the list of pickable buttons.
     * @param  {*} mesh The mesh.
     * @returns void
     */
    function addPickableButton(mesh) {
        pickableMeshes.push(mesh);
        pickableButtons.push(mesh);
        Optimizations.optimizeMeshPicking(mesh);
        makeMeshMouseClickable({
            mesh: mesh,
            callBack: function () {
                // Here click the button rather than acting on the stare point
                // (default).
                mesh.clickFunc();
            },
        });
    }
    exports.addPickableButton = addPickableButton;
    /**
     * Adds a mesh to the list of pickable molecule meshes.
     * @param  {*} mesh The mesh.
     * @returns void
     */
    function addPickableMolecule(mesh) {
        pickableMeshes.push(mesh);
        pickableMolecules.push(mesh);
        Optimizations.optimizeMeshPicking(mesh);
        makeMeshMouseClickable({ mesh: mesh });
    }
    exports.addPickableMolecule = addPickableMolecule;
    /**
     * Determines if a given mesh is pickable.
     * @param  {*} mesh The mesh.
     * @returns boolean True if it is pickable. False otherwise.
     */
    function checkIfMeshPickable(mesh) {
        // Floor is always pickable, even if not visible.
        if (mesh.id === Vars.vrVars.groundMesh.id) {
            return true;
        }
        // If not visible, then not pickable. Note that something could be
        // entirely transparent (visibility is 0), but it will still intercept the
        // stare point. This is by design.
        if (!mesh.isVisible) {
            return false;
        }
        // if (mesh.visibility === 0) { return false; }
        // Otherwise, pick only if in the list.
        return pickableMeshes.indexOf(mesh) !== -1;
    }
    exports.checkIfMeshPickable = checkIfMeshPickable;
    /**
     * Get the category of the currently selected mesh.
     * @returns *
     */
    function getCategoryOfCurMesh() {
        if (exports.curPickedMesh === undefined) {
            return 1 /* None */;
        }
        else if (exports.curPickedMesh === Vars.vrVars.groundMesh) {
            return 2 /* Ground */;
        }
        else if (pickableButtons.indexOf(exports.curPickedMesh) !== -1) {
            return 3 /* Button */;
        }
        else if (pickableMolecules.indexOf(exports.curPickedMesh) !== -1) {
            return 4 /* Molecule */;
        }
        else if (exports.curPickedMesh === exports.padNavSphereAroundCamera) {
            return 5 /* padNavSphereAroundCamera */;
        }
        else {
            return 1 /* None */;
        }
    }
    exports.getCategoryOfCurMesh = getCategoryOfCurMesh;
    /**
     * Make it so a given mesh can be clicked with the mouse.
     * @param  {Object<string,*>} params The parameters. See interface above.
     * @returns void
     */
    function makeMeshMouseClickable(params) {
        if (params.callBack === undefined) {
            params.callBack = Navigation.actOnStareTrigger;
        }
        if (params.scene === undefined) {
            params.scene = Vars.scene;
        }
        if (params.mesh === undefined) {
            return;
        }
        params.mesh.actionManager = new BABYLON.ActionManager(params.scene);
        params.mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, function () {
            // If it's in VR mode, there are no mouse clicks. This is
            // important to prevent a double click with controllers.
            if (Vars.vrVars.navMode !== 3 /* NoVR */) {
                // TODO: What about phones? Still clickable? May need to
                // modify above.
                return;
            }
            params.callBack();
        }));
    }
    exports.makeMeshMouseClickable = makeMeshMouseClickable;
    /**
     * Places a cube around the canmera so you can navegate even when not pointing
     * at a molecule or anything. Good for pad-based navigation, but not
     * teleportation.
     * @returns void
     */
    function makePadNavigationSphereAroundCamera() {
        exports.padNavSphereAroundCamera = BABYLON.Mesh.CreateSphere("padNavSphereAroundCamera", 4, Vars.MAX_TELEPORT_DIST - 1.0, Vars.scene);
        exports.padNavSphereAroundCamera.flipFaces(true);
        var mat = new BABYLON.StandardMaterial("padNavSphereAroundCameraMat", Vars.scene);
        mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        mat.specularColor = new BABYLON.Color3(0, 0, 0);
        mat.opacityTexture = null;
        exports.padNavSphereAroundCamera.material = mat;
        exports.padNavSphereAroundCamera.visibility = 0.0; // It's an invisible sphere.
        // Doing it this way so follows camera even if camera changes.
        Vars.scene.registerBeforeRender(function () {
            exports.padNavSphereAroundCamera.position = CommonCamera.getCameraPosition();
        });
        // It needs to be pickable
        pickableMeshes.push(exports.padNavSphereAroundCamera);
        // Pretend like it's a molecule. Teleportation will be disabled elsewhere.
        // addPickableMolecule(padNavSphereAroundCamera);
    }
    exports.makePadNavigationSphereAroundCamera = makePadNavigationSphereAroundCamera;
});

define('Cameras/VRControllers',["require", "exports", "../Navigation/Navigation", "../Navigation/Pickables", "../Navigation/Points", "../Vars", "./CommonCamera", "./VRCamera"], function (require, exports, Navigation, Pickables, Points, Vars, CommonCamera, VRCamera) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lastTriggerTime = 0;
    var lastPadRotationTime = 0;
    var padMoveSpeedFactor = 0.0;
    var padRotateSpeedFactor = 0.0;
    var padPressed = false;
    /**
     * Sets up the enter and exit functions when controllers load. No unload
     * function, though I'd like one.
     * @returns void
     */
    function setup() {
        // Put a cube around the camera. This is to receive picker for pad-based
        // navigation, even if you're not pointing at a protein.
        Pickables.makePadNavigationSphereAroundCamera();
        // onControllersAttachedObservable doesn't work. I'd prefer that one...
        Vars.vrHelper.webVRCamera.onControllerMeshLoadedObservable.add(function (webVRController) {
            // Update navMode
            // console.re.clear();
            // console.re.log("moo1");
            Vars.vrVars.navMode = 1 /* VRWithControllers */;
            console.log("controller loaded");
            VRCamera.setupGazeTracker();
            console.log("Isnt there on pickable or something");
            setupTrigger(webVRController);
            setupPad(webVRController);
        });
        // Doesn't appear to be a detach function...
    }
    exports.setup = setup;
    /**
     * Sets up the trigger button.
     * @param  {*} webVRController The web controller object.
     * @returns void
     */
    function setupTrigger(webVRController) {
        // Monitor for triggers. Only allow one to fire every once in a while.
        // When it does, teleport to that location.
        webVRController.onTriggerStateChangedObservable.add(function (state) {
            if (!state["pressed"]) {
                // Only trigger if it's pressed.
                return;
            }
            var curTime = new Date().getTime();
            // console.log(curTime, lastTriggerTime, curTime - lastTriggerTime, Vars.VR_CONTROLLER_TRIGGER_DELAY_TIME);
            if (curTime - lastTriggerTime > Vars.VR_CONTROLLER_TRIGGER_DELAY_TIME) {
                // Enough time has passed...
                // console.log("triggered");
                lastTriggerTime = curTime;
                Navigation.actOnStareTrigger();
            }
        });
    }
    /**
     * Sets up the VR controller pads.
     * @param  {*} webVRController
     * @returns void
     */
    function setupPad(webVRController) {
        // console.re.log("moo2");
        // Also allow navigation via the pad (non teleporting).
        // console.log(webVRController);
        webVRController.onPadStateChangedObservable.add(function (state) {
            // console.re.log("DEBUG: onPadStateChangedObservable");
            padPressed = state["pressed"];
            if ((padPressed) &&
                (Math.abs(padMoveSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET) &&
                (Math.abs(padRotateSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET)) {
                console.log("Would reset camera view if you didn't get an error below...");
                // Vars.vrHelper.webVRCamera.resetToCurrentRotation();
                return;
            }
        });
        // webVRController.onMainButtonStateChangedObservable.add((state) => {
        //     console.re.log("DEBUG: onMainButtonStateChangedObservable");
        // });
        // webVRController.onSecondaryButtonStateChangedObservable.add((state) => {
        //     console.re.log("DEBUG: onSecondaryButtonStateChangedObservable");
        // });
        // webVRController.onMenuButtonStateChangedObservable.add((state) => {
        //     console.re.log("DEBUG: onMenuButtonStateChangedObservable");
        // });
        webVRController.onPadValuesChangedObservable.add(function (state) {
            // If it's not a press right in the middle, then save the y value for
            // moving foward/backward.
            padMoveSpeedFactor = state["y"];
            // Also save the x for turning. But here you can make people really
            // sick, so only trigger if on outer 4ths of pad (no accidents).
            padRotateSpeedFactor = state["x"];
            // First check if it's right in the middle. That's reset camera zone,
            // so cancel.
            if ((Math.abs(padRotateSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET) &&
                (Math.abs(padMoveSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET)) {
                padMoveSpeedFactor = 0;
                padRotateSpeedFactor = 0;
                return;
            }
            // Unless you're pretty far to the left or right, don't count it.
            if (Math.abs(padRotateSpeedFactor) < 0.5) {
                padRotateSpeedFactor = 0.0;
            }
            else {
                // Scale the rotation speed factor
                padRotateSpeedFactor = padRotateSpeedFactor + ((padRotateSpeedFactor > 0) ? -0.5 : 0.5);
                padRotateSpeedFactor = 2.0 * padRotateSpeedFactor;
            }
        });
        // Check the pad state at every render and act accordingly.
        Vars.scene.registerBeforeRender(function () {
            if (padPressed) {
                moveCamera();
                rotateCamera();
            }
        });
    }
    /**
     * Moves the camera slightly forward. TODO: Shouldn't this be in
     * Navigation.ts?
     * @returns void
     */
    function moveCamera() {
        // No point in proceeding if you don't have a stare point.
        if (Points.curStarePt.equals(Points.pointWayOffScreen)) {
            return;
        }
        // Get the vector form the stare point to the camera. TODO: This is also
        // calculated elsewhere. Could put it in its own function or even cache it
        // for speed.
        var cameraPos = CommonCamera.getCameraPosition();
        var vecStarePtCamera = Points.curStarePt.subtract(cameraPos);
        vecStarePtCamera.normalize();
        var deltaVec = vecStarePtCamera.scale(padMoveSpeedFactor * Vars.PAD_MOVE_SPEED * Vars.scene.getAnimationRatio());
        // console.log(padMoveSpeedFactor, Vars.PAD_MOVE_SPEED, Vars.scene.getAnimationRatio(), deltaVec, vecStarePtCamera);
        CommonCamera.setCameraPosition(cameraPos.subtract(deltaVec));
    }
    /**
     * Rotates the VR camera slightly. TODO: Shouldn't this be in Navigation.ts?
     * @returns void
     */
    function rotateCamera() {
        if (padRotateSpeedFactor === 0) {
            // Why proceed if there is no rotation?
            return;
        }
        var nowTime = new Date().getTime();
        if (nowTime - lastPadRotationTime < Vars.VR_CONTROLLER_PAD_ROTATION_DELAY_TIME) {
            // Avoid rapid/continuous rotations. I tested this. It makes people
            // want to vomit.
            return;
        }
        lastPadRotationTime = nowTime;
        // Get the camera's current rotation.
        var curAngles = Vars.vrHelper.webVRCamera.rotationQuaternion.toEulerAngles();
        // Rotate it slightly about up axis.
        // curAngles.y += 0.1 * padRotateSpeedFactor * Vars.PAD_MOVE_SPEED * Vars.scene.getAnimationRatio();
        // curAngles.y = curAngles.y + Math.sign(padRotateSpeedFactor) * 0.0625 * Math.PI;
        // Rotates 45 degrees for rapid reorientation.
        curAngles.y = curAngles.y + Math.sign(padRotateSpeedFactor) * 0.25 * Math.PI;
        // Set camera to this new rotation.
        Vars.vrHelper.webVRCamera.rotationQuaternion = BABYLON.Quaternion.FromEulerVector(curAngles);
    }
});

// This module sets up the VR camera.
define('Cameras/VRCamera',["require", "exports", "../Navigation/Pickables", "../Scene/Optimizations", "../Vars", "./VRControllers"], function (require, exports, Pickables, Optimizations, Vars, VRControllers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Sets up the VR camera.
     * @returns void
     */
    function setup() {
        // Setup different trigger VR functions (changes state, etc.)
        setupEnterAndExitVRCallbacks();
        VRControllers.setup();
    }
    exports.setup = setup;
    /**
     * Sets up the enter and exit VR functions. When enters, sets up VR. When
     * exists, downgrades to non-VR navigation.
     * @returns void
     */
    function setupEnterAndExitVRCallbacks() {
        Vars.vrHelper.onEnteringVRObservable.add(function (a, b) {
            // Not sure what a and b are. Both are objects.
            // Update navMode
            Vars.vrVars.navMode = 2 /* VRNoControllers */;
            // Setup teleportation. If uncommented, this is the one that comes
            // with BABYLON.js.
            // setupCannedVRTeleportation();
            setupGazeTracker();
            // Reset selected mesh.
            Pickables.setCurPickedMesh(undefined);
            // You need to recalculate the shadows. I've found you get back
            // shadows in VR otherwise.
            Optimizations.updateEnvironmentShadows();
            window["vrHelper"] = Vars.vrHelper;
        });
        Vars.vrHelper.onExitingVRObservable.add(function () {
            // Update navMode
            Vars.vrVars.navMode = 3 /* NoVR */;
            // Reset selected mesh.
            Pickables.setCurPickedMesh(undefined);
            // Let's recalculate the shadows here again too, just to be on the
            // safe side.
            Optimizations.updateEnvironmentShadows();
        });
        // Vars.vrHelper.onNewMeshPicked.add((pickingInfo) => {
        //     // Callback receiving ray cast picking info
        //     Pickables.setCurPickedMesh(pickingInfo.pickedMesh);
        // });
        // Vars.vrHelper.onSelectedMeshUnselected.add((mesh) => {
        // Mesh has been unselected
        // Pickables.setCurPickedMesh(undefined);
        // Navigation.setCurStarePt(Navigation.pointWayOffScreen);
        // console.log(mesh, Pickables.curPickedMesh, Navigation.curStarePt);
        // console.log("GGGG");
        // });
    }
    /**
     * A placeholder mesh. Not technically empty, but pretty close.
     * @returns {*} The custom mesh (almost an empty).
     */
    function makeEmptyMesh() {
        var customMesh = new BABYLON.Mesh("vrNavTargetMesh", Vars.scene);
        var positions = [0, 0, 0];
        var indices = [0];
        var vertexData = new BABYLON.VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        vertexData.applyToMesh(customMesh);
        customMesh.isVisible = false;
        return customMesh;
    }
    /**
     * Sets up the VR gaze tracking mesh.
     * @returns void
     */
    function setupGazeTracker() {
        Vars.vrHelper.raySelectionPredicate = function (mesh) {
            // if (!mesh.isVisible) {
            //     return false;
            // }
            return Pickables.checkIfMeshPickable(mesh);
        };
        // Make an invisible mesh that will be positioned at location of gaze.
        Vars.vrHelper.gazeTrackerMesh = makeEmptyMesh();
        Vars.vrHelper.updateGazeTrackerScale = false; // Babylon 3.3 preview.
        Vars.vrHelper.displayGaze = true; // Does need to be true. Otherwise, position not updated.
        Vars.vrHelper.enableInteractions();
        // window.vrHelper = Vars.vrHelper;
    }
    exports.setupGazeTracker = setupGazeTracker;
});

define('UI/Menu3D/Button',["require", "exports", "../../Navigation/Pickables", "../../Vars", "./Menu3D"], function (require, exports, Pickables, Vars, Menu3D) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var btnScale = new BABYLON.Vector3(0.75, 0.75, 0.75);
    var ButtonWrapper = /** @class */ (function () {
        /**
         * The constructor.
         * @param  {Object<string,*>} params
         * @constructor
         */
        function ButtonWrapper(params) {
            var _this = this;
            // Make the button
            this.button = new BABYLON.GUI.HolographicButton(params.name);
            params.panel.addControl(this.button);
            // Make the possible materials (different colors).
            this.makeColorMats();
            // Change button color if appropriate.
            if (params.color !== undefined) {
                this.updateColor(params.color);
            }
            // Save the level.
            this.level = params.level;
            // Make a text block
            this.textBlock = new BABYLON.GUI.TextBlock();
            this.textBlock.color = "white";
            this.textBlock.resizeToFit = true;
            // Save the value and text, etc.
            this.value = params.default;
            this.trueTxt = params.trueTxt;
            this.falseTxt = params.falseTxt;
            this.clickFunc = params.clickFunc;
            // Update the text.
            this.updateTxt();
            this.button.scaling = btnScale.clone();
            // Make the button clickable. No. It is the sphere that will trigger this...
            // this.button.onPointerClickObservable.add((e) => {
            // this.toggled();
            // });
            // Make a mesh that surrounds the button. It actually triggers the
            // click.
            this.containingMesh = BABYLON.Mesh.CreateSphere(params.name + "-container-mesh", 2, Vars.BUTTON_SPHERE_RADIUS, Vars.scene);
            this.containingMesh.position = this.button.node.absolutePosition;
            this.containingMesh.visibility = 0;
            this.containingMesh.scaling = btnScale.clone();
            // Add a clicking function to the mesh.
            this.containingMesh.clickFunc = function () {
                _this.toggled();
            };
            // Add the mesh to the list of ones that are pickable.
            Pickables.addPickableButton(this.containingMesh);
            if (params.initFunc !== undefined) {
                params.initFunc(this);
            }
        }
        ButtonWrapper.prototype.updateColor = function (color) {
            switch (color) {
                case "default":
                    this.button.mesh.material = this.defaultMat;
                    break;
                case undefined: // Also default
                    this.button.mesh.material = this.defaultMat;
                    break;
                case "green":
                    this.button.mesh.material = this.greenMat;
                    break;
                case "yellow":
                    this.button.mesh.material = this.yellowMat;
                    break;
                case "red":
                    this.button.mesh.material = this.redMat;
                    break;
                default:
            }
        };
        /**
         * Determines if this button is visible.
         * @param  {boolean} [val=] Whether this button is visible.
         * @returns void
         */
        ButtonWrapper.prototype.isVisible = function (val) {
            if (val === undefined) {
                // A getter
                return this.button.isVisible;
            }
            else {
                // A setter. Note that this doesn't affect visibility on meshes
                // (they could be entirely transparent).
                //     mesh.actionManager
                // .registerAction(
                // )
                this.button.isVisible = val;
                this.containingMesh.isVisible = val;
            }
        };
        /**
         * Toggle whether this button is visible.
         * @returns void
         */
        ButtonWrapper.prototype.toggled = function () {
            // Play the sound.
            Menu3D.clickSound.setPosition(this.containingMesh.position.clone());
            Menu3D.clickSound.play();
            // Switch value.
            this.value = !this.value;
            // Fire the user-defined trigger.
            this.clickFunc(this);
            // Update the text.
            this.updateTxt();
        };
        /**
         * Sets the text on this button.
         * @param {string=} txt  The text to update. If undefined, gets it based
         *                       on the value, trueTxt, and falseTxt variables.
         * @returns void
         */
        ButtonWrapper.prototype.updateTxt = function (txt) {
            if (txt === undefined) {
                this.textBlock.text = this.value ? this.trueTxt : this.falseTxt;
            }
            else {
                this.textBlock.text = txt;
                this.trueTxt = txt;
                this.falseTxt = txt;
            }
            this.button.content.dispose();
            this.button.content = this.textBlock;
        };
        ButtonWrapper.prototype.makeColorMats = function () {
            var colorDelta = 0.1;
            this.defaultMat = this.button.mesh.material;
            this.greenMat = this.button.mesh.material.clone();
            this.greenMat.albedoColor = new BABYLON.Color3(0.3, 0.35 + colorDelta, 0.4);
            this.yellowMat = this.button.mesh.material.clone();
            this.yellowMat.albedoColor = new BABYLON.Color3(0.3 + colorDelta, 0.35 + colorDelta, 0.4);
            this.redMat = this.button.mesh.material.clone();
            this.redMat.albedoColor = new BABYLON.Color3(0.3 + colorDelta, 0.35, 0.4);
        };
        return ButtonWrapper;
    }());
    exports.ButtonWrapper = ButtonWrapper;
});

define('UI/OpenPopup',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var botstrapLoaded = false;
    var modalFunc;
    function openUrlModal(title, url) {
        // Load the css if needed.
        if (!botstrapLoaded) {
            botstrapLoaded = true;
            // Add the css
            document.head.insertAdjacentHTML("beforeend", "<link rel=stylesheet href=help/css/bootstrap.min.css>");
            // Add the DOM for a modal
            document.body.insertAdjacentHTML("beforeend", "\n            <!-- The Modal -->\n            <div class=\"modal fade\" id=\"myModal\" role=\"dialog\">\n                <div class=\"modal-dialog\" role=\"document\">\n                    <div class=\"modal-content\">\n\n                    <!-- Modal Header -->\n                    <div class=\"modal-header\">\n                        <h4 class=\"modal-title\">Modal Heading</h4>\n                        <button type=\"button\" class=\"close\" data-dismiss=\"modal\">&times;</button>\n                    </div>\n\n                    <!-- Modal body -->\n                    <div class=\"modal-body\">\n                        <div class=\"embed-responsive embed-responsive-1by1\">\n                            <iframe class=\"embed-responsive-item\" src=\"\"></iframe>\n                        </div>\n                    </div>\n\n                    <!-- Modal footer -->\n                    <!-- <div class=\"modal-footer\">\n                        <button type=\"button\" class=\"btn btn-primary\" data-dismiss=\"modal\">Close</button>\n                    </div> -->\n                </div>\n            </div>\n        ");
            // Add the javascript
            // jQuery.getScript( "help/scripts/popper.min.js", ( data, textStatus, jqxhr ) => {
            jQuery.getScript("help/scripts/bootstrap.min.js", function (data, textStatus, jqxhr) {
                modalFunc = jQuery.prototype.modal; // Save for later use.
                openUrlModalContinue(title, url);
            });
            // });
        }
        else {
            openUrlModalContinue(title, url);
        }
    }
    exports.openUrlModal = openUrlModal;
    function openUrlModalContinue(title, url) {
        jQuery.prototype.modal = modalFunc;
        var myModal = jQuery("#myModal");
        myModal.find("h4.modal-title").html(title);
        myModal.find("iframe").attr("src", url);
        myModal.modal();
    }
});
// window["openUrlModal"] = openUrlModal;

// Functions common to all loaded molecules, regardless of source.
define('Mols/CommonLoader',["require", "exports", "../Navigation/Pickables", "../Scene/LoadAndSetup", "../Scene/Optimizations", "../Vars", "./Shadows"], function (require, exports, Pickables, LoadAndSetup, Optimizations, Vars, Shadows) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Run this before loading.
     * @returns void
     */
    function beforeLoading() {
        // Set up the shadow generator.
        Shadows.setupShadowGenerator();
        // Make UVs work
        BABYLON.OBJFileLoader.OPTIMIZE_WITH_UV = true;
    }
    exports.beforeLoading = beforeLoading;
    /**
     * @param  {Object<string,*>} sceneInfoData The data from scene_info.json.
     * @returns void
     */
    function afterLoading(sceneInfoData) {
        Shadows.setupShadowCatchers(); // Related to extras, so keep it here.
        // Do you need to make the ground glass instead of invisible? See
        // scene_info.json, which can have transparentGround: true.
        if ((sceneInfoData["transparentGround"] !== undefined) && (sceneInfoData["transparentGround"] === true)) {
            if (Vars.vrVars.groundMesh) {
                Vars.vrVars.groundMesh.visibility = 1;
                var transparentGround = new BABYLON.StandardMaterial("transparentGround", Vars.scene);
                transparentGround.diffuseColor = new BABYLON.Color3(1, 1, 1);
                transparentGround.specularColor = new BABYLON.Color3(0, 0, 0);
                transparentGround.emissiveColor = new BABYLON.Color3(0, 0, 0);
                transparentGround.alpha = Vars.TRANSPARENT_FLOOR_ALPHA;
                // transparentGround.ambientColor = new BABYLON.Color3(0.23, 0.98, 0.53);
                Vars.vrVars.groundMesh.material = transparentGround;
                // let glass = new BABYLON.PBRMaterial("glass", Vars.scene);
                // glass.reflectionTexture = hdrTexture;
                // glass.refractionTexture = hdrTexture;
                // glass.linkRefractionWithTransparency = true;
                // glass.indexOfRefraction = 0.52;
                // glass.alpha = 0; // Fully refractive material
                // Vars.vrVars.groundMesh.material = glass;
            }
            else {
                console.log("Warning: Vars.vrVars.groundMesh not defined.");
            }
        }
        // Finish up all scene preparations.
        LoadAndSetup.loadingAssetsDone();
    }
    exports.afterLoading = afterLoading;
    /**
     * Sets up a molecule mesh.
     * @param  {*}      mesh           The mesh.
     * @param  {string} objID          A string identifying this mesh.
     * @param  {*}      shadowQuality  The shadow quality. Like "Skip".
     * @param  {number} uniqIntID      A unique numerical id that identifies this
     *                                 mesh.
     * @returns void
     */
    function setupMesh(mesh, objID, shadowQuality, uniqIntID) {
        if ((mesh.material !== undefined) && (mesh.material !== null)) {
            // if (shadowQuality !== "Skip") {
            //     // So using shadows baked from blender.
            //     // Save the side orientation before removing mesh.
            //     let oldMatOrien = mesh.material.sideOrientation;
            //     // Remove existing material
            //     mesh.material.dispose();
            //     mesh.material = null;
            //     // Make sure not alpha blended.
            //     mesh.hasVertexAlpha = false;
            //     mesh.visibility = true;
            //     // Create new material
            //     let mat = new BABYLON.StandardMaterial("molMat" + uniqIntID.toString(), Vars.scene);
            //     mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            //     mat.specularColor = new BABYLON.Color3(0, 0, 0);
            //     mat.opacityTexture = null;
            //     mat.sideOrientation = oldMatOrien;
            //     // mat.diffuseTexture.hasAlpha = false;
            //     let texName = objID + ".png";
            //     let tex = new BABYLON.Texture(  // lightmapTexture
            //         texName, Vars.scene,
            //     );
            //     tex.vScale = -1;
            //     mat.emissiveTexture = tex;
            //     mat.disableLighting = true;
            //     mat.sideOrientation = BABYLON.Material.ClockWiseSideOrientation;
            //     mat.backFaceCulling = false;
            //     // Add it to the mesh
            //     mesh.material = mat;
            //     // Freeze the material (improves optimization).
            //     Optimizations.freezeMeshProps(mesh);
            // } else {
            // Not using baked shadows. Add a small emission color so the dark
            // side of the protein isn't too dark.
            var lightingInf = Shadows.getBlurDarknessFromLightName();
            // Experience:
            // In Couch scene, background luminosity of 0.01 is good. There shadow darkness was 0.9625
            // In House scene, background luminosity of 0.0025 is good. There shadow darkness was 0.35.
            // Let's play around with a scheme for guessing at the right background luminosity.
            var backgroundLum = void 0;
            if (lightingInf.darkness > 0.95) {
                backgroundLum = 0.05;
            }
            else if (lightingInf.darkness < 0.4) {
                backgroundLum = 0.0025;
            }
            else {
                // Scaled
                // (0.95, 0.01)
                // (0.4, 0.0025)
                // let m = 0.013636363636363637;  // (0.01 - 0.0025) / (0.95 - 0.4);
                // let b = -0.0029545454545454545;  // 0.01 - 0.013636363636363637 * 0.95;
                backgroundLum = 0.013636363636363637 * lightingInf.darkness - 0.0029545454545454545;
            }
            // backgroundLum = 1;
            mesh.material.emissiveColor = new BABYLON.Color3(backgroundLum, backgroundLum, backgroundLum);
            // let ssao = new BABYLON.SSAORenderingPipeline("ssaopipeline", Vars.scene, 0.75);
            // Enable transparency (for fading in and out).
            // mesh.material.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHABLEND;
            // Freeze the material (improves optimization).
            Optimizations.freezeMeshProps(mesh);
        }
        // }
        // This is required to position correctly.
        mesh.scaling.z = -1;
        if (uniqIntID > 0) {
            mesh.scaling.x = -1;
        }
        // Make it so it casts a shadow.
        if (Shadows.shadowGenerator) {
            Shadows.shadowGenerator.getShadowMap().renderList.push(mesh);
        }
        // Make it pickable
        Pickables.addPickableMolecule(mesh);
    }
    exports.setupMesh = setupMesh;
});

define('Mols/3DMol/VRMLParserWebWorker',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var DATA_CHUNK_SIZE = 10000000;
    var dataToSendBack = undefined;
    var numRegex = new RegExp("(^|-| )[0-9\.]{1,8}", "g");
    var geoCenter = undefined;
    // Determine if we're in a webworker. See
    // https://stackoverflow.com/questions/7931182/reliably-detect-if-the-script-is-executing-in-a-web-worker
    var inWebWorker = false;
    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
        inWebWorker = true;
    }
    // Get the data from the main thread, if webworker.
    if (inWebWorker) {
        self.onmessage = function (e) {
            var cmd = e.data["cmd"];
            var data = e.data["data"];
            var removeExtraPts = e.data["removeExtraPts"];
            if (cmd === "start") {
                // This will populate dataToSendBack
                loadValsFromVRML(data, removeExtraPts);
                cmd = "sendDataChunk";
            }
            if (cmd === "sendDataChunk") {
                var chunkToSend = dataToSendBack.shift();
                var status_1 = (dataToSendBack.length === 0) ? "done" : "more";
                if (chunkToSend === undefined) {
                    // This happens if there's no mesh (i.e., ribbon on pure
                    // ligand).
                    status_1 = "done";
                }
                postMessage({
                    "chunk": chunkToSend,
                    "status": status_1,
                });
            }
        };
    }
    /**
     * Load in values like coordinates and colors from the VRML string.
     * @param  {string}    vrmlStr         The string containing the VRML data.
     * @param  {boolean=}  removeExtraPts  Whether to remove extra points at the
     *                                     origin. Sticks representation from
     *                                     3DMoljs unfortunately generates these.
     *                                     They make it hard to center sticks-only
     *                                     representations.
     * @returns Array<Object<string, Array<number>>>   The model data.
     */
    function loadValsFromVRML(vrmlStr, removeExtraPts) {
        if (removeExtraPts === void 0) { removeExtraPts = false; }
        var modelData = [];
        // A given VRML file could have multiple IndexedFaceSets. Divide and
        // handle separately.
        var vrmlChunks = vrmlStr.split("geometry IndexedFaceSet {").splice(1);
        for (var _i = 0, vrmlChunks_1 = vrmlChunks; _i < vrmlChunks_1.length; _i++) {
            var vrmlChunk = vrmlChunks_1[_i];
            // Extract the coordinates from the vrml text
            var coors = strToCoors(betweenbookends("point [", "]", vrmlChunk));
            // Remove stray points (added to the origin) if necessary.
            if (removeExtraPts) {
                coors = removeStrayPoints(coors);
            }
            // Make sure string keys for closure compiler, since web worker is
            // external.
            modelData.push({
                "colors": strToColors(betweenbookends("color [", "]", vrmlChunk)),
                "coors": coors,
                "trisIdxs": strToTris(betweenbookends("coordIndex [", "]", vrmlChunk)),
            });
        }
        // Now that you've collected all the data, go back and translate all the
        // vertixes so Center the coordinates at the origin. Makes it easier to
        // pivot at geometric center.
        if (geoCenter === undefined) {
            geoCenter = getGeometricCenter(modelData);
        }
        modelData = translateBeforeBabylonImport(geoCenter, modelData);
        if (!inWebWorker) {
            return modelData;
        }
        else {
            // Now you need to chunk all the data. This is because you can only
            // transfer so much data back to the main thread at a time.
            dataToSendBack = [];
            var dataTypes = ["colors", "coors", "trisIdxs"];
            for (var modelIdx in modelData) {
                if (modelData.hasOwnProperty(modelIdx)) {
                    for (var _a = 0, dataTypes_1 = dataTypes; _a < dataTypes_1.length; _a++) {
                        var dataType = dataTypes_1[_a];
                        var chunks = chunk(modelData[+modelIdx][dataType]);
                        for (var _b = 0, chunks_1 = chunks; _b < chunks_1.length; _b++) {
                            var chunk_1 = chunks_1[_b];
                            dataToSendBack.push([+modelIdx, dataType, chunk_1]);
                        }
                    }
                }
            }
            return [];
        }
    }
    exports.loadValsFromVRML = loadValsFromVRML;
    /**
     * Fixes 0,0,0 points from the coordinates. 3DMoljs unfortunately adds these
     * to stick representations.
     * @param  {*} pts The coordinates. Float32Array.
     * @returns * Float32Array
     */
    function removeStrayPoints(pts) {
        console.log("Removing extra points.");
        var firstX = pts[0];
        var firstY = pts[1];
        var firstZ = pts[2];
        var coorsLen = pts.length;
        for (var coorIdx = 0; coorIdx < coorsLen; coorIdx = coorIdx + 3) {
            var idx2 = coorIdx + 1;
            var idx3 = coorIdx + 2;
            if ((pts[coorIdx] === 0) && (pts[idx2] === 0) && (pts[idx3] === 0)) {
                pts[coorIdx] = firstX;
                pts[idx2] = firstY;
                pts[idx3] = firstZ;
            }
        }
        return pts;
    }
    exports.removeStrayPoints = removeStrayPoints;
    /**
     * Divides an array into an array of arrays.
     * @param  {Array<*>} arr  The original array.
     * @returns {Array<Array<*>>}  The array of arrays.
     */
    function chunk(arr) {
        // See https://stackoverflow.com/questions/8495687/split-array-into-chunks
        var chunks = [];
        var i = 0;
        var n = arr.length;
        while (i < n) {
            chunks.push(arr.slice(i, i += DATA_CHUNK_SIZE));
        }
        return chunks;
    }
    /**
     * Converts coordinats in string format to list of numbers. Ordered per a
     * left-handed coordinate system.
     * @param  {string} str The coordinates in string format.
     * @returns * The list (actually a Float32Array... not sure how to type this.)
     */
    function strToCoors(str) {
        // Convert coordinates in string form to arrays.
        var coorStrs = str.match(numRegex);
        var coorLen = coorStrs.length;
        var coors = new Float32Array(coorLen);
        for (var i = 0; i < coorLen; i = i + 3) {
            // Note the order here. To convert to left-handed coor system. Note
            // also you must use array with push because you don't know ahead of
            // time how many coordinates there will be.
            coors[i] = +coorStrs[i + 2];
            coors[i + 1] = +coorStrs[i + 1];
            coors[i + 2] = +coorStrs[i];
        }
        // Now convert it to a typed array, which is much faster.
        return coors;
    }
    ;
    /**
     * Converts colors in string format to list of numbers. Similar to
     * strToCoors(), but for colors.
     * @param  {string} str The colors in string format.
     * @returns * The list (actually a Float32Array... not sure how to type this.)
     */
    function strToColors(str) {
        // Convert coordinates in string form to arrays.
        var colorStrs = str.match(numRegex);
        var colorStrsLen = colorStrs.length;
        var colors = new Float32Array(4 * colorStrsLen / 3);
        var colorLen = colors.length;
        for (var i = 0; i < colorLen; i = i + 4) {
            var i2 = 3 * i / 4;
            colors[i] = +colorStrs[i2];
            colors[i + 1] = +colorStrs[i2 + 1];
            colors[i + 2] = +colorStrs[i2 + 2];
            colors[i + 3] = 1.0;
        }
        // Now convert it to a typed array, which is much faster.
        return colors;
    }
    ;
    /**
     * Converts coordIndex in string format to list of numbers. Similar to
     * strToCoors(), but for indexes.
     * @param  {string} str The indexes in string format.
     * @returns * The list (actually a Uint32Array... not sure how to type this.)
     */
    function strToTris(str) {
        // Convert coordinates in string form to arrays.
        var indexStrs = str.match(numRegex);
        var indexStrsLen = indexStrs.length;
        var indexLen = 3 * indexStrsLen / 4;
        var indexes = new Uint32Array(indexLen);
        for (var i = 0; i < indexLen; i = i + 3) {
            var i2 = 4 * i / 3;
            indexes[i] = +indexStrs[i2];
            indexes[i + 1] = +indexStrs[i2 + 1];
            indexes[i + 2] = +indexStrs[i2 + 2];
        }
        return indexes;
    }
    ;
    /**
     * Gets the text betwen two strings.
     * @param  {string} bookend1 The first string.
     * @param  {string} bookend2 The second string.
     * @param  {string} str      The entire text to consider.
     * @returns string           The portion of str between bookend1 and bookend2.
     */
    function betweenbookends(bookend1, bookend2, str) {
        // Find the text between two bookends.
        var strArr = str.split(bookend1, 2);
        if (strArr.length <= 1) { // In case empty.
            return "";
        }
        strArr = strArr[1].split(bookend2, 2);
        var strBetween = strArr[0];
        return strBetween;
    }
    /**
     * Translate the coordinates before babylon import.
     * @param  {Array<number>}                         delta      The x, y, z to
     *                                                            translate.
     * @param  {Array<Object<string, Array<number>>>}  modelData  Information
     *                                                            about
     *                                                            coordinates,
     *                                                            colors, etc.
     * @returns Array<Object<string, Array<number>>>   Like model Data, but with
     *                                                 the coordinates translated.
     */
    function translateBeforeBabylonImport(delta, modelData) {
        var numModels = modelData.length;
        for (var modelIdx = 0; modelIdx < numModels; modelIdx++) {
            var coorsLen = modelData[modelIdx]["coors"].length;
            for (var coorIdx = 0; coorIdx < coorsLen; coorIdx = coorIdx + 3) {
                modelData[modelIdx]["coors"][coorIdx] = modelData[modelIdx]["coors"][coorIdx] - delta[0];
                modelData[modelIdx]["coors"][coorIdx + 1] = modelData[modelIdx]["coors"][coorIdx + 1] - delta[1];
                modelData[modelIdx]["coors"][coorIdx + 2] = modelData[modelIdx]["coors"][coorIdx + 2] - delta[2];
            }
        }
        return modelData;
    }
    /**
     * Calculate the geometric center of the coordinates.
     * @param  {Array<Object<string, Array<number>>>}  modelData  Information
     *                                                            about
     *                                                            coordinates,
     *                                                            colors, etc.
     * @returns * The x, y, z of the geometric center. Float32Array.
     */
    function getGeometricCenter(modelData) {
        // No coordinates... it's an empty mesh.
        if (modelData.length === 0) {
            return new Float32Array([0.0, 0.0, 0.0]);
        }
        var coorCountAllModels = modelData.map(function (m) { return m["coors"].length; }).reduce(function (a, b) { return a + b; });
        if (coorCountAllModels === 0) {
            // No coordinates... it's an empty mesh.
            return new Float32Array([0.0, 0.0, 0.0]);
        }
        var xTotal = 0;
        var yTotal = 0;
        var zTotal = 0;
        var numModels = modelData.length;
        for (var modelIdx = 0; modelIdx < numModels; modelIdx++) {
            var modelDatum = modelData[modelIdx];
            var coors = modelDatum["coors"];
            var coorsLen = coors.length;
            for (var coorIdx = 0; coorIdx < coorsLen; coorIdx = coorIdx + 3) {
                xTotal = xTotal + coors[coorIdx];
                yTotal = yTotal + coors[coorIdx + 1];
                zTotal = zTotal + coors[coorIdx + 2];
            }
        }
        var numCoors = coorCountAllModels / 3.0;
        xTotal = xTotal / numCoors;
        yTotal = yTotal / numCoors;
        zTotal = zTotal / numCoors;
        return new Float32Array([xTotal, yTotal, zTotal]);
    }
});

// An module to manage VRML data obtained from 3Dmol.js. Assumes the 3Dmol.js
// javascript file is already loaded.
define('Mols/3DMol/VRML',["require", "exports", "../../UrlVars", "../../Vars", "../CommonLoader", "./PositionInScene", "./VRMLParserWebWorker"], function (require, exports, UrlVars, Vars, CommonLoader, PositionInScene, VRMLParserWebWorker) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var modelData = [];
    exports.molRotation = new BABYLON.Vector3(0, 0, 0);
    var element;
    var config;
    var vrmlStr;
    var vrmlParserWebWorker;
    var molTxt = "";
    var molTxtType = "pdb";
    var hasActiveSurface = false;
    /**
     * Setup the ability to work with 3Dmol.js.
     * @param  {Function} callBack  Runs once the iframe is loaded is loaded.
     * @returns void
     */
    function setup(callBack) {
        // Add a container for 3dmoljs.
        addDiv();
        // Make the viewer object.
        element = jQuery("#mol-container");
        config = { backgroundColor: "white" };
        exports.viewer = $3Dmol.createViewer(element, config);
        // jQuery("#mol-container canvas")["attr"]("style", extraStyle);
        window["viewer"] = exports.viewer; // For debugging.
        callBack();
    }
    exports.setup = setup;
    /**
     * Add (or readd) div 3DMoljs div.
     * @returns void
     */
    function addDiv() {
        var molContainer = jQuery("#mol-container");
        if (molContainer) {
            molContainer.remove();
        }
        var extraStyle = "display:none;";
        // let extraStyle = "width:150px; height:150px; z-index:150; position:fixed; top:0; left:0;";
        jQuery("body").append("<div\n        id=\"mol-container\"\n        class=\"mol-container\"\n        style=\"" + extraStyle + "\"></div>");
    }
    function resetAll() {
        if (hasActiveSurface) {
            hasActiveSurface = false;
            // I can't get rid of the surfaces without causing
            // problems. I'm just going to go nuclear and reload the
            // whole thing.
            exports.viewer = null;
            setup(function () {
                exports.viewer.addModel(molTxt, "pdb");
            });
        }
        exports.viewer.setStyle({}, {});
    }
    exports.resetAll = resetAll;
    /**
     * Load a file into the 3dmol object.
     * @param  {string}     url     The url.
     * @param  {Function} callBack  A callback function. The 3DMoljs molecule
     *                              object is the parameter.
     * @returns void
     */
    function loadPDBURL(url, callBack) {
        jQuery.ajax(url, {
            "success": function (data) {
                // Setup the visualization
                molTxt = data; // In case you need to restart.
                molTxtType = "pdb";
                if (url.slice(url.length - 3).toLowerCase() === "sdf") {
                    molTxtType = "sdf";
                }
                var mdl = exports.viewer.addModel(data, molTxtType);
                // viewer.zoomTo();
                // render();  // Use default style.
                // viewer.render();
                callBack(mdl);
            },
            "error": function (hdr, status, err) {
                console.error("Failed to load molecule " + url + ": " + err);
            },
        });
    }
    exports.loadPDBURL = loadPDBURL;
    /**
     * Set the style on the 3DMoljs viewer.
     * @param  {Object<string,*>} sels  A selection object.
     * @param  {Object<string,*>} rep   A representation object.
     * @returns void
     */
    function setStyle(sels, rep) {
        exports.viewer.setStyle(sels, rep);
        exports.viewer.render();
    }
    exports.setStyle = setStyle;
    /**
     * Add a surface to the 3DMoljs viewer.
     * @param  {Object<string,*>} colorScheme  A colorscheme object.
     * @param  {Object<string,*>} sels         A selection object.
     * @param  {Function}         callBack     A callback function.
     * @returns void
     */
    function addSurface(colorScheme, sels, callBack) {
        hasActiveSurface = true;
        exports.viewer.addSurface($3Dmol.SurfaceType.MS, colorScheme, sels, undefined, undefined, function () {
            callBack();
        });
    }
    exports.addSurface = addSurface;
    /**
     * Sets the 3dmol.js style. Also generates a vrml string and values.
     * @param  {boolean}    updateData  Whether to update the underlying data with
     *                                  this visualization. True by default.
     * @param  {string}     repName     The representative name. Like "Surface".
     * @param  {Function=}  callBack    The callback function, with the new mesh
     *                                  as a parameter.
     * @returns void
     */
    function render(updateData, repName, callBack) {
        if (callBack === void 0) { callBack = function () { return; }; }
        // Make sure there are no waiting menus up and running. Happens some
        // times.
        Vars.engine.hideLoadingUI();
        // Render the style
        // viewer.render();
        if (updateData) {
            // Load the data.
            loadVRMLFrom3DMol(function () {
                loadValsFromVRML(repName, function () {
                    // Could modify coordinates before importing into babylon
                    // scene, so comment out below. Changed my mind the kinds of
                    // manipulations above should be performed on the mesh.
                    // Babylon is going to have better functions for this than I
                    // can come up with.
                    var newMesh = importIntoBabylonScene();
                    if (newMesh !== undefined) {
                        // It's undefined if, for example, trying to do cartoon on
                        // ligand.
                        PositionInScene.positionAll3DMolMeshInsideAnother(newMesh, Vars.scene.getMeshByName("protein_box"));
                        callBack(newMesh); // Cloned so it won't change with new rep in future.
                    }
                    // Clean up.
                    modelData = [];
                });
            });
        }
    }
    exports.render = render;
    /**
     * Loads the VRML string from the 3Dmol instance.
     * @param  {Function=}  callBack    The callback function.
     * @returns void
     */
    function loadVRMLFrom3DMol(callBack) {
        // Make the VRML string from that model.
        vrmlStr = exports.viewer.exportVRML();
        callBack();
    }
    /**
     * Load in values like coordinates and colors from the VRML string.
     * @param  {string}  repName  The representative name. Like "Surface".
     * @returns void
     */
    function loadValsFromVRML(repName, callBack) {
        // Clear previous model data.
        modelData = [];
        if (typeof (Worker) !== "undefined") {
            if (typeof (vrmlParserWebWorker) === "undefined") {
                vrmlParserWebWorker = new Worker("VRMLParserWebWorker.js");
            }
            vrmlParserWebWorker.onmessage = function (event) {
                // Msg back from web worker
                var resp = event.data;
                var chunk = resp["chunk"];
                var status = resp["status"];
                if (chunk !== undefined) {
                    var modelIdx = chunk[0];
                    var dataType = chunk[1];
                    var vals = chunk[2];
                    if (modelData.length === modelIdx) {
                        modelData.push({
                            "coors": new Float32Array(0),
                            "colors": new Float32Array(0),
                            "trisIdxs": new Uint32Array(0),
                        });
                    }
                    modelData[modelIdx][dataType] = typedArrayConcat(dataType === "trisIdxs" ? Uint32Array : Float32Array, [modelData[modelIdx][dataType], vals]);
                }
                switch (status) {
                    case "more":
                        // There's more data. Request it now.
                        vrmlParserWebWorker.postMessage({
                            "cmd": "sendDataChunk",
                            "data": undefined,
                        });
                        break;
                    case "done":
                        // No more data. Run the callback.
                        // console.log(modelData);
                        callBack();
                        break;
                    default:
                        console.log("Error here!");
                }
            };
            // Send message to web worker.
            vrmlParserWebWorker.postMessage({
                "cmd": "start",
                "data": vrmlStr,
                "removeExtraPts": (repName === "Stick"),
            });
        }
        else {
            // Sorry! No Web Worker support..
            modelData = VRMLParserWebWorker.loadValsFromVRML(vrmlStr);
            callBack();
        }
    }
    /**
     * Concatonates a list of typed arrays.
     * @param  {*} resultConstructor  The type of array. E.g., Uint8Array.
     * @param  {*} listOfArrays       A list of typed arrays to concatonate.
     * @returns * The typed array.
     */
    function typedArrayConcat(resultConstructor, listOfArrays) {
        // See http://2ality.com/2015/10/concatenating-typed-arrays.html
        var totalLength = 0;
        for (var _i = 0, listOfArrays_1 = listOfArrays; _i < listOfArrays_1.length; _i++) {
            var arr = listOfArrays_1[_i];
            totalLength += arr.length;
        }
        var result = new resultConstructor(totalLength);
        var offset = 0;
        for (var _a = 0, listOfArrays_2 = listOfArrays; _a < listOfArrays_2.length; _a++) {
            var arr = listOfArrays_2[_a];
            result.set(arr, offset);
            offset += arr.length;
        }
        return result;
    }
    /**
     * Creates a babylonjs object from the values and adds it to the babylonjs
     * scene.
     * @returns {*} The new mesh from the 3dmoljs instance.
     */
    function importIntoBabylonScene() {
        var meshes = [];
        for (var modelIdx in modelData) {
            if (modelData.hasOwnProperty(modelIdx)) {
                var modelDatum = modelData[modelIdx];
                // Calculate normals instead? It's not necessary. Doesn't chang over
                // 3dmoljs calculated normals.
                var norms = [];
                BABYLON.VertexData.ComputeNormals(modelDatum["coors"], modelDatum["trisIdxs"], norms);
                // Compile all that into vertex data.
                var vertexData = new BABYLON.VertexData();
                vertexData["positions"] = modelDatum["coors"]; // In quotes because from webworker (external)
                vertexData["indices"] = modelDatum["trisIdxs"];
                vertexData["normals"] = norms;
                vertexData["colors"] = modelDatum["colors"];
                // Delete the old mesh if it exists.
                // if (Vars.scene.getMeshByName("MeshFrom3DMol") !== null) {
                //     Vars.scene.getMeshByName("MeshFrom3DMol").dispose();
                // }
                // Make the new mesh
                var babylonMeshTmp = new BABYLON.Mesh("mesh_3dmol_tmp" + modelIdx, Vars.scene);
                vertexData.applyToMesh(babylonMeshTmp);
                // Add a material.
                var mat = new BABYLON.StandardMaterial("Material", Vars.scene);
                mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
                mat.emissiveColor = new BABYLON.Color3(0, 0, 0);
                mat.specularColor = new BABYLON.Color3(0, 0, 0);
                // mat.sideOrientation = BABYLON.Mesh.FRONTSIDE;
                // mat.sideOrientation = BABYLON.Mesh.BACKSIDE;
                babylonMeshTmp.material = mat;
                meshes.push(babylonMeshTmp);
            }
        }
        var babylonMesh;
        if (meshes.length > 0) {
            // Merge all these meshes.
            // https://doc.babylonjs.com/how_to/how_to_merge_meshes
            babylonMesh = BABYLON.Mesh.MergeMeshes(meshes, true, true); // dispose of source and allow 32 bit integers.
            // babylonMesh = meshes[0];
            babylonMesh.name = "MeshFrom3DMol" + Math.random().toString();
            babylonMesh.id = babylonMesh.name;
            // Work here
            CommonLoader.setupMesh(babylonMesh, babylonMesh.name, "Skip", 123456789);
        }
        return babylonMesh;
    }
    exports.importIntoBabylonScene = importIntoBabylonScene;
    /**
     * Rotate the molecular meshes.
     * @param  {string} axis    The axis. "x", "y", or "z".
     * @param  {number} amount  The amount. In radians, I think.
     * @returns void
     */
    function updateMolRotation(axis, amount) {
        exports.molRotation[axis] += amount;
        // Update URL too.
        UrlVars.setURL();
    }
    exports.updateMolRotation = updateMolRotation;
    /**
     * Setts the molRotation object externally.
     * @param  {number} x
     * @param  {number} y
     * @param  {number} z
     * @returns void
     */
    function setMolRotation(x, y, z) {
        exports.molRotation = new BABYLON.Vector3(x, y, z);
    }
    exports.setMolRotation = setMolRotation;
});

// Functions from loading molecules directly from a 3Dmol.js instance. See
// VRML.ts for additional functions related to the mesh itself.
define('Mols/3DMol/ThreeDMol',["require", "exports", "../../UI/Menu3D/Menu3D", "../../UI/OpenPopup", "../../UrlVars", "../CommonLoader", "./VRML"], function (require, exports, Menu3D, OpenPopup, UrlVars, CommonLoader, VRML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.atomicInfo = {};
    exports.modelUrl = "nanokid.sdf";
    /**
     * Setter for modelUrl.
     * @param  {string} url The new value.
     * @returns void
     */
    function setModelUrl(url) { exports.modelUrl = url; }
    exports.setModelUrl = setModelUrl;
    /**
     * Load in the extra molecule meshes.
     * @param  {Object<string,*>} sceneInfoData The data from scene_info.json.
     * @returns void
     */
    function setup(sceneInfoData) {
        // Load the 3DMoljs iframe.
        try {
            jQuery.getScript(
            // "https://3Dmol.csb.pitt.edu/build/3Dmol-min.js",
            "https://3Dmol.csb.pitt.edu/build/3Dmol.js", function (data, textStatus, jqxhr) {
                after3DMolJsLoaded(sceneInfoData);
            });
        }
        catch (err) {
            after3DMolJsLoaded(sceneInfoData);
        }
    }
    exports.setup = setup;
    /**
     * Runs after the 3Dmol.js library is loaded.
     * @param  {Object<string,*>} sceneInfoData The data from scene_info.json.
     * @returns void
     */
    function after3DMolJsLoaded(sceneInfoData) {
        VRML.setup(function () {
            UrlVars.readUrlParams();
            // let pdbUri = "https://files.rcsb.org/view/1XDN.pdb";
            VRML.loadPDBURL(exports.modelUrl, function (mdl3DMol) {
                // Update URL with location
                UrlVars.setURL();
                // Get additional selection information about the loaded molecule.
                // Like residue name.
                getAdditionalSels(mdl3DMol);
                // Now that the pdb is loaded, you need to repopulate the menu. In
                // the future, you might setup the menu for the first time from
                // here instead, but I can still imagine using ProteinVR without
                // 3Dmoljs, so let's just recreate for now.
                Menu3D.setup(); // Will use scene_info.json from what was previously saved.
                // Now that the PDB is loaded, you can start loading styles.
                UrlVars.startLoadingStyles();
                // Show protein ribbon by default.
                // Visualize.toggleRep(["Protein", "All"], "Cartoon", "Spectrum");
                // Continue...
                CommonLoader.afterLoading(sceneInfoData);
                // If it's nanokid, open a popup to let them specify a url or
                // pdbid.
                if (exports.modelUrl === "nanokid.sdf") {
                    setTimeout(function () {
                        // Give them some time to admire nanokid... :)
                        OpenPopup.openUrlModal("Load Molecule", "help/load.html");
                    }, 3000);
                }
            });
        });
    }
    /**
     * Generates additional possible selections from the properties of the atoms
     * themselves (like residue names).
     * @param  {*} mdl3DMol  A 3dmoljs molecule object.
     * @returns void
     */
    function getAdditionalSels(mdl3DMol) {
        // Get all the atoms.
        var atoms = mdl3DMol.selectedAtoms({});
        exports.atomicInfo = {
            "Atom Name": [],
            "Chain": [],
            "Element": [],
            "Residue Index": [],
            "Residue Name": [],
            "Secondary Structure": [],
        };
        var atomsLen = atoms.length;
        for (var i = 0; i < atomsLen; i++) {
            var atom = atoms[i];
            exports.atomicInfo["Atom Name"].push(atom["atom"]);
            exports.atomicInfo["Chain"].push(atom["chain"]);
            exports.atomicInfo["Element"].push(atom["elem"]);
            exports.atomicInfo["Residue Name"].push(atom["resn"]);
            exports.atomicInfo["Residue Index"].push(atom["resi"]);
            exports.atomicInfo["Secondary Structure"].push(atom["ss"]);
        }
        // We want just unique values.
        for (var lbl in exports.atomicInfo) {
            if (exports.atomicInfo.hasOwnProperty(lbl)) {
                exports.atomicInfo[lbl] = uniq(exports.atomicInfo[lbl]);
            }
        }
    }
    function uniq(arr) {
        // see
        // https://stackoverflow.com/questions/11688692/how-to-create-a-list-of-unique-items-in-javascript
        var u = {};
        var a = [];
        for (var i = 0, l = arr.length; i < l; ++i) {
            if (!u.hasOwnProperty(arr[i])) {
                a.push(arr[i]);
                u[arr[i]] = 1;
            }
        }
        return a;
    }
});

define('UrlVars',["require", "exports", "./Mols/3DMol/ThreeDMol", "./Mols/3DMol/Visualize", "./Mols/3DMol/VRML"], function (require, exports, ThreeDMol, Visualize, VRML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var stylesQueue = [];
    /**
     * Get all the url parameters from a url string.
     * @param  {string} url  The url srtring.
     * @returns Object<string,*> The parameters.
     */
    function getAllUrlParams(url) {
        // Adapted from
        // https://www.sitepoint.com/get-url-parameters-with-javascript/
        // get query string from url (optional) or window
        var queryString = url ? url.split("?")[1] : window.location.search.slice(1);
        // we'll store the parameters here
        var obj = {};
        // if query string exists
        if (queryString) {
            // stuff after # is not part of query string, so get rid of it
            queryString = queryString.split("#")[0];
            // split our query string into its component parts
            var arr = queryString.split("&");
            for (var _i = 0, arr_1 = arr; _i < arr_1.length; _i++) {
                var a = arr_1[_i];
                // separate the keys and the values
                var keyValPair = a.split("=");
                // set parameter name and value (use 'true' if empty)
                var paramName = keyValPair[0];
                var paramValue = (keyValPair[1] === undefined) ? true : keyValPair[1];
                obj[paramName] = paramValue;
            }
        }
        return obj;
    }
    /**
     * Round a number and represent it as a string.
     * @param  {number} x  The number.
     * @returns string The rounded string.
     */
    function round(x) {
        return (Math.round(100000 * x) / 100000).toString();
    }
    /**
     * Set the browser url to reflect the latest styles and rotations.
     * @returns void
     */
    function setURL() {
        var params = [];
        // Get the rotations.
        var x = VRML.molRotation.x;
        if (x !== 0) {
            params.push("x=" + round(x));
        }
        var y = VRML.molRotation.y;
        if (y !== 0) {
            params.push("y=" + round(y));
        }
        var z = VRML.molRotation.z;
        if (z !== 0) {
            params.push("z=" + round(z));
        }
        // Set the url.
        params.push("src=" + ThreeDMol.modelUrl);
        // Also get all the representations
        var i = 0;
        var styles = [];
        for (var key in Visualize.styleMeshes) {
            if (Visualize.styleMeshes.hasOwnProperty(key)) {
                if (Visualize.styleMeshes[key].mesh.isVisible) {
                    styles.push("style" + i.toString() + "=" + key);
                    i++;
                }
            }
        }
        // styles.reverse();  // order doens't matter anyway.
        params = params.concat(styles);
        // Update URL
        window.history.pushState({
        // "html": response.html,
        // "pageTitle": response.pageTitle,
        }, document.title, window.location.href.split("?")[0] + "?" + params.join("&"));
    }
    exports.setURL = setURL;
    /**
     * Gets info from the url parameters and saves/applies it, as appropriate.
     * Note that this gets what molecular styles need to be applied, but does not
     * apply them.
     * @returns void
     */
    function readUrlParams() {
        var params = getAllUrlParams(window.location.href);
        // Update the mesh rotations
        params["x"] = (params["x"] === undefined) ? 0 : +params["x"];
        params["y"] = (params["y"] === undefined) ? 0 : +params["y"];
        params["z"] = (params["z"] === undefined) ? 0 : +params["z"];
        VRML.setMolRotation(params["x"], params["y"], params["z"]);
        // Set the url if it's present.
        var src = params["src"];
        if (src !== undefined) {
            if ((src.length === 4) && (src.indexOf(".") === -1)) {
                // Assume it's a pdb id
                src = "https://files.rcsb.org/view/" + src.toUpperCase() + ".pdb";
            }
            ThreeDMol.setModelUrl(src);
        }
        // Setup the styles as well.
        for (var key in params) {
            if (params.hasOwnProperty(key)) {
                if (key.slice(0, 5) === "style") {
                    var repInfo = extractRepInfoFromKey(params[key]);
                    stylesQueue.push(repInfo);
                }
            }
        }
        // If stylesQueue has nothing in it, set up a default rep.
        if (stylesQueue.length === 0) {
            stylesQueue.push([["Protein", "All"], "Cartoon", "Spectrum"]);
            stylesQueue.push([["Ligand", "All"], "Stick", "Element"]);
        }
        // stylesQueue.reverse();  // order doens't matter anyway.
    }
    exports.readUrlParams = readUrlParams;
    /**
     * Takes a string like All--Ligand--Stick--Element and converts it to [["All",
     * "Ligand"], "Stick", "Element"].
     * @param  {string} key The srting.
     * @returns Array<*>
     */
    function extractRepInfoFromKey(key) {
        var prts = key.split("--");
        var rep = decodeURIComponent(prts[prts.length - 2]);
        var colorScheme = decodeURIComponent(prts[prts.length - 1]);
        var sels = prts.slice(0, prts.length - 2).map(function (i) {
            i = decodeURIComponent(i);
            if (i.slice(0, 1) === "{") {
                i = JSON.parse(i);
            }
            return i;
        });
        return [sels, rep, colorScheme];
    }
    exports.extractRepInfoFromKey = extractRepInfoFromKey;
    /**
     * Start loading all the molecular styles described in the url. A recursive
     * function.
     * @returns void
     */
    function startLoadingStyles() {
        if (stylesQueue.length > 0) {
            // There are some styles to still run.
            var style = stylesQueue.pop();
            Visualize.toggleRep(style[0], style[1], style[2], function () {
                // Try to get the next style.
                startLoadingStyles();
            });
        }
    }
    exports.startLoadingStyles = startLoadingStyles;
});

// Functions to create a protein visualization using 3DMol.js
define('Mols/3DMol/Visualize',["require", "exports", "../../Scene/Optimizations", "../../UI/Menu3D/Menu3D", "../../UrlVars", "../../Vars", "./PositionInScene", "./VRML"], function (require, exports, Optimizations, Menu3D, UrlVars, Vars, PositionInScene, VRML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // A place to keep track of all the styles. List of [key, vals]
    // let styles: any[] = [];
    var currentSurface = undefined;
    exports.styleMeshes = {};
    var selKeyWordTo3DMolSel = {
        // See VMD output TCL files for good ideas.
        "All": {},
        "Protein": { "resn": lAndU(["ALA", "ARG", "ASP", "ASN", "ASX", "CYS",
                "GLN", "GLU", "GLX", "GLY", "HIS", "HSP",
                "HYP", "ILE", "LEU", "LYS", "MET", "PCA",
                "PHE", "PRO", "TRP", "TYR", "VAL", "GLU",
                "SER", "THR", "MSE"]) },
        "Acidic": { "resn": lAndU(["ASP", "GLU"]) },
        "Cyclic": { "resn": lAndU(["HIS", "PHE", "PRO", "TRP", "TYR"]) },
        "Aliphatic": { "resn": lAndU(["ALA", "GLY", "ILE", "LEU", "VAL"]) },
        "Aromatic": { "resn": lAndU(["HIS", "PHE", "TRP", "TYR"]) },
        "Basic": { "resn": lAndU(["ARG", "HIS", "LYS", "HSP"]) },
        "Charged": { "resn": lAndU(["ASP", "GLU", "ARG", "HIS", "LYS", "HSP"]) },
        "Hydrophobic": { "resn": lAndU(["ALA", "LEU", "VAL", "ILE", "PRO", "PHE",
                "MET", "TRP"]) },
        "Neutral": { "resn": lAndU(["VAL", "PHE", "GLN", "TYR", "HIS", "CYS",
                "MET", "TRP", "ASX", "GLX", "PCA", "HYP"]) },
        "Nucleic": { "resn": lAndU(["ADE", "A", "GUA", "G", "CYT", "C", "THY",
                "T", "URA", "U"]) },
        "Purine": { "resn": lAndU(["ADE", "A", "GUA", "G"]) },
        "Pyrimidine": { "resn": lAndU(["CYT", "C", "THY", "T", "URA", "U"]) },
        "Ions": { "resn": lAndU(["AL", "BA", "CA", "CAL", "CD", "CES", "CLA",
                "CL", "CO", "CS", "CU", "CU1", "CUA", "HG",
                "IN", "IOD", "K", "MG", "MN3", "MO3", "MO4",
                "MO5", "MO6", "NA", "NAW", "OC7", "PB",
                "POT", "PT", "RB", "SOD", "TB", "TL", "WO4",
                "YB", "ZN", "ZN1", "ZN2"]) },
        "Water": { "resn": lAndU(["WAT", "HOH", "TIP", "TIP3"]) },
    };
    // Add in ligand
    selKeyWordTo3DMolSel["Ligand"] = { "not": { "or": [
                selKeyWordTo3DMolSel["Protein"],
                selKeyWordTo3DMolSel["Nucleic"],
                selKeyWordTo3DMolSel["Ions"],
                selKeyWordTo3DMolSel["Water"],
            ] } };
    var colorSchemeKeyWordTo3DMol = {
        "Amino Acid": { "colorscheme": "amino" },
        "Blue": { "color": "blue" },
        "Chain": { "colorscheme": "chain" },
        "Element": { "colorscheme": "default" },
        "Green": { "color": "green" },
        "Nucleic": { "colorscheme": "nucleic" },
        "Orange": { "color": "orange" },
        "Purple": { "color": "purple" },
        "Red": { "color": "red" },
        "Spectrum": { "color": "spectrum" },
        "White": { "color": "white" },
        "Yellow": { "color": "yellow" },
    };
    // Ligand?
    // All residus? Chains? Elements? Others here... https://3dmol.csb.pitt.edu/doc/types.html#AtomSpec
    /**
     * The toggleRep function. Starts the mesh-creation proecss.
     * @param  {Array<*>}            filters        Can include strings (lookup
     *                                              sel in selKeyWordTo3DMolSel).
     *                                              Or a 3DMoljs selection object.
     * @param  {string}              repName        The representative name. Like
     *                                              "Surface".
     * @param  {string}              colorScheme    The name of the color scheme.
     * @param  {Function|undefined}  finalCallback  Callback to run once the mesh
     *                                              is entirely done.
     * @returns void
     */
    function toggleRep(filters, repName, colorScheme, finalCallback) {
        if (finalCallback === void 0) { finalCallback = undefined; }
        // Get the key of this rep request.
        var keys = getKeys(filters, repName, colorScheme);
        if (finalCallback === undefined) {
            finalCallback = function () { return; };
        }
        // If it's "Hide", then just hide the mesh
        if (colorScheme === "Hide") {
            for (var fullKey in exports.styleMeshes) {
                if (exports.styleMeshes.hasOwnProperty(fullKey)) {
                    var styleMesh = exports.styleMeshes[fullKey];
                    if (styleMesh.categoryKey === keys.categoryKey) {
                        styleMesh.mesh.isVisible = false;
                        console.log("Hiding existing mesh...");
                    }
                }
            }
            // Still need to position the meshes (hiding some reps could make others bigger).
            PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"));
            // Update the URL
            UrlVars.setURL();
            // Recalculate the menu
            Menu3D.setup();
            return;
        }
        // Maybe the mesh has been generated previously. If so, just show that.
        if (exports.styleMeshes[keys.fullKey] !== undefined) {
            exports.styleMeshes[keys.fullKey].mesh.isVisible = true;
            console.log("showing existing mesh...");
            // Still need to position the meshes (hiding some reps could make others bigger).
            PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"));
            // Update the URL
            UrlVars.setURL();
            // Recalculate the menu
            Menu3D.setup();
            return;
        }
        // You'll need to use 3DMoljs to generate the mesh, since it's never been
        // generated before. First remove all representations from existing
        // 3Dmoljs.
        // let viewer = VRML.viewer;
        // VRML.removeAllSurfaces();
        // VRML.setStyle({}, undefined);
        // console.log("Abovee causes an error...");
        VRML.resetAll();
        // VRML.viewer.render();
        // Make the new representation.
        var colorSccheme = colorSchemeKeyWordTo3DMol[colorScheme];
        var sels = { "and": filters.map(function (i) {
                // "i" can be a keyword or a selection json itself.
                return (selKeyWordTo3DMolSel[i] !== undefined) ? selKeyWordTo3DMolSel[i] : i;
            }) };
        if (repName.toLowerCase() === "surface") {
            VRML.addSurface(colorSccheme, sels, function () {
                toggleRepContinued(keys, repName, finalCallback);
            });
        }
        else {
            var rep = {};
            rep[repName.toLowerCase()] = colorSccheme;
            VRML.setStyle(sels, rep);
            toggleRepContinued(keys, repName, finalCallback);
        }
    }
    exports.toggleRep = toggleRep;
    /**
     * Continues the toggleRep function.
     * @param  {Object<string,*>}    keys
     * @param  {string}              repName        The representative name. Like
     *                                              "Surface".
     * @param  {Function|undefined}  finalCallback  Callback to run once the mesh
     *                                              is entirely done.
     * @returns void
     */
    function toggleRepContinued(keys, repName, finalCallback) {
        VRML.render(true, repName, function (newMesh) {
            // Remove any other meshes that have the same category key (so could
            // be different color... that would be removed.)
            for (var i in exports.styleMeshes) {
                if (exports.styleMeshes.hasOwnProperty(i)) {
                    var styleMesh = exports.styleMeshes[i];
                    if (styleMesh.categoryKey === keys.categoryKey) {
                        Optimizations.removeMeshEntirely(styleMesh.mesh);
                        delete exports.styleMeshes[i];
                        console.log("deleting old mesh...");
                    }
                }
            }
            // If the new mesh is a surface, make it so each triangle is two sided
            // and delete the surface from 3Dmoljs instance (cleanup).
            if (repName === "Surface") {
                newMesh.material.backFaceCulling = false;
                // if (currentSurface !== undefined) {
                // debugger;
                // VRML.viewer.removeSurface(currentSurface["surfid"]);
                // currentSurface = undefined;
                // }
            }
            // Add this new one.
            exports.styleMeshes[keys.fullKey] = {
                categoryKey: keys.categoryKey,
                mesh: newMesh,
            };
            // Update the URL
            UrlVars.setURL();
            // Recalculate the menu
            Menu3D.setup();
            finalCallback();
            console.log("added new mesh");
        });
    }
    /**
     * Get keys to uniquelty describe a given representations.
     * @param  {Array<string|Object>} filters      Selections. Can be keywords or
     *                                             3dmoljs selection objects.
     * @param  {string}               repName      The name of the representation,
     *                                             e.g., "Cartoon".
     * @param  {string}               colorScheme  The color style keyword.
     */
    function getKeys(filters, repName, colorScheme) {
        filters.sort();
        var filtersStr = filters.map(function (f) {
            if (typeof f === "string") {
                return f;
            }
            else {
                return JSON.stringify(f);
            }
        }); // In case some JSON selections.
        return {
            categoryKey: filtersStr.join("--") + "--" + repName,
            fullKey: filtersStr.join("--") + "--" + repName + "--" + colorScheme,
        };
    }
    /**
     * Also adds upper and lower versions of elements in a list.
     * @param  {Array<string>} lst  The original list.
     * @returns string  The list with uppercase and lowercase items also added.
     */
    function lAndU(lst) {
        var newLst = lst.map(function (s) { return s; });
        for (var _i = 0, lst_1 = lst; _i < lst_1.length; _i++) {
            var s = lst_1[_i];
            newLst.push(s.toUpperCase());
            newLst.push(s.toLowerCase());
        }
        // See https://gomakethings.com/removing-duplicates-from-an-array-with-vanilla-javascript/
        newLst = newLst.filter(function (item, index) {
            return newLst.indexOf(item) >= index;
        });
        return newLst;
    }
});
// export function
;
define('Mols/3DMol/PositionInScene',["require", "exports", "../../Scene/Optimizations", "../../Vars", "./Visualize", "./VRML"], function (require, exports, Optimizations, Vars, Visualize, VRML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var lastRot = undefined;
    /**
     * Positions a given molecular mesh within a specified box.
     * @param  {*} babylonMesh       The molecular mesh.
     * @param  {*} otherBabylonMesh  The box.
     * @returns void
     */
    function positionAll3DMolMeshInsideAnother(babylonMesh, otherBabylonMesh) {
        var allVisMolMeshes = getVisibleMolMeshes(babylonMesh);
        // Save all information about each of the visible meshes, for later
        // animation.
        if (lastRot === undefined) {
            lastRot = VRML.molRotation.clone();
        }
        var allVisMolMeshesInfo = allVisMolMeshes.map(function (m) {
            return {
                mesh: m,
                position: m.position.clone(),
                rotation: lastRot.clone(),
                scaling: m.scaling.clone(),
            };
        });
        lastRot = VRML.molRotation.clone();
        if (allVisMolMeshes.length === 0) {
            // No meshes to show.
            return;
        }
        resetMeshes(allVisMolMeshes);
        // Render to update the meshes
        Vars.scene.render(); // Needed to get bounding box to recalculate.
        // Get the bounding box of the other mesh and it's dimensions
        // (protein_box).
        var targetBox = otherBabylonMesh.getBoundingInfo().boundingBox;
        var targetBoxDimens = Object.keys(targetBox.maximumWorld).map(function (k) { return targetBox.maximumWorld[k] - targetBox.minimumWorld[k]; });
        // Get the molecular model with the biggest volume.
        var maxVol = 0.0;
        var thisBox;
        var thisBoxDimens;
        var _loop_1 = function (allVisMolMesh) {
            // Get the bounding box of this mesh.
            var thisBoxTmp = allVisMolMesh.getBoundingInfo().boundingBox;
            var thisBoxDimensTmp = Object.keys(thisBoxTmp.maximumWorld).map(function (k) { return thisBoxTmp.maximumWorld[k] - thisBoxTmp.minimumWorld[k]; });
            var volume = thisBoxDimensTmp[0] * thisBoxDimensTmp[1] * thisBoxDimensTmp[2];
            if (volume > maxVol) {
                maxVol = volume;
                thisBox = thisBoxTmp;
                thisBoxDimens = thisBoxDimensTmp;
            }
        };
        for (var _i = 0, allVisMolMeshes_1 = allVisMolMeshes; _i < allVisMolMeshes_1.length; _i++) {
            var allVisMolMesh = allVisMolMeshes_1[_i];
            _loop_1(allVisMolMesh);
        }
        // Get the scales
        var scales = targetBoxDimens.map(function (targetBoxDimen, i) {
            return targetBoxDimen / thisBoxDimens[i];
        });
        // Get the minimum scale
        var minScale = Math.min.apply(null, scales);
        var meshScaling = new BABYLON.Vector3(minScale, minScale, minScale);
        // Scale the meshes.
        for (var _a = 0, allVisMolMeshes_2 = allVisMolMeshes; _a < allVisMolMeshes_2.length; _a++) {
            var allVisMolMesh = allVisMolMeshes_2[_a];
            allVisMolMesh.scaling = meshScaling;
        }
        Vars.scene.render(); // Needed to get bounding box to recalculate.
        // Translate the meshes.
        var meshTranslation = thisBox.centerWorld.subtract(targetBox.centerWorld);
        for (var _b = 0, allVisMolMeshes_3 = allVisMolMeshes; _b < allVisMolMeshes_3.length; _b++) {
            var allVisMolMesh = allVisMolMeshes_3[_b];
            allVisMolMesh.position = allVisMolMesh.position.subtract(meshTranslation);
        }
        // The above will position the molecular mesh within the target mesh,
        // centering the two bounding boxes. That would be good for positioning
        // proteins in a bilayer, for example. Now let's move the meshes so they
        // are actually on the ground (all other meshes).
        // Vars.scene.render();  // Needed to get bounding box to recalculate.
        var deltaY = 0.5 * ((targetBox.maximumWorld.y - targetBox.minimumWorld.y) -
            (thisBox.maximumWorld.y - thisBox.minimumWorld.y));
        for (var _c = 0, allVisMolMeshes_4 = allVisMolMeshes; _c < allVisMolMeshes_4.length; _c++) {
            var allVisMolMesh = allVisMolMeshes_4[_c];
            allVisMolMesh.position.y = allVisMolMesh.position.y - deltaY;
            allVisMolMesh.visibility = 1; // Hide while rotating.
        }
        // Now do the animations.
        for (var _d = 0, allVisMolMeshesInfo_1 = allVisMolMeshesInfo; _d < allVisMolMeshesInfo_1.length; _d++) {
            var allVisMolMeshInfo = allVisMolMeshesInfo_1[_d];
            var mesh = allVisMolMeshInfo.mesh;
            var pos = mesh.position.clone();
            var sca = mesh.scaling.clone();
            var rot = mesh.rotation.clone();
            var posX = makeBabylonAnim("posX", "position.x", allVisMolMeshInfo.position.x, pos.x);
            var posY = makeBabylonAnim("posY", "position.y", allVisMolMeshInfo.position.y, pos.y);
            var posZ = makeBabylonAnim("posZ", "position.z", allVisMolMeshInfo.position.z, pos.z);
            var scaX = makeBabylonAnim("scaX", "scaling.x", allVisMolMeshInfo.scaling.x, sca.x);
            var scaY = makeBabylonAnim("scaY", "scaling.y", allVisMolMeshInfo.scaling.y, sca.y);
            var scaZ = makeBabylonAnim("scaZ", "scaling.z", allVisMolMeshInfo.scaling.z, sca.z);
            var rotX = makeBabylonAnim("rotX", "rotation.x", allVisMolMeshInfo.rotation.x, rot.x);
            var rotY = makeBabylonAnim("rotY", "rotation.y", allVisMolMeshInfo.rotation.y, rot.y);
            var rotZ = makeBabylonAnim("rotZ", "rotation.z", allVisMolMeshInfo.rotation.z, rot.z);
            mesh.animations = [posX, posY, posZ, scaX, scaY, scaZ, rotX, rotY, rotZ];
            var anim = Vars.scene.beginAnimation(mesh, 0, 15, false, 1, function () {
                // You need to recalculate the shadows.
                Optimizations.updateEnvironmentShadows();
            });
        }
    }
    exports.positionAll3DMolMeshInsideAnother = positionAll3DMolMeshInsideAnother;
    /**
     * Gets a list of all the babylonjs molecular meshes that are visible.
     * @param  {*} babylonMesh  The mesh that was just added.
     * @returns Array<*>  A list of all visible meshes.
     */
    function getVisibleMolMeshes(babylonMesh) {
        var allVisMolMeshes = [];
        for (var molMeshId in Visualize.styleMeshes) {
            if (Visualize.styleMeshes.hasOwnProperty(molMeshId)) {
                var allVisMolMesh = Visualize.styleMeshes[molMeshId].mesh;
                if (allVisMolMesh.isVisible === true) {
                    allVisMolMeshes.push(allVisMolMesh);
                }
            }
        }
        // Add the current one (just added).
        if (babylonMesh !== undefined) {
            allVisMolMeshes.push(babylonMesh);
        }
        return allVisMolMeshes;
    }
    /**
     * Resets things like the location and rotation of all visible meshes.
     * @param  {Object<*>} allVisMolMeshes  All the visible meshes.
     * @returns void
     */
    function resetMeshes(allVisMolMeshes) {
        // Reset the scaling, position, and rotation of all the visible molecular
        // meshes.
        for (var _i = 0, allVisMolMeshes_5 = allVisMolMeshes; _i < allVisMolMeshes_5.length; _i++) {
            var allVisMolMesh = allVisMolMeshes_5[_i];
            allVisMolMesh.animations = [];
            if (allVisMolMesh.isVisible === true) {
                // Make sure allVisMolMesh is not scaled or positioned. But
                // note that rotations are preserved.
                allVisMolMesh.scaling = new BABYLON.Vector3(1, 1, 1);
                allVisMolMesh.position = new BABYLON.Vector3(0, 0, 0);
                allVisMolMesh.rotation = VRML.molRotation;
                allVisMolMesh.visibility = 0; // Hide while rotating.
            }
        }
    }
    /**
     * Make a babylonjs animation. I found myself doing this a lot, so figured I'd
     * make a function.
     * @param  {string} name      The animation name.
     * @param  {string} prop      The property to animate.
     * @param  {number} startVal  The starting value.
     * @param  {number} endVal    The ending value.
     */
    function makeBabylonAnim(name, prop, startVal, endVal) {
        var anim = new BABYLON.Animation(name, prop, 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        anim.setKeys([
            { frame: 0, value: startVal },
            { frame: 15, value: endVal },
        ]);
        return anim;
    }
    ;
});

define('UI/Menu3D/Rotations',["require", "exports", "../../Mols/3DMol/PositionInScene", "../../Mols/3DMol/VRML", "../../Vars"], function (require, exports, PositionInScene, VRML, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Builds a submenu object describing how the models and be rotated.
     * @returns Object The submenu objct.
     */
    function buildRotationsSubMenu() {
        var amt = 15.0 * Math.PI / 180.0;
        return {
            "X Axis": function () {
                VRML.updateMolRotation("x", amt);
                PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"));
            },
            "Y Axis": function () {
                VRML.updateMolRotation("y", amt);
                PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"));
            },
            "Z Axis": function () {
                VRML.updateMolRotation("z", amt);
                PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"));
            },
        };
    }
    exports.buildRotationsSubMenu = buildRotationsSubMenu;
});

define('UI/Menu3D/Styles',["require", "exports", "../../Mols/3DMol/ThreeDMol", "../../Mols/3DMol/Visualize", "../../UrlVars", "./Menu3D"], function (require, exports, ThreeDMol, Visualize, UrlVars, Menu3D) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var components = ["Protein", "Ligand", "Water", "Nucleic"];
    var selections = {
        "Ligand": ["All"],
        "Nucleic": ["All"],
        "Protein": [
            "All", "Hydrophobic", "Hydrophilic", "Charged", "Aromatic",
        ],
        "Water": ["All"],
    };
    var commonReps = ["Stick", "Sphere", "Surface"];
    var representations = {
        "Ligand": commonReps,
        "Nucleic": commonReps,
        "Protein": ["Cartoon"].concat(commonReps),
        "Water": commonReps,
    };
    // You'll need to modify colorSchemeKeyWordTo3DMol in Visualize.ts too.
    var colors = [
        "White", "Red", "Blue", "Green", "Orange", "Yellow", "Purple",
    ];
    var colorSchemes = [
        "Element", "Amino Acid", "Chain", "Nucleic", "Spectrum",
    ];
    /**
     * Makes submenus required for the various style options (reps, colors, etc.).
     * @returns Object
     */
    function buildStylesSubMenu() {
        var menu = {
            "Components": {},
            "Selections": {},
            "Clear": function () {
                for (var fullKey in Visualize.styleMeshes) {
                    if (Visualize.styleMeshes.hasOwnProperty(fullKey)) {
                        var styleMesh = Visualize.styleMeshes[fullKey];
                        styleMesh.mesh.isVisible = false;
                    }
                }
                Menu3D.openMainMenuFloorButton.toggled();
            },
            "Remove Existing": {},
        };
        var _loop_1 = function (component) {
            menu["Components"][component] = {};
            var _loop_3 = function (selection) {
                menu["Components"][component][selection] = makeRepColorSchemeSubMenus({}, component, function (rep, colorScheme) {
                    Visualize.toggleRep([component, selection], rep, colorScheme);
                });
            };
            for (var _i = 0, _a = selections[component]; _i < _a.length; _i++) {
                var selection = _a[_i];
                _loop_3(selection);
            }
        };
        // Add in the standard selections (ligand, protein, etc).
        for (var _i = 0, components_1 = components; _i < components_1.length; _i++) {
            var component = components_1[_i];
            _loop_1(component);
        }
        // Selection keywords
        var selKeywords = {
            "Atom Name": "atom",
            "Chain": "chain",
            "Element": "elem",
            "Residue Index": "resi",
            "Residue Name": "resn",
            "Secondary Structure": "ss",
        };
        var maxNumPerGroup = 14;
        var addToMenuRecurse = function (component, menuBranch, items) {
            items.sort(function (x, y) {
                // If either is a string number, convert to number.
                x = isNaN(+x) ? x : +x;
                y = isNaN(+y) ? y : +y;
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                return 0;
            });
            // So divide it into maxNumPerGroup groups.
            var chunks = chunkify(items, maxNumPerGroup);
            var _loop_4 = function (chunk) {
                if (chunk.length === 1) {
                    // Just a single item, so make the rep/color submenus.
                    var item_1 = chunk[0];
                    menuBranch[item_1] = {};
                    menuBranch[item_1] = makeRepColorSchemeSubMenus(menuBranch[item_1], component, function (rep, colorScheme) {
                        var selKeyword = selKeywords[component]; // See ThreeDMol.ts
                        var it = {};
                        it[selKeyword] = item_1;
                        Visualize.toggleRep([it], rep, colorScheme);
                    });
                }
                else {
                    // Multiple items, so it's a category.
                    var lbl = "[" + chunk[0].toString() + "-" + chunk[chunk.length - 1].toString() + "]";
                    menuBranch[lbl] = {};
                    addToMenuRecurse(component, menuBranch[lbl], chunk);
                }
            };
            for (var _i = 0, chunks_1 = chunks; _i < chunks_1.length; _i++) {
                var chunk = chunks_1[_i];
                _loop_4(chunk);
            }
        };
        // Add in selections specific to this protein.
        for (var component in ThreeDMol.atomicInfo) {
            if (ThreeDMol.atomicInfo.hasOwnProperty(component)) {
                // component is like "Element"
                var sels = ThreeDMol.atomicInfo[component];
                menu["Selections"][component] = {};
                addToMenuRecurse(component, menu["Selections"][component], sels);
            }
        }
        var _loop_2 = function (repName) {
            if (Visualize.styleMeshes.hasOwnProperty(repName)) {
                if (Visualize.styleMeshes[repName].mesh.isVisible === true) {
                    var lbl = repName.replace(/--/g, " ");
                    lbl = lbl.replace(/{/g, "").replace(/}/g, "").replace(/"/g, "");
                    menu["Remove Existing"][lbl] = function () {
                        Menu3D.openMainMenuFloorButton.toggled();
                        setTimeout(function () {
                            var repInfo = UrlVars.extractRepInfoFromKey(repName);
                            Visualize.toggleRep(repInfo[0], repInfo[1], "Hide");
                        }, 0);
                    };
                }
            }
        };
        // Also add in existing styles so they can be removed.
        for (var repName in Visualize.styleMeshes) {
            _loop_2(repName);
        }
        return menu;
    }
    exports.buildStylesSubMenu = buildStylesSubMenu;
    /**
     * Takes an array and divides it into subarrays that are roughly equally
     * spaced.
     * @param  {Array<*>} arr        The array.
     * @param  {number}   numChunks  The number of subarrays.
     * @returns Array<Array<*>>  An array of arrays.
     */
    function chunkify(arr, numChunks) {
        // see
        // https://stackoverflow.com/questions/8188548/splitting-a-js-array-into-n-arrays
        if (numChunks < 2) {
            return [arr];
        }
        var len = arr.length;
        var out = [];
        var i = 0;
        var size;
        if (len % numChunks === 0) {
            size = Math.floor(len / numChunks);
            while (i < len) {
                out.push(arr.slice(i, i += size));
            }
        }
        else {
            while (i < len) {
                size = Math.ceil((len - i) / numChunks--);
                out.push(arr.slice(i, i += size));
            }
        }
        return out;
    }
    /**
     * Adds representative and color submenus.
     * @param  {Object}    menuBranch  The branch to which to add these submenus.
     * @param  {string}    component   Like "Protein".
     * @param  {Function}  clickFunc   The function to run when the buttons of
     *                                 this submenu are clicked.
     * @returns Object                 The submenu object, now updated.
     */
    function makeRepColorSchemeSubMenus(menuBranch, component, clickFunc) {
        // What representations can you use? Default to Protein because it
        // contains them all.
        var repsToUse = (representations[component] === undefined) ?
            representations["Protein"] :
            representations[component];
        var _loop_5 = function (rep) {
            menuBranch[rep] = {
                "Colors": {},
                "Color Schemes": {},
            };
            var _loop_6 = function (colorScheme) {
                menuBranch[rep]["Color Schemes"][colorScheme] = function () {
                    clickFunc(rep, colorScheme);
                    Menu3D.openMainMenuFloorButton.toggled();
                };
            };
            for (var _i = 0, colorSchemes_1 = colorSchemes; _i < colorSchemes_1.length; _i++) {
                var colorScheme = colorSchemes_1[_i];
                _loop_6(colorScheme);
            }
            var _loop_7 = function (color) {
                menuBranch[rep]["Colors"][color] = function () {
                    clickFunc(rep, color);
                    Menu3D.openMainMenuFloorButton.toggled();
                };
            };
            for (var _a = 0, colors_1 = colors; _a < colors_1.length; _a++) {
                var color = colors_1[_a];
                _loop_7(color);
            }
            menuBranch[rep]["Hide"] = function () {
                clickFunc(rep, "Hide");
                Menu3D.openMainMenuFloorButton.toggled();
            };
        };
        for (var _i = 0, repsToUse_1 = repsToUse; _i < repsToUse_1.length; _i++) {
            var rep = repsToUse_1[_i];
            _loop_5(rep);
        }
        return menuBranch;
    }
});

define('UI/Menu3D/Menu3D',["require", "exports", "../../Cameras/CommonCamera", "../../Navigation/Points", "../../Vars", "./Button", "./Rotations", "./Styles"], function (require, exports, CommonCamera, VRPoints, Vars, Button, Rotations, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // An easy way to define a menu. It's a nested object. See setup();
    var menuInf;
    // The program will convert that nested array to a flat list.
    var menuInfFlat;
    exports.clickSound = undefined;
    // These variables need to be initialized in setup(), to enable reloading if
    // necessary.
    var allButtons;
    var GUI3DMenuManager;
    var commonMenuAnchor;
    var latestLevelViewed;
    var sceneInfoData;
    /**
     * Load the 3D GUI. Also reloads the GUI (destroys old version). Reloading is
     * useful when you add a new PDB, for example, and want to update the
     * selection options.
     * @param  {Object<string,*>=} data The data from scene_info.json. Saves on
     *                                  first use so it doesn't need to be
     *                                  subsequently specified.
     * @returns void
     */
    function setup(data) {
        // Initialize some variables
        allButtons = [];
        latestLevelViewed = 0;
        menuInf = {
            "Styles": Styles.buildStylesSubMenu(),
            "Rotate": Rotations.buildRotationsSubMenu(),
            "Last": function () {
                console.log("Going to", latestLevelViewed);
                showOnlyButtonsOfLevel(latestLevelViewed);
            },
        };
        // Save the scene data so you can reference it in the future, if you
        // recreate the menu. If it's not defined, the use the saved data.
        if (data !== undefined) {
            sceneInfoData = data;
        }
        else {
            data = sceneInfoData;
        }
        // Only required to setup once.
        if (GUI3DMenuManager === undefined) {
            // Make a manager for the menu
            GUI3DMenuManager = new BABYLON.GUI.GUI3DManager(Vars.scene);
            // window["GUI3DMenuManager"] = GUI3DMenuManager;
        }
        setupMainMenu();
        // Only required to setup once.
        if (exports.openMainMenuFloorButton === undefined) {
            setupMainMenuToggleButton();
        }
        // Only required to setup once.
        if (exports.clickSound === undefined) {
            exports.clickSound = new BABYLON.Sound("click-button", "assets/staple-public-domain.mp3", Vars.scene, null, { loop: false, autoplay: false, spatialSound: true, volume: 0.1 });
        }
    }
    exports.setup = setup;
    // window["setup"] = setup;
    /**
     * Setup the main menu.
     * @returns void
     */
    function setupMainMenu() {
        // Get the descriptions
        // VRVoiceCommands.setMoleculeNameInfos(data);
        // Flatten the menu data.
        menuInfFlat = groupMenuInfByLevel();
        // Here would also be a good place to add additional buttons such as voice
        // dictation. See setupSubMenuNavButtons for how this was done
        // previously.
        menuInfFlat = setupSubMenuNavButtons(menuInfFlat);
        commonMenuAnchor = new BABYLON.TransformNode(""); // this can be a mesh, too
        // createPanelIfNeeded(1);
        createPanelSixteenButtons();
        // for (let key in VRVoiceCommands.moleculeNameInfos) {
        //     if (VRVoiceCommands.moleculeNameInfos.hasOwnProperty(key)) {
        //         let inf = VRVoiceCommands.moleculeNameInfos[key];
        //         let desc = inf.description;
        //         allButtons.push(
        //             new ButtonWrapper({
        //                 clickFunc: (buttonWrapper) => {
        //                     VRVoiceCommands.showOrHideModel(
        //                         inf.modelName,
        //                         inf.representation,
        //                         !buttonWrapper.value,
        //                     );
        //                     // For reasons I don't understand, the radius on this
        //                     // cylinder (set below) doesn't take. Put it here to
        //                     // too make sure.
        //                     // cylinderPanelMainMenu.radius = Vars.MENU_RADIUS;
        //                     // cylinderPanelMainMenu.margin = Vars.MENU_MARGIN;
        //                 },
        //                 default: false,
        //                 falseTxt: desc + "\n(Hide)",
        //                 initFunc: (buttonWrapper) => {
        //                     buttonWrapper.isVisible(false);  // Buttons start off hidden.
        //                 },
        //                 name: "menu-visible-button-" + inf.modelName.replace(/ /g, "").replace(/\n/g, ""),
        //                 panel: cylinderPanelMainMenu,
        //                 trueTxt: desc + "\n(Show)",
        //             }),
        //         );
        //         // window.but = but;
        //     }
        // }
        // setupSubMenuNavButtons(cylinderPanelMainMenu, data);
        // window["cylinderPanelMainMenu"] = cylinderPanelMainMenu;
    }
    /**
     * Creates a panel containing 16 buttons. These buttons are manipulated to
     * show different submenus.
     * @returns void
     */
    function createPanelSixteenButtons() {
        // let panel = new BABYLON.GUI.CylinderPanel();
        var panel = new BABYLON.GUI.SpherePanel();
        panel.radius = Vars.MENU_RADIUS;
        panel.margin = Vars.MENU_MARGIN;
        GUI3DMenuManager.addControl(panel);
        panel.blockLayout = true;
        var _loop_1 = function (idx) {
            var func = function () { return; };
            var txt = idx.toString();
            var color = "yellow";
            var levelInt = 1;
            allButtons.push(new Button.ButtonWrapper({
                clickFunc: function (buttonWrapper) {
                    func();
                    // For reasons I don't understand, the radius on this
                    // cylinder (set below) doesn't take. Put it here to
                    // too make sure.
                    // cylinderPanelMainMenu.radius = Vars.MENU_RADIUS;
                    // cylinderPanelMainMenu.margin = Vars.MENU_MARGIN;
                },
                default: false,
                falseTxt: txt,
                initFunc: function (buttonWrapper) {
                    buttonWrapper.isVisible(false); // Buttons start off hidden.
                },
                level: levelInt,
                name: "menu-visible-button-" + txt,
                panel: panel,
                trueTxt: txt,
                color: color,
            }));
        };
        // Add buttons
        for (var idx = 0; idx < 16; idx++) {
            _loop_1(idx);
        }
        // Set radius and such.
        panel.columns = 4;
        panel.linkToTransformNode(commonMenuAnchor);
        panel.blockLayout = false;
    }
    /**
     * Takes the data in menuInf and groups it into appropriate levels. Eventually
     * these levels will becomme diferent submenus.
     * @returns Object<number: Array<string, *>> The grouped data.
     */
    function groupMenuInfByLevel() {
        // You need to restructure the menuInf variable.
        var menuData = {}; // Where to put the data.
        var levelsUsed = [];
        /**
         * Get the next available level slot.
         * @param  {number} bestLevelGuess  The best guess at the next available
         *                                  slot.
         * @returns number  The actual slot.
         */
        var getNextAvailableLevel = function (bestLevelGuess) {
            // You may need to adjust the level to make sure it hasn't already
            // been used.
            while (levelsUsed.indexOf(bestLevelGuess) !== -1) {
                bestLevelGuess++;
            }
            return bestLevelGuess;
        };
        /**
         * @param  {Object}           inf      The menuInfo data.
         * @param  {number}           level    The currently menu level.
         * @param  {number|undefined} upLevel  The level of the submenu one above
         *                                     this one.
         * @returns void
         */
        var recurse = function (inf, level, upLevel) {
            levelsUsed.push(level);
            var keys = Object.keys(inf);
            var _loop_2 = function (idx) {
                if (keys.hasOwnProperty(idx)) {
                    var key = keys[idx];
                    var val = inf[key];
                    // Make sure list initialized.s
                    menuData[level] = (menuData[level] === undefined) ? [] : menuData[level];
                    switch (typeof (val)) {
                        case "function":
                            menuData[level].push({
                                func: val,
                                txt: key,
                                upLevel: upLevel,
                            });
                            break;
                        case "object":
                            var nextLevel_1 = getNextAvailableLevel(level + 1);
                            menuData[level].push({
                                color: "green",
                                func: function () { showOnlyButtonsOfLevel(nextLevel_1); },
                                txt: key + " ",
                                upLevel: upLevel,
                            });
                            recurse(val, nextLevel_1, level);
                            break;
                        default:
                            alert("error!");
                    }
                }
            };
            for (var idx in keys) {
                _loop_2(idx);
            }
        };
        recurse(menuInf, 1, undefined);
        return menuData;
    }
    /**
     * Set up submenu navigation buttons like back and close.
     * @param  {Object} menuData
     * @returns *
     */
    function setupSubMenuNavButtons(menuData) {
        var _loop_3 = function (level) {
            if (menuData.hasOwnProperty(level)) {
                // Sort the existing items by the text. To alphabetize before
                // adding "control" buttons below.
                menuData[level].sort(function (first, second) {
                    // See https://stackoverflow.com/questions/51165/how-to-sort-strings-in-javascript
                    return ("" + first.txt).localeCompare(second.txt);
                });
                var levelInt = +level;
                if (levelInt > 1) { // Because even main submenu can't go back (will be cancel).
                    menuData[level].push({
                        color: "yellow",
                        func: function () {
                            showOnlyButtonsOfLevel(menuData[level][0].upLevel);
                        },
                        txt: "Back ",
                        upLevel: menuData[level][0].upLevel,
                    });
                }
                if (levelInt > 0) {
                    menuData[level].push({
                        color: "red",
                        func: function () {
                            // showOnlyButtonsOfLevel(0);
                            exports.openMainMenuFloorButton.toggled();
                        },
                        txt: "Close Menu ",
                        upLevel: menuData[level][0].upLevel,
                    });
                }
            }
        };
        // Each of the submenus should have a back button and a close menu button.
        for (var level in menuData) {
            _loop_3(level);
        }
        // console.log(menuData);
        return menuData;
    }
    /**
     * Sets up some additional buttons (like audio, tactile feedback, etc).
     * @param  {*}                panel  The panel to add the buttons to.
     * @param  {Object<string,*>} data   The data from scene_info.json.
     * @returns void
     */
    // function setupSubMenuNavButtons(panel: any, data: any): void {
    // Turn on speech synthesis.
    // allButtons.push(
    //     new ButtonWrapper({
    //         clickFunc: (buttonWrapper) => {
    //             // TODO:
    //             if (buttonWrapper.value) {
    //                 VRVoiceCommands.setup(data);
    //             } else {
    //                 VRVoiceCommands.stopVoiceCommands();
    //             }
    //         },
    //         default: false,
    //         falseTxt: "Audio Commands\n(On)",
    //         initFunc: (buttonWrapper) => {
    //             buttonWrapper.isVisible(false);  // No audio to begin.
    //         },
    //         name: "menu-audio-commands-button",
    //         panel,
    //         trueTxt: "Audio Commands\n(Off)",
    //     }),
    // );
    // }
    /**
     * Setup the toggle button on the floor that turns the main menu on and off.
     * @returns void
     */
    function setupMainMenuToggleButton() {
        // Also set up a manager at your feet. This turns the main manager on and
        // off.
        // gui3DMenuManagers[0] = new BABYLON.GUI.GUI3DManager(Vars.scene);
        var panelToggle = new BABYLON.GUI.StackPanel3D();
        GUI3DMenuManager.addControl(panelToggle);
        // Set up the button
        // let camera = Vars.scene.activeCamera;
        exports.openMainMenuFloorButton = new Button.ButtonWrapper({
            clickFunc: function (buttonWrapper) {
                if (!buttonWrapper.value) {
                    showOnlyButtonsOfLevel(0);
                }
                else {
                    showOnlyButtonsOfLevel(1);
                }
                commonMenuAnchor.position.copyFrom(CommonCamera.getCameraPosition());
                commonMenuAnchor.rotation.y = CommonCamera.getCameraRotationY(); //  + Math.PI * 0.5;
                // camera.rotation.y + Math.PI * 0.5;  // TODO: What about if VR camera?
            },
            default: false,
            falseTxt: "Show Menu",
            level: 0,
            name: "menu-visible-button",
            panel: panelToggle,
            trueTxt: "Hide Menu",
        });
        window["openMainMenuFloorButton"] = exports.openMainMenuFloorButton;
        // Set up the button anchor and move/rotate it.
        var mainMenuAnchorToggle = new BABYLON.TransformNode(""); // this can be a mesh, too
        panelToggle.linkToTransformNode(mainMenuAnchorToggle);
        mainMenuAnchorToggle.rotation.x = Math.PI * 0.5;
        // Update button position with each turn of the render loop.
        mainMenuAnchorToggle.position.copyFrom(VRPoints.groundPointBelowCamera);
        mainMenuAnchorToggle.position.y = mainMenuAnchorToggle.position.y + 0.1;
        mainMenuAnchorToggle.rotation.y = CommonCamera.getCameraRotationY();
        Vars.scene.registerBeforeRender(function () {
            // setInterval(() => {
            mainMenuAnchorToggle.position.copyFrom(VRPoints.groundPointBelowCamera); // Prob
            mainMenuAnchorToggle.position.y = mainMenuAnchorToggle.position.y + 0.1; // No prob
            mainMenuAnchorToggle.rotation.y = CommonCamera.getCameraRotationY(); // Prob
            // camera.rotation.y;  // TODO: What about VR camera.
            // }, 1000);
        });
    }
    /**
     * Shows the buttons associated with a specific submenu level.
     * @param  {number} level
     * @returns void
     */
    function showOnlyButtonsOfLevel(level) {
        if (level > 1) { // Not the main menu.
            latestLevelViewed = level;
        }
        // Hide all the buttons.
        for (var _i = 0, allButtons_1 = allButtons; _i < allButtons_1.length; _i++) {
            var btn = allButtons_1[_i];
            btn.isVisible(false);
        }
        if (level === 0) {
            // It's the button on the floor. Just needed to hide all buttons, so
            // now you're good.
            return;
        }
        // Figure out what layout to use.
        var btnIdxOrder = [];
        if (menuInfFlat[level].length <= 4) {
            btnIdxOrder = [7, 6, 5, 4];
        }
        else if (menuInfFlat[level].length <= 8) {
            btnIdxOrder = [7, 6, 5, 4, 11, 10, 9, 8];
        }
        else if (menuInfFlat[level].length <= 12) {
            btnIdxOrder = [3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8];
        }
        else {
            btnIdxOrder = [3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12];
        }
        // Show enough buttons for the number of menu items to show, and update
        // them.
        for (var i = 0; i < menuInfFlat[level].length; i++) {
            var btnidx = btnIdxOrder[i];
            var menuInfFlatThisOne = menuInfFlat[level][i];
            var btn = allButtons[btnidx];
            btn.updateTxt(menuInfFlatThisOne.txt);
            btn.updateColor(menuInfFlatThisOne.color);
            btn.clickFunc = menuInfFlatThisOne.func;
            // menuInfFlatThisOne.upLevel doesn't seem to be necessary.
            btn.isVisible(true);
        }
    }
    ;
});
// function updateMainMenuButtons() {
//     for (let objID in visibilityInfo) {
//         if (visibilityInfo.hasOwnProperty(objID)) {
//             let button = visibilityInfo[objID][0];
//             let visibilityState = visibilityInfo[objID][1];
//             let txtStr = objID.replace(/.sdf/g, "").replace(/.pdb/g, "");
//             txtStr = txtStr.replace(/.wrl/g, "");
//             txtStr = txtStr.replace(/_/g, "\n");
//             txtStr += "\n(" + (visibilityState ? "Hide" : "Show") + ")";
//             let text = new BABYLON.GUI.TextBlock();
//             text.text = txtStr;
//             text.color = "white";
//             // text.fontSize = 24;
//             text.resizeToFit = true;
//             button.content.dispose();
//             button.content = text;
//             button.isVisible = mainMenuVisible;
//         }
//     }
// }
;
define('Mols/Load',["require", "exports", "../Scene/Optimizations", "../UI/Menu3D/Menu3D", "../Vars", "./3DMol/ThreeDMol", "./CommonLoader"], function (require, exports, Optimizations, Menu3D, Vars, ThreeDMol, CommonLoader) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Load in the molecules.
     */
    function setup() {
        // If run in gltf mode, loads from gltf files (e.g., from biotite
        // environment). Otherwise, loads from url and other sources.
        CommonLoader.beforeLoading();
        jQuery.getJSON("scene_info.json", function (data) {
            // Deactivate menu if appropriate.
            if (data["menuActive"] === false) {
                Vars.vrVars.menuActive = false;
            }
            // Load using GLTF (e.g., from babylonjs).
            // if (data["objIDs"] !== undefined) {
            //     // The objIDs list contains IDs corresponding to gltf files.
            //    GLTF.setup(data);
            // } else {
            // So loading it from a pdb file via 3Dmoljs.
            ThreeDMol.setup(data);
            // }
            if (Vars.vrVars.menuActive) {
                Menu3D.setup(data);
            }
            // Update the shadows.
            Optimizations.updateEnvironmentShadows();
        });
    }
    exports.setup = setup;
});

define('UI/LoadingScreens',["require", "exports", "../Vars"], function (require, exports, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var intervalID;
    /**
     * Removes the initial loading screen, to let the user know that the initial
     * javascript file is loading.
     * @returns void
     */
    function removeLoadingJavascriptScreen() {
        // Remove the initial loading javascript screen (not the babylonjs loading
        // screen... That's to come).
        document.getElementById("loading-container").outerHTML = "";
    }
    exports.removeLoadingJavascriptScreen = removeLoadingJavascriptScreen;
    /**
     * Update the text displayed on the babylonjs loading scene.
     * @param  {string} msg  The text to update.
     * @returns void
     */
    function babylonJSLoadingMsg(msg) {
        // Just to make sure there isn't a fight between the two ways of showing
        // babylonjs loading messages.
        stopFakeLoading();
        Vars.engine.displayLoadingUI(); // Keep it up while progressing...
        Vars.engine.loadingUIText = msg;
    }
    exports.babylonJSLoadingMsg = babylonJSLoadingMsg;
    /**
     * Starts the fake loading screen, to give the impression that things are
     * loading.
     * @param  {number} initialVal  The initial fake value (%).
     * @returns void
     */
    function startFakeLoading(initialVal) {
        var fakeVal = initialVal;
        clearInterval(intervalID);
        intervalID = setInterval(function () {
            fakeVal = fakeVal + 0.02 * (99 - fakeVal);
            Vars.engine.displayLoadingUI(); // Keep it up while progressing...
            Vars.engine.loadingUIText = "Loading the main scene... " + fakeVal.toFixed(0) + "%";
        }, 100);
    }
    exports.startFakeLoading = startFakeLoading;
    /**
     * Stop the fake-loading splash screen.
     * @returns void
     */
    function stopFakeLoading() {
        clearInterval(intervalID);
    }
    exports.stopFakeLoading = stopFakeLoading;
});

// Sets up tweaks to the UI.
define('UI/UI2D',["require", "exports", "../UI/OpenPopup", "../Vars"], function (require, exports, OpenPopup, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Sets up the 2D button that can be used to launch VR.
     * @returns void
     */
    function setup() {
        addRunModeButtons();
    }
    exports.setup = setup;
    /**
     * Adds the 2D button to the DOM, makes it clickable.
     * @returns void
     */
    function addRunModeButtons() {
        // Adds some additional buttons to the UI. Source:
        // https://iconmonstr.com/fullscreen-thin-svg/
        jQuery("body").append("\n        <button\n          title=\"Click to switch to full screen\"\n          id=\"fullscreen-button\"\n          class=\"ui-button\"\n          style=\"color:white;\n                 width:80px;\n                 right:20px;\n                 position:absolute;\n                 height:50px;\n                 bottom:80px;\n                 background-color:rgba(51,51,51,0.7);\n                 border:none;\n                 outline:none;\n                 cursor:pointer;\">\n            <svg\n              style=\"position:relative; left:0.5px;\"\n              width=\"48\" height=\"48\"\n              xmlns=\"http://www.w3.org/2000/svg\"\n              xmlns:svg=\"http://www.w3.org/2000/svg\"\n              clip-rule=\"evenodd\">\n                <g class=\"layer\">\n                    <path d=\"m47.799999,43.649999l-47.699999,0l0,-39.749999l47.699999,0l0,39.749999zm-1.9875,-37.762499l-43.724999,0l0,35.774999l43.724999,0l0,-35.774999zm-7.95,13.9125l-1.9875,0l0,-6.441487l-22.341487,22.341487l6.441487,0l0,1.9875l-9.9375,0l0,-9.9375l1.9875,0l0,6.441487l22.341487,-22.341487l-6.441487,0l0,-1.9875l9.9375,0l0,9.9375z\" fill=\"#ffffff\" id=\"svg_1\"/>\n                </g>\n            </svg>\n        </button>\n\n        <button\n          title=\"Click for help\"\n          id=\"help-button\"\n          class=\"ui-button\"\n          style=\"color:white;\n                 width:80px;\n                 right:20px;\n                 position:absolute;\n                 height:50px;\n                 bottom:140px;\n                 background-color:rgba(51,51,51,0.7);\n                 border:none;\n                 outline:none;\n                 cursor:pointer;\">\n                 <svg version=\"1.2\" baseProfile=\"tiny\" id=\"Layer_1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"\n\t x=\"0px\" y=\"0px\" width=\"48px\" height=\"48px\" viewBox=\"0 0 48 48\" xml:space=\"preserve\">\n<path fill=\"none\" stroke=\"#FFFFFF\" stroke-width=\"2\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-miterlimit=\"10\" d=\"\n\tM35.5,9.8c1.7,5.4-0.6,8-1.6,8.9c-1.9,1.9-4.5,4.7-5.8,7c-1.5,2.7-4.1,12-6.8,4.4c-3.2-9.1,1.3-11.6,3.5-13.4\n\tc1.5-1.3,3.4-4.3,0.5-5.3c-4-1.3-6.1,5.3-10.7,4c-3-0.8-3.2-4.1-2.2-6.6C15.4,1.7,32.5,0.6,35.5,9.8L35.5,9.8z\"/>\n<path fill=\"none\" stroke=\"#FFFFFF\" stroke-width=\"2\" stroke-miterlimit=\"10\" d=\"M28.3,39.6c0-5.5-8.5-5.5-8.5,0S28.3,45.1,28.3,39.6\n\t\"/>\n</svg>\n\n        </button>\n    ");
        var fullScreenButton = jQuery("#fullscreen-button");
        fullScreenButton.click(function () {
            Vars.engine.switchFullscreen(true);
            jQuery("#renderCanvas").focus(); // So keypress will work.
        });
        var helpButton = jQuery("#help-button");
        helpButton.click(function () {
            // window.open("help/index.html", "_blank");
            OpenPopup.openUrlModal("Help", "help/index.html");
        });
        // Also make VR button visible.
        document.getElementById("babylonVRiconbtn").style.opacity = "1.0"; // Non IE;
        document.getElementById("babylonVRiconbtn").style.filter = "alpha(opacity=1.0)"; // IE;
    }
    /**
     * A function to activate debug mode.
     * @returns void
     */
    function debugMode() {
        Vars.scene.debugLayer.show();
        setTimeout(function () {
            document.getElementById("inspector-host").style.zIndex = "15";
            document.getElementById("scene-explorer-host").style.zIndex = "15";
        }, 500);
    }
    window["debugMode"] = debugMode;
});

define('Scene/LoadAndSetup',["require", "exports", "../Cameras/Setup", "../Cameras/VRCamera", "../Mols/Load", "../Navigation/Navigation", "../Navigation/Pickables", "../UI/LoadingScreens", "../UI/UI2D", "../Vars", "./Optimizations"], function (require, exports, CamerasSetup, VRCamera, MolsLoad, Navigation, Pickables, LoadingScreens, UI2D, Vars, Optimizations) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Load the scene, setup the VR, etc.
     * @returns void
     */
    function load() {
        Vars.setup();
        // Remove the initial loading javascript screen (not the babylonjs loading
        // screen... That's to come).
        LoadingScreens.removeLoadingJavascriptScreen();
        // Because of this error, you need to setup VR before loading the babylon
        // scene:
        // https://forum.babylonjs.com/t/createdefaultvrexperience-android-chrome-vr-mode-change-material-unusual-error/2738/4
        vrSetupBeforeBabylonFileLoaded();
        babylonScene(function () {
            // Setup the cameras.
            CamerasSetup.setup();
            // Setup the general things that apply regardless of the mode used.
            // Here because it requires a ground mesh. Set up the floor mesh
            // (hidden).
            Navigation.setup();
            // Setup function to manage pickable objects (e.g., floor).
            Pickables.setup();
            // Sets up nav selection buttons in DOM.
            UI2D.setup();
            // Load extra objects
            MolsLoad.setup();
            // loadingAssetsDone(), below, will run once all assets loaded.
        });
        // Watch for browser/canvas resize events
        window.addEventListener("resize", function () {
            Vars.engine.resize();
        });
    }
    exports.load = load;
    function vrSetupBeforeBabylonFileLoaded() {
        // You'll need a navigation mesh.
        var navMeshToUse = BABYLON.Mesh.CreateSphere("navTargetMesh", 4, 0.1, Vars.scene);
        var navMeshMat = new BABYLON.StandardMaterial("myMaterial", Vars.scene);
        navMeshMat.diffuseColor = new BABYLON.Color3(1, 0, 1);
        navMeshToUse.material = navMeshMat;
        // Setup the VR here. Set up the parameters (filling in missing values,
        // for example). Also saves the modified params to the params module
        // variable.
        Vars.setupVR({
            groundMeshName: "ground",
            navTargetMesh: navMeshToUse,
        });
        // Setup the VR camera
        VRCamera.setup();
        // Optimize the scene to make it run better.
        Optimizations.setup();
        // For debugging...
        // trackDebugSphere();
        window.Vars = Vars;
    }
    /**
     * Load the scene from the .babylon file.
     * @param  {Function} callBackFunc The callback function to run when loaded.
     * @returns void
     */
    function babylonScene(callBackFunc) {
        LoadingScreens.babylonJSLoadingMsg("Loading the main scene...");
        // TODO: Use LoadAssetContainerAsync instead?
        BABYLON.SceneLoader.LoadAssetContainer("scene/", "scene.babylon", Vars.scene, function (container) {
            LoadingScreens.startFakeLoading(90);
            Vars.scene.executeWhenReady(function () {
                container.addAllToScene();
                // There should be only one camera at this point, because the VR
                // stuff is in the callback. Make that that one camera is the
                // active one.
                Vars.scene.activeCamera = Vars.scene.cameras[0];
                // Attach camera to canvas inputs
                // Vars.scene.activeCamera.attachControl(Vars.canvas);
                keepOnlyLightWithShadowlightSubstr();
                hideObjectsUsedForSceneCreation();
                optimizeMeshesAndMakeClickable();
                callBackFunc();
            });
        }, function (progress) {
            if (progress["lengthComputable"]) {
                // Only to 90 to not give the impression that it's done loading.
                var percent = Math.round(90 * progress["loaded"] / progress["total"]);
                LoadingScreens.babylonJSLoadingMsg("ALoading the main scene... " + percent.toString() + "%");
            }
        });
    }
    /**
     * Only the light with shadowlight should be retained.
     * @returns void
     */
    function keepOnlyLightWithShadowlightSubstr() {
        // Delete all the lights but the first one that has the substring
        // shadowlight or shadow_light.
        var foundFirstShadowLight = false;
        var indexToUse = 0;
        while (Vars.scene.lights.length > 1) {
            var light = Vars.scene.lights[indexToUse];
            var lightName = light.name.toLowerCase();
            var isShadowLight = ((lightName.indexOf("shadowlight") !== -1) ||
                (lightName.indexOf("shadow_light") !== -1));
            if (!isShadowLight) {
                // It's not a shadow light. Delete it.
                Vars.scene.lights[indexToUse].dispose();
            }
            else if (foundFirstShadowLight) {
                // You've already found a shadow light. Delete additional
                // ones.
                Vars.scene.lights[indexToUse].dispose();
            }
            else {
                // Must be the first shadow light. Don't delete, but make
                // note of it.
                foundFirstShadowLight = true;
                indexToUse++;
            }
        }
    }
    /**
     * Hides meshes that are only used ofr scene creation.
     * @returns void
     */
    function hideObjectsUsedForSceneCreation() {
        // Hide objects used for scene creation.
        for (var meshIdx in Vars.scene.meshes) {
            if (Vars.scene.meshes[meshIdx].name === "protein_box") {
                // Vars.scene.meshes[meshIdx].dispose();
                Vars.scene.getMeshByName("protein_box").isVisible = false;
                // scene.getMeshByName("protein_box").visibility
            }
        }
    }
    /**
     * Optimizes meshes and makes them clickable.
     * @returns void
     */
    function optimizeMeshesAndMakeClickable() {
        // Optimize and make meshes clickable. Also, make sure all meshes
        // are emmissive.
        for (var meshIdx in Vars.scene.meshes) {
            if (Vars.scene.meshes[meshIdx].material) {
                var mesh = Vars.scene.meshes[meshIdx];
                // It needs to be emmisive (so always baked).
                if ((mesh.material.emissiveTexture === undefined) || (mesh.material.emissiveTexture === null)) {
                    mesh.material.emissiveTexture = mesh.material.diffuseTexture;
                    // Below seems important to comment out. .clone()
                    // above and .dispose() below doesn't work. Also,
                    // below = null and = undefined didn't work. No good
                    // solutions, so leave diffuse texture in place?
                    // mesh.material.diffuseTexture = undefined;
                    mesh.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
                    mesh.material.specularColor = new BABYLON.Color3(0, 0, 0);
                    mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                }
                // TODO: Using false below to not freeze materials.
                // They are white otherwise. Good to figure out why.
                Optimizations.freezeMeshProps(mesh, false);
                Pickables.makeMeshMouseClickable({
                    mesh: mesh,
                    scene: Vars.scene,
                });
            }
        }
    }
    function loadingAssetsDone() {
        // Give it a bit to let one render cycle go through. Hackish,
        // admittedly.
        setTimeout(Optimizations.updateEnvironmentShadows, 1000);
        // Stop showing the fake loading screen.
        LoadingScreens.stopFakeLoading();
        // Make sure the camera can see far enough.
        Vars.scene.activeCamera.maxZ = 250;
        // Make sure camera can see objects that are very close.
        Vars.scene.activeCamera.minZ = 0;
        // Start the render loop. Register a render loop to repeatedly render the
        // scene
        Vars.engine.runRenderLoop(function () {
            // try {
            Vars.scene.render();
            // }  catch {
            // console.log("ERROR!");
            // }
            // console.log("render");
        });
    }
    exports.loadingAssetsDone = loadingAssetsDone;
});


///<reference path="external/require/require.d.ts" />
require.config({
    // paths: {
    //     // jquery: 'https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min',
    //     jquery: '../js/jquery.min',
    //     bootstrap: '../js/bootstrap-3.3.7/dist/js/bootstrap.min'
    // },
    // shim: {
    //     bootstrap: {
    //         deps: ['jquery']
    //     }
    // },
    "urlArgs": "bust=" + (new Date()).getTime(),
});
// This require function starts the app
require(["Scene/LoadAndSetup"], function (SceneLoad) {
    SceneLoad.load(); // ("renderCanvas");
});

define("Start", function(){});

}());