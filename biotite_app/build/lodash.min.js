(function () {
/**
 * @license almond 0.3.3 Copyright jQuery Foundation and other contributors.
 * Released under MIT license, http://github.com/requirejs/almond/LICENSE
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice,
        jsSuffixRegExp = /\.js$/;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap, lastIndex,
            foundI, foundStarMap, starI, i, j, part, normalizedBaseParts,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name) {
            name = name.split('/');
            lastIndex = name.length - 1;

            // If wanting node ID compatibility, strip .js from end
            // of IDs. Have to do this here, and not in nameToUrl
            // because node allows either .js or non .js to map
            // to same file.
            if (config.nodeIdCompat && jsSuffixRegExp.test(name[lastIndex])) {
                name[lastIndex] = name[lastIndex].replace(jsSuffixRegExp, '');
            }

            // Starts with a '.' so need the baseName
            if (name[0].charAt(0) === '.' && baseParts) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that 'directory' and not name of the baseName's
                //module. For instance, baseName of 'one/two/three', maps to
                //'one/two/three.js', but we want the directory, 'one/two' for
                //this normalization.
                normalizedBaseParts = baseParts.slice(0, baseParts.length - 1);
                name = normalizedBaseParts.concat(name);
            }

            //start trimDots
            for (i = 0; i < name.length; i++) {
                part = name[i];
                if (part === '.') {
                    name.splice(i, 1);
                    i -= 1;
                } else if (part === '..') {
                    // If at the start, or previous value is still ..,
                    // keep them so that when converted to a path it may
                    // still work when converted to a path, even though
                    // as an ID it is less than ideal. In larger point
                    // releases, may be better to just kick out an error.
                    if (i === 0 || (i === 1 && name[2] === '..') || name[i - 1] === '..') {
                        continue;
                    } else if (i > 0) {
                        name.splice(i - 1, 2);
                        i -= 2;
                    }
                }
            }
            //end trimDots

            name = name.join('/');
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            var args = aps.call(arguments, 0);

            //If first arg is not require('string'), and there is only
            //one arg, it is the array form without a callback. Insert
            //a null so that the following concat is correct.
            if (typeof args[0] !== 'string' && args.length === 1) {
                args.push(null);
            }
            return req.apply(undef, args.concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    //Creates a parts array for a relName where first part is plugin ID,
    //second part is resource ID. Assumes relName has already been normalized.
    function makeRelParts(relName) {
        return relName ? splitPrefix(relName) : [];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relParts) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0],
            relResourceName = relParts[1];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relResourceName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relResourceName));
            } else {
                name = normalize(name, relResourceName);
            }
        } else {
            name = normalize(name, relResourceName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i, relParts,
            args = [],
            callbackType = typeof callback,
            usingExports;

        //Use name if no relName
        relName = relName || name;
        relParts = makeRelParts(relName);

        //Call the callback to define the module, if necessary.
        if (callbackType === 'undefined' || callbackType === 'function') {
            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relParts);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback ? callback.apply(defined[name], args) : undefined;

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, makeRelParts(callback)).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (config.deps) {
                req(config.deps, config.callback);
            }
            if (!callback) {
                return;
            }

            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        return req(cfg);
    };

    /**
     * Expose module registry for debugging and tooling
     */
    requirejs._defined = defined;

    define = function (name, deps, callback) {
        if (typeof name !== 'string') {
            throw new Error('See almond README: incorrect module build, no module name');
        }

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("external/almond", function(){});

// A place to put variables that need to be accessed from multiple places.
// This module is a place to store "global" variables.
define('Vars',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Also some constants
    /** @const {number} */
    exports.TRANSPORT_DURATION = 11;
    /** @const {number} */
    exports.MAX_DIST_TO_MOL_ON_TELEPORT = 1.5;
    /** @const {number} */
    exports.MIN_DIST_TO_MOL_ON_TELEPORT = 1.0;
    /** @const {number} */
    exports.MAX_VERTS_PER_SUBMESH = 2000; // This is kind of an arbitrary number.
    /** @const {number} */
    exports.BUTTON_SPHERE_RADIUS = 1.2; // the radius of the spheres around buttons used to detect clicks.
    /** @const {number} */
    exports.MENU_RADIUS = 2.5; // 3 is comfortable, but doesn't work in crowded environments.
    /** @const {number} */
    exports.MENU_MARGIN = 0.05; // 0.15;  // 0.1;
    /** @const {number} */
    exports.PAD_MOVE_SPEED = 0.01;
    /** @const {number} */
    exports.VR_CONTROLLER_TRIGGER_DELAY_TIME = 500; // time to wait between triggers.
    /** @const {number} */
    exports.VR_CONTROLLER_PAD_ROTATION_DELAY_TIME = 750; // time to wait between triggers.
    /** @const {number} */
    exports.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET = 0.1;
    /** @const {number} */
    exports.MAX_TELEPORT_DIST = 15;
    /** @const {number} */
    exports.TRANSPARENT_FLOOR_ALPHA = 0.05; // 0.02;
    // IOS doesn't support a lot of features!
    /** @const {*} */
    exports.IOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window["MSStream"];
    /**
     * Setup the Vars.
     * @returns void
     */
    function setup() {
        exports.canvas = document.getElementById("renderCanvas");
        // Generate the BABYLON 3D engine
        exports.engine = new BABYLON.Engine(exports.canvas, true);
        if (true) { // true means use manifest files.
            BABYLON.Database.IDBStorageEnabled = true;
        }
        else {
            exports.engine.enableOfflineSupport = false;
        }
        exports.scene = new BABYLON.Scene(exports.engine);
        // For debugging
        window["scene"] = exports.scene;
    }
    exports.setup = setup;
    /**
     * Determines the camera height from the active camera.
     * @returns void
     */
    function determineCameraHeightFromActiveCamera() {
        // Get the camera height. But I don't think this variable is every
        // actually used anywhere...
        if (exports.cameraHeight === undefined) {
            // Calculate the camera height from it's position.
            /** @const {*} */
            const ray = new BABYLON.Ray(exports.scene.activeCamera.position, new BABYLON.Vector3(0, -1, 0), 50);
            /** @const {*} */
            const pickingInfo = exports.scene.pickWithRay(ray, (mesh) => {
                return (mesh.name === "ground");
            });
            exports.cameraHeight = pickingInfo.distance;
        }
    }
    exports.determineCameraHeightFromActiveCamera = determineCameraHeightFromActiveCamera;
    /**
     * Sets the camera height.
     * @param  {number} height  The height.
     * @returns void
     */
    function setCameraHeight(height) {
        exports.cameraHeight = height;
    }
    exports.setCameraHeight = setCameraHeight;
    /**
     * Modifies the parameters, adding in default values where values are missing,
     * for example. Also saves the updated params to the module-level params
     * variable.
     * @param  {Object<string,*>} initParams The initial parameters.
     */
    function setupVR(initParams) {
        // Create the vr helper. See http://doc.babylonjs.com/how_to/webvr_helper
        let params = {
            // "createDeviceOrientationCamera": false,  // This makes phone ignore motion sensor. No good.
            "createDeviceOrientationCamera": true,
        };
        if (exports.scene.getEngine().getCaps().multiview) {
            // Much faster according to
            // https://doc.babylonjs.com/how_to/multiview, but not supported in
            // all browsers.
            params["useMultiview"] = true;
        }
        exports.vrHelper = exports.scene.createDefaultVRExperience(params);
        // Hide the vrHelper icon initially.
        document.getElementById("babylonVRiconbtn").style.opacity = "0.0"; // Non IE;
        document.getElementById("babylonVRiconbtn").style.filter = "alpha(opacity=0)"; // IE;
        window["vrHelper"] = exports.vrHelper;
        // console.log(window.vrHelper);
        // Save the parameter to params (module-level variable).
        exports.vrVars = initParams;
        // Whether the menu system is active. True by default.
        exports.vrVars.menuActive = true;
    }
    exports.setupVR = setupVR;
});

// This sets up the non vr camera. Not everyone has a vr headset.
define('Cameras/NonVRCamera',["require", "exports", "../Vars"], function (require, exports, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** @type {*} */
    let nonVRCamera;
    let lastCameraPosAboveGroundMesh = new BABYLON.Vector3(0, 0, 0);
    /**
     * Sets up the nonVR camera (not everyone has a VR headset).
     * @returns void
     */
    function setup() {
        setupNonVRCameraObj();
    }
    exports.setup = setup;
    /**
     * Sets up the camera object.
     * @returns void
     */
    function setupNonVRCameraObj() {
        // The VRHelper already created a camera. Need to set it up.
        nonVRCamera = Vars.scene.activeCamera;
        // Enable navigation via both WASD and the arrows keys.
        nonVRCamera.keysUp = [87, 38];
        nonVRCamera.keysDown = [83, 40];
        nonVRCamera.keysLeft = [65, 37];
        nonVRCamera.keysRight = [68, 39];
        // Turn on gravity. Note: Turning this on causes problems, and it doesn't
        // seem to be necessary. Well, it does help with arrow/wsad navigation
        // (can't fly off).
        // Vars.scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
        Vars.scene.gravity = new BABYLON.Vector3(0, -0.1, 0);
        nonVRCamera.applyGravity = true;
        // Enable collision detection. Note that the second paramerter is a
        // radius.
        setCameraElipsoid();
        // Turn on collisions as appropriate. Note that groundMesh collisions are
        // enabled in Navigation.
        // scene.workerCollisions = true;
        Vars.scene.collisionsEnabled = true;
        nonVRCamera.checkCollisions = true;
        // Slow the camera.
        nonVRCamera.speed = 0.1;
        // Make sure orientation is default
        // nonVRCamera.rotation = new BABYLON.Vector3(0, 0, 0);
        nonVRCamera.attachControl(Vars.canvas, true);
        // Position the camera on the floor. See
        // http://www.html5gamedevs.com/topic/30837-gravity-camera-stops-falling/
        nonVRCamera._updatePosition();
    }
    /**
     * Sets up the collision elipsoid around the non-VR camera.
     * @returns void
     */
    function setCameraElipsoid() {
        // Depends on camera height.
        nonVRCamera.ellipsoid = new BABYLON.Vector3(1.0, 0.5 * Vars.cameraHeight, 1.0);
    }
    exports.setCameraElipsoid = setCameraElipsoid;
});

define('Cameras/Setup',["require", "exports", "../Vars", "./NonVRCamera"], function (require, exports, Vars, NonVRCamera) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Runs after the babylon scene is loaded.
    function setup() {
        // You need to make the camera from the babylon file active. First, get
        // the babylon camera.
        exports.cameraFromBabylonFile = Vars.scene.cameras.filter((c) => c.name.indexOf("VR") === -1)[0];
        // If true, sets up device orientation camera. Otherwise, just use one in
        // babylonjs file. A toggle for debugging.
        if (true) {
            // Create a device orientation camera that matches the one loaded from
            // the babylon file.
            let DevOrCamera = new BABYLON.DeviceOrientationCamera("DevOr_camera", exports.cameraFromBabylonFile.position.clone(), Vars.scene, true);
            DevOrCamera.rotation = exports.cameraFromBabylonFile.rotation.clone();
            // DevOrCamera.resetToCurrentRotation();
            // For debugging.
            // window["cameraFromBabylonFile"] = cameraFromBabylonFile;
            // window["DevOrCamera"] = DevOrCamera;
            // Update the active camera to be the device orientation one.
            Vars.scene.activeCamera = DevOrCamera; // cameraFromBabylonFile
            // Make sure device orientation camera pointing in direction of
            // original camera.
            Vars.scene.activeCamera.rotationQuaternion = BABYLON.Quaternion.FromEulerVector(exports.cameraFromBabylonFile.rotation);
        }
        else {
            Vars.scene.activeCamera = exports.cameraFromBabylonFile;
        }
        // Get the camera height.
        Vars.determineCameraHeightFromActiveCamera();
        // Setup the default (nonVR) camera.
        NonVRCamera.setup();
    }
    exports.setup = setup;
});

// This module has functions for storing various important points in the
// scene. Note that the camera location is in CommonCamera, not here.
define('Navigation/Points',["require", "exports", "../Cameras/CommonCamera", "../Vars", "./Pickables"], function (require, exports, CommonCamera, Vars, Pickables) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pointWayOffScreen = new BABYLON.Vector3(-1000, 1000, 1000);
    exports.groundPointBelowCamera = new BABYLON.Vector3(0, 0, 0);
    exports.groundPointBelowStarePt = new BABYLON.Vector3(0, 0, 0);
    exports.curStarePt = new BABYLON.Vector3(0, 0, 0);
    /**
     * Sets the curStarePt variable externally.
     * @param {*} pt
     * @returns void
     */
    function setCurStarePt(pt) {
        exports.curStarePt.copyFrom(pt);
    }
    exports.setCurStarePt = setCurStarePt;
    /**
     * Sets up the key points detection. Stare point, point below the camera, etc.
     * @returns void
     */
    function setup() {
        // Constantly update the stare point info. Also, position the tracking
        // mesh.
        Vars.scene.registerBeforeRender(() => {
            // Get the stare point. Here because it should be updated with every
            // frame.
            setStarePointInfo();
            cancelStareIfFarAway();
            Vars.vrVars.navTargetMesh.position.copyFrom(exports.curStarePt);
            // Hide Vars.vrVars.navTargetMesh if it's on padNavSphereAroundCamera.
            if (Pickables.curPickedMesh !== undefined) {
                Vars.vrVars.navTargetMesh.isVisible = Pickables.curPickedMesh !== Pickables.padNavSphereAroundCamera;
            }
            // Also the point on the ground below the camera should be updated
            // every turn of the render loop (to position the menu button).
            let pickedGroundPt = groundPointPickingInfo(CommonCamera.getCameraPosition()).pickedPoint;
            if (pickedGroundPt) {
                exports.groundPointBelowCamera = pickedGroundPt;
            }
            // Also the point on the ground below the stare point.
            pickedGroundPt = groundPointPickingInfo(exports.curStarePt).pickedPoint;
            if (pickedGroundPt) {
                exports.groundPointBelowStarePt = pickedGroundPt;
            }
        });
    }
    exports.setup = setup;
    /**
     * Gets the point where the user is looking (or pointing with controllers).
     * @returns void
     */
    function setStarePointInfo() {
        // This function runs with ever turn of the render loop. Set's information
        // about what you're looking/pointing at. Info saved to curStarePt
        /** @type {*} */
        let ray;
        if (Vars.vrVars.navMode === 3 /* NoVR */) {
            // No VR yet. So it's outside the realm of the VRHelper. Calculate
            // it using the looking direction.
            // Get a ray extending out in the direction of the stare.
            ray = Vars.scene.activeCamera.getForwardRay();
        }
        else if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // Find the valid gazetracker mesh.
            /** @type {*} */
            let gazeTrackerMesh;
            if (Vars.vrVars.navMode === 1 /* VRWithControllers */) {
                gazeTrackerMesh = Vars.vrHelper.rightControllerGazeTrackerMesh;
                if (!gazeTrackerMesh) {
                    gazeTrackerMesh = Vars.vrHelper.leftControllerGazeTrackerMesh;
                }
            }
            else if (Vars.vrVars.navMode === 2 /* VRNoControllers */) {
                gazeTrackerMesh = Vars.vrHelper.gazeTrackerMesh;
            }
            if (!gazeTrackerMesh) {
                console.log("error!");
                return;
            }
            if (!gazeTrackerMesh.isVisible) {
                setCurStarePt(exports.pointWayOffScreen);
            }
            else {
                setCurStarePt(gazeTrackerMesh.absolutePosition);
            }
            // Construct a ray from the camera to the stare obj
            /** @type {*} */
            let camPos = CommonCamera.getCameraPosition();
            // ray = new BABYLON.Ray(camPos, curStarePt.subtract(camPos), 1000);
            ray = new BABYLON.Ray(camPos, exports.curStarePt.subtract(camPos));
        }
        else {
            console.log("Unexpected error.");
        }
        setPickPointAndObjInScene(ray);
    }
    exports.setStarePointInfo = setStarePointInfo;
    /**
     * Cancel the stare point if it's very far away.
     * @returns void
     */
    function cancelStareIfFarAway() {
        if (exports.curStarePt === undefined) {
            setCurStarePt(exports.pointWayOffScreen);
            Pickables.setCurPickedMesh(undefined);
        }
        else {
            /** @type {number} */
            let dist = BABYLON.Vector3.Distance(CommonCamera.getCameraPosition(), exports.curStarePt);
            if (dist > 10) {
                setCurStarePt(exports.pointWayOffScreen);
                Pickables.setCurPickedMesh(undefined);
            }
        }
    }
    /**
     * Sets the pick point and object currently looking at.
     * @param  {*}       ray	          The looking ray.
     * @param  {boolean} [updatePos=true] Whether to update the position.
     * @returns void
     */
    function setPickPointAndObjInScene(ray, updatePos = true) {
        // Determines where the specified ray intersects a pickable object.
        /** @const {*} */
        const pickingInfo = Vars.scene.pickWithRay(ray, (mesh) => {
            return Pickables.checkIfMeshPickable(mesh);
        });
        /** @type {number} */
        let pickingInfoDist = pickingInfo.distance;
        if ((pickingInfo.hit) && (pickingInfoDist < Vars.MAX_TELEPORT_DIST)) {
            // It does hit the floor or some other pickable object. Return the
            // point.
            if (updatePos) {
                setCurStarePt(pickingInfo.pickedPoint);
            }
            Pickables.setCurPickedMesh(pickingInfo.pickedMesh);
        }
        else {
            // It doesn't hit the floor or is too far away, so return null.
            setCurStarePt(exports.pointWayOffScreen);
            Pickables.setCurPickedMesh(undefined);
        }
    }
    /**
     * Gets the picking info for the point on the ground below a specified point.
     * @param   {*}              pt  The specified point.
     * @returns Object<string,*> The picking info, projected onto the ground.
     */
    function groundPointPickingInfo(pt) {
        /** @const {*} */
        const ray = new BABYLON.Ray(pt, new BABYLON.Vector3(0, -1, 0), 50);
        /** @const {*} */
        const pickingInfo = Vars.scene.pickWithRay(ray, (mesh) => {
            return (mesh.id === Vars.vrVars.groundMesh.id);
        });
        return pickingInfo;
    }
    exports.groundPointPickingInfo = groundPointPickingInfo;
});

// These functions include camera functions common to all kinds of cameras.
define('Cameras/CommonCamera',["require", "exports", "../Navigation/Points", "../Vars"], function (require, exports, Points, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** @const {*} */
    const forwardVec = new BABYLON.Vector3(1, 0, 0);
    /** @const {*} */
    const upVec = new BABYLON.Vector3(1, 0, 0);
    // let activeCamPos = new BABYLON.Vector3(0, 0, 0);
    /**
     * Gets the location of the camera. If VR camera, gets the left eye.
     * @returns * The camera location.
     */
    function getCameraPosition() {
        // If it's a VR camera, you need to make an adjustment.
        /** @const {*} */
        const activeCam = Vars.scene.activeCamera;
        let activeCamPos = activeCam.position.clone();
        if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // VR camera, so get eye position.
            if (activeCam.leftCamera) {
                activeCamPos.copyFrom(activeCam.leftCamera.globalPosition);
            }
            else {
                console.log("Prob here");
            }
        }
        return activeCamPos;
    }
    exports.getCameraPosition = getCameraPosition;
    /**
     * Sets the camera location. Accounts for difference between eye and camera
     * pos if VR camera.
     * @param  {*} pt The new location.
     * @returns void
     */
    function setCameraPosition(pt) {
        if (Vars.vrVars.navMode === 3 /* NoVR */) {
            // A regular camera. Just move it there.
            let activeCam = Vars.scene.activeCamera;
            activeCam.position.copyFrom(pt);
        }
        else if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // Not ever tested... not sure it works...
            let activeCam = Vars.vrHelper.webVRCamera;
            // A VR camera. Need to account for the fact that the eye might not be
            // at the same place as the camera.
            activeCam.position.copyFrom(pt.subtract(getVecFromEyeToCamera()));
        }
    }
    exports.setCameraPosition = setCameraPosition;
    function getCameraRotation() {
        if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            return Vars.scene.activeCamera.deviceRotationQuaternion.clone();
        }
        else {
            return Vars.scene.activeCamera.rotationQuaternion.clone();
        }
    }
    exports.getCameraRotation = getCameraRotation;
    function getCameraRotationQuaternion() {
        if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // window["camera"] = Vars.scene.activeCamera;
            // return Vars.scene.activeCamera.leftCamera.rotationQuaternion;
            return Vars.scene.activeCamera.deviceRotationQuaternion;
        }
        else {
            return Vars.scene.activeCamera.rotationQuaternion;
        }
    }
    exports.getCameraRotationQuaternion = getCameraRotationQuaternion;
    function setCameraRotationQuaternion(rotQua) {
        if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            console.log("PROBLEM!");
        }
        else {
            // console.log(Vars.scene.activeCamera.rotationQuaternion, rotQua.clone());
            Vars.scene.activeCamera.rotationQuaternion = rotQua.clone();
        }
    }
    exports.setCameraRotationQuaternion = setCameraRotationQuaternion;
    /**
     * Gets the camera rotation
     * @returns * The rotation.
     */
    function getCameraRotationY() {
        if ((Vars.vrVars.navMode === 2 /* VRNoControllers */) ||
            (Vars.vrVars.navMode === 1 /* VRWithControllers */)) {
            // Complicated in the case of a VR camera.
            let groundPtVec = Points.groundPointBelowStarePt.subtract(Points.groundPointBelowCamera);
            /** @type {number} */
            let angle = BABYLON.Vector3.GetAngleBetweenVectors(groundPtVec, forwardVec, upVec);
            if (groundPtVec.z < 0) {
                angle = -angle;
            }
            // Make sure the angle is between 0 and 2 * Math.PI
            while (angle < 0) {
                angle = angle + 2 * Math.PI;
            }
            while (angle > 2 * Math.PI) {
                angle = angle - 2 * Math.PI;
            }
            angle = angle + Math.PI * 0.5;
            return angle;
        }
        else {
            // This is much simplier with a non-VR camera.
            let activeCam = Vars.scene.activeCamera;
            let activeCamRot = activeCam.rotation.clone();
            return activeCamRot.y; // + Math.PI * 0.5;
        }
    }
    exports.getCameraRotationY = getCameraRotationY;
    /**
     * Gets the vector from the camera location to the eye location. For a VR
     * camera, these can be different.
     * @returns * The vector.
     */
    function getVecFromEyeToCamera() {
        if (Vars.vrVars.navMode === 3 /* NoVR */) {
            // Not in VR mode? Then there is no eye.
            return new BABYLON.Vector3(0, 0, 0);
        }
        // Note that some VR cameras don't track position, only orientation.
        // Google cardboard is an example.
        let activeCam = Vars.vrHelper.webVRCamera;
        let deltaVec;
        if (activeCam.leftCamera) {
            let leftEyePos = activeCam.leftCamera.globalPosition;
            deltaVec = leftEyePos.subtract(activeCam.position);
        }
        else {
            deltaVec = new BABYLON.Vector3(0, 0, 0);
        }
        return deltaVec;
    }
    exports.getVecFromEyeToCamera = getVecFromEyeToCamera;
});

// Functions to handle molecule shadows.
define('Mols/Shadows',["require", "exports", "../Vars"], function (require, exports, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Setup the shadow generator that casts a shadow from the molecule meshes.
     * @returns void
     */
    function setupShadowGenerator() {
        // Get the light that will cast the shadows.
        let light = Vars.scene.lights[0];
        /** @type {Object<string,number>} */
        let shadowInf = getBlurDarknessFromLightName();
        shadowInf.T = 0;
        shadowInf.blur = 2;
        // Set up the shadow generator.
        // Below gives error on iphone sometimes...
        if (!Vars.IOS) {
            exports.shadowGenerator = new BABYLON.ShadowGenerator(4096, light);
            exports.shadowGenerator.useBlurExponentialShadowMap = true;
            exports.shadowGenerator.setDarkness(shadowInf.darkness);
            // If using kernal, do below.
            exports.shadowGenerator.useKernelBlur = true; // Very good shadows, but more expensive.
            exports.shadowGenerator.blurKernel = shadowInf.blur; // Degree of bluriness.
            // If not using kernal, do below
            // shadowGenerator.blurScale = 7;  // Good for surfaces and ribbon.
            // shadowGenerator.blurBoxOffset = 5;
            // Will make debugging easier.
            // window.shadowGenerator = shadowGenerator;
            // Old parameters not used:
            // shadowGenerator.usePoissonSampling = true;  // Good but slow.
        }
        else {
            console.log("iOS, so not generating shadows... causes an error... See https://forum.babylonjs.com/t/issues-between-shadowgenerator-and-ios-osx/795");
        }
    }
    exports.setupShadowGenerator = setupShadowGenerator;
    /**
     * Gets the blur and darkness to use on shadows and molecule lighting.
     * @returns Object<string,number>
     */
    function getBlurDarknessFromLightName() {
        let light = Vars.scene.lights[0];
        // Set some default values for the shadows.
        let blur = 64;
        let darkness = 0.9625; // Lower numbers are darker.
        // Now overwrite those values if reason to do so in the name of the light.
        let blurMatches = light.name.match(/blur_([0-9\.]+)/g);
        if (blurMatches !== null) {
            blur = +blurMatches[0].substr(5);
        }
        /** @type Array<string> */
        let darknessMatches = light.name.match(/dark_([0-9\.]+)/g);
        if (darknessMatches !== null) {
            darkness = +darknessMatches[0].substr(5);
        }
        return { blur, darkness };
    }
    exports.getBlurDarknessFromLightName = getBlurDarknessFromLightName;
    /**
     * Sets up the shadow-catcher mesh.
     * @returns void
     */
    function setupShadowCatchers() {
        // Go through and find the shdow catchers
        /** @type {number} */
        let len = Vars.scene.meshes.length;
        for (let idx = 0; idx < len; idx++) {
            let mesh = Vars.scene.meshes[idx];
            if ((mesh.name.toLowerCase().indexOf("shadowcatcher") !== -1) || (mesh.name.toLowerCase().indexOf("shadow_catcher") !== -1)) {
                // Make the material
                mesh.material = new BABYLON.ShadowOnlyMaterial("shadow_catch" + idx.toString(), Vars.scene);
                mesh.material.activeLight = Vars.scene.lights[0];
                // mesh.material.alpha = 0.1;
                // It can receive shadows.
                mesh.receiveShadows = true;
            }
        }
    }
    exports.setupShadowCatchers = setupShadowCatchers;
});

define('Scene/Optimizations',["require", "exports", "../Mols/Shadows", "../Vars"], function (require, exports, Shadows, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Setup the optimizations.
     * @returns void
     */
    function setup() {
        // Turn on scene optimizer
        BABYLON.SceneOptimizer.OptimizeAsync(Vars.scene, 
        // BABYLON.SceneOptimizerOptions.HighDegradationAllowed(),
        sceneOptimizerParameters());
        // Assume no part of the scene goes on to empty (skybox?)
        Vars.scene.autoClear = false; // Color buffer
        Vars.scene.autoClearDepthAndStencil = false;
        // Modify some meshes
        /** @type {number} */
        let len = Vars.scene.meshes.length;
        let zeroVec = new BABYLON.Color3(0, 0, 0);
        for (let idx = 0; idx < len; idx++) {
            /** @const {*} */
            const mesh = Vars.scene.meshes[idx];
            // Meshes that contain the word "baked" should be shadeless
            if ((mesh.name.indexOf("baked") !== -1) && (mesh.material !== undefined)) {
                // Make material shadeless
                mesh.material.diffuseColor = zeroVec;
                mesh.material.specularColor = zeroVec;
                mesh.material.emissiveTexture = mesh.material.diffuseTexture;
                mesh.material.diffuseTexture = null;
                // Material won't be changing. But apparently this is no
                // longer a needed optimization:
                // http://www.html5gamedevs.com/topic/37540-when-is-it-safe-to-freeze-materials/
                // mesh.material.freeze();
                // Assume no change in location (because that would require
                // recalculating shadows)
                mesh.freezeWorldMatrix();
            }
        }
    }
    exports.setup = setup;
    /**
     * Gets the number of vertices in a mesh.
     * @param  {*} mesh The mesh.
     * @returns {number|null}  The number of vertices.
     */
    function getNumVertices(mesh) {
        // First, get the number of vertexes.
        let numVertexes = 0;
        if (mesh !== undefined) {
            /** @type {Array<*>} */
            let vertexData = mesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
            if (vertexData === null) {
                return null;
            } // Something like __root__
            numVertexes = vertexData.length / 3;
        }
        else {
            numVertexes = 0;
        }
        return numVertexes;
    }
    /**
     * Optimize the ability to pick meshes, using octrees.
     * @param  {*} mesh The mesh.
     * @returns void
     */
    function optimizeMeshPicking(mesh) {
        // First, get the number of vertexes.
        /** @type {number} */
        let numVertexes = getNumVertices(mesh);
        if (numVertexes === null) {
            return;
        } // Something like __root__
        // If there are very few vertexes, don't use this optimization. This
        // prevents it's use on button spheres, for example.
        if (numVertexes < 100) {
            return;
        }
        // Now get the number of submeshes to use.
        let numSubMeshes = 1 + Math.floor(numVertexes / Vars.MAX_VERTS_PER_SUBMESH);
        // Subdivide the mesh if necessary.
        if (numSubMeshes > 1) {
            mesh.subdivide(numSubMeshes);
        }
        // Now use octree for picking and collisions.
        // mesh.createOrUpdateSubmeshesOctree(64, 2);  // Messes up culling on protein all sticks.
        // mesh.useOctreeForCollisions = true;
    }
    exports.optimizeMeshPicking = optimizeMeshPicking;
    /**
     * Freeze the properties on a mesh, so they don't need to be recalculated.
     * @param  {*}       mesh	                The mesh.
     * @param  {boolean} [freezeMaterial=true]  Whether to freeze the material.
     * @param  {boolean} [worldMatrix=true]     Whether to freeze the world matrix.
     * @returns void
     */
    function freezeMeshProps(mesh, freezeMaterial = true, worldMatrix = true) {
        if (freezeMaterial) {
            mesh.material.freeze();
            // material.unfreeze();
        }
        // if (worldMatrix) {
        // TODO: Why doesn't this work?
        // mesh.freezeWorldMatrix();
        // mesh.unfreezeWorldMatrix();
        // }
    }
    exports.freezeMeshProps = freezeMeshProps;
    /**
     * Update the environment shadows. They are frozen otherwise.
     * @returns void
     */
    function updateEnvironmentShadows() {
        if (Shadows.shadowGenerator) {
            // Update the shadows. They are frozen otherwise.
            Vars.scene.lights[0].autoUpdateExtends = true;
            Shadows.shadowGenerator.getShadowMap().refreshRate = BABYLON.RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
            Vars.scene.lights[0].autoUpdateExtends = false;
        }
    }
    exports.updateEnvironmentShadows = updateEnvironmentShadows;
    /**
     * Prepares scene-optimizer paramters.
     * @returns * The parameters.
     */
    function sceneOptimizerParameters() {
        // See https://doc.babylonjs.com/how_to/how_to_use_sceneoptimizer
        // The goal here is to maintain a frame rate of 60. Check every two
        // seconds. Very similar to HighDegradationAllowed
        let result = new BABYLON.SceneOptimizerOptions(25, 2000);
        let priority = 0;
        result.optimizations.push(new BABYLON.ShadowsOptimization(priority));
        // The below won't make a difference for my scenes anyway...
        // result.optimizations.push(new BABYLON.MergeMeshesOptimization(priority));
        result.optimizations.push(new BABYLON.LensFlaresOptimization(priority));
        result.optimizations.push(new BABYLON.PostProcessesOptimization(priority));
        result.optimizations.push(new BABYLON.ParticlesOptimization(priority));
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new RemoveSurfaces(priority)); // Remove surfaces
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new BABYLON.TextureOptimization(priority, 512));
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new BABYLON.RenderTargetsOptimization(priority));
        result.optimizations.push(new BABYLON.TextureOptimization(priority, 256));
        result.optimizations.push(new ReportOptimizationChange(priority));
        // Next priority
        priority++;
        result.optimizations.push(new BABYLON.HardwareScalingOptimization(priority, 4));
        result.optimizations.push(new SimplifyMeshes(priority, 500)); // Simplify meshes.
        result.optimizations.push(new ReportOptimizationChange(priority));
        return result;
    }
    /**
     * Entirely remove a mesh.
     * @param  {*} mesh The mesh to remove.
     * @returns void
     */
    function removeMeshEntirely(mesh) {
        if (mesh !== null) {
            mesh.dispose();
        }
        mesh = null;
    }
    exports.removeMeshEntirely = removeMeshEntirely;
    class ReportOptimizationChange {
        /**
         * Remove the surface mesh (it takes a lot of resources).
         * @param  {number} priority The priority of this optimization.
         * @returns void
         */
        constructor(priority) {
            if (priority === undefined) {
                priority = 0;
            }
            this["priority"] = priority;
            this["apply"] = (scene) => {
                console.log("Optimization priority:", this["priority"]);
                console.log("FPS:", Vars.engine.getFps());
                console.log("");
                return true;
            };
            this["getDescription"] = () => {
                return "Reports the current priority. For debugging.";
            };
        }
    }
    // tslint:disable-next-line:max-classes-per-file
    class RemoveSurfaces {
        /**
         * Remove the surface mesh (it takes a lot of resources).
         * @param  {number} priority The priority of this optimization.
         * @returns void
         */
        constructor(priority) {
            if (typeof priority === "undefined") {
                priority = 0;
            }
            this["priority"] = priority;
            this["apply"] = (scene) => {
                // Delete the surface mesh. Note that it will still be visible in the
                // main menu, but oh well.
                let surfaces = Vars.scene.getMeshByName("surfaces.wrl");
                removeMeshEntirely(surfaces);
                // Failed attempty below, but perhaps worth revisiting in the future.
                // VoiceCommands.showOrHideModel("", "surface", false);
                // VoiceCommands.interpretHideShowCommands(["surface"], true);
                return true;
            };
            this["getDescription"] = () => {
                return "Removes surface representations.";
            };
        }
    }
    // tslint:disable-next-line:max-classes-per-file
    class SimplifyMeshes {
        /**
         * A scene optimization to decimate the big meshes.
         * @param  {number} priority                  The priority of this
         *                                            optimization.
         * @param  {number} minNumVertsThatIsProblem  The target number of vertices.
         * @param  {number} [decimationLevel=]        The decimation level. If not
         *                                            specified, calculated from
         *                                            minNumVertsThatIsProblem.
         */
        constructor(priority, minNumVertsThatIsProblem, decimationLevel = undefined) {
            if (typeof priority === "undefined") {
                priority = 0;
            }
            this["priority"] = priority;
            this["apply"] = (scene) => {
                /** @type {Array<Array<number,*,number>>} */
                let meshesToConsider = [];
                /** @type {number} */
                let len = Vars.scene.meshes.length;
                for (let meshIdx = 0; meshIdx < len; meshIdx++) {
                    let mesh = Vars.scene.meshes[meshIdx];
                    // If it's decimated, skip it. It will be deleted and
                    // recreated.
                    if (mesh.name.indexOf("Decimated") !== -1) {
                        continue;
                    }
                    // For now, skip it if it was a wrl file in origin (because
                    // simplification erases colors).
                    // if (mesh.name.indexOf(".wrl") === -1) { continue; }
                    // mesh.material.wireframe = true;
                    // Get the number of vertexes.
                    /** @type {number} */
                    let numVertexes = getNumVertices(mesh);
                    if (numVertexes === null) {
                        continue;
                    } // Something like __root__
                    if (numVertexes < minNumVertsThatIsProblem) {
                        continue;
                    }
                    meshesToConsider.push([
                        numVertexes, mesh,
                        (decimationLevel === undefined) ? 1. - minNumVertsThatIsProblem / numVertexes : decimationLevel,
                    ]);
                    // Simplify the mesh. See
                    // https://doc.babylonjs.com/how_to/in-browser_mesh_simplification
                    // You used to be able to simplify a mesh without LOD.
                    // let decimator = new BABYLON.QuadraticErrorSimplification(mesh);
                    // simplify({
                    //     "decimationIterations": 100,
                    //     "aggressiveness": 7,
                    //     // "syncIterations": ?  // Just keep default. Not sure what this is.
                    // }, () => { return; });
                }
                // Order the meshes from the one with most vertices to the one with
                // least (prioritize bad ones).
                meshesToConsider.sort((a, b) => b[0] - a[0]);
                // Simplify those meshes.
                let meshesToConsiderLen = meshesToConsider.length;
                for (let i = 0; i < meshesToConsiderLen; i++) {
                    /** @type {Array<number,*,number>} */
                    let meshToConsider = meshesToConsider[i];
                    let mesh = meshToConsider[1];
                    /** @type {number} */
                    let decimationLvel = meshToConsider[2];
                    // Remove the existing LODs if they exist.
                    while (mesh.getLODLevels().length > 0) {
                        let firstLODMesh = mesh.getLODLevels()[0]["mesh"];
                        mesh.removeLODLevel(firstLODMesh);
                        removeMeshEntirely(firstLODMesh);
                    }
                    // https://doc.babylonjs.com/api/classes/babylon.mesh#simplify
                    mesh.simplify([{ "quality": decimationLvel, "distance": 0.001 }], false, BABYLON.SimplificationType.QUADRATIC, () => {
                        // console.log("GGG2", mesh.name, mesh.getLODLevels().length);
                        // let simpMesh = mesh.getLODLevels()[0]["mesh"];
                        // removeMeshEntirely(mesh);
                        // console.log(simpMesh);
                        // window["mesh"] = mesh;
                        // console.log(mesh.name, decimationLvel);
                    });
                }
                return true;
            };
            this["getDescription"] = () => {
                return "Simplifies the geometry of complex objects in the scene.";
            };
        }
    }
});

// This module handles all things navigation related.
define('Navigation/Navigation',["require", "exports", "../Cameras/CommonCamera", "../Cameras/NonVRCamera", "../Scene/Optimizations", "../Vars", "./Pickables", "./Points"], function (require, exports, CommonCamera, NonVRCamera, Optimizations, Vars, Pickables, Points) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // ***** TODO: WORK ON THIS:
    // export let interactingObjs = [];
    // export function addInteractingObj(mesh) { interactingObjs.push(mesh); }
    let currentlyTeleporting = false;
    /**
     * Setup the navigation system.
     * @returns void
     */
    function setup() {
        // Allways collide with a floor mesh.
        Vars.vrVars.groundMesh = Vars.scene.getMeshByID(Vars.vrVars.groundMeshName);
        if (Vars.vrVars.groundMesh === null) {
            alert("No mesh named " + Vars.vrVars.groundMeshName);
        }
        Vars.vrVars.groundMesh.checkCollisions = true;
        // The ground should generally be hidden. There's a chance it could be
        // turned into glass too. See Mols.
        Vars.vrVars.groundMesh.visibility = 0;
        Optimizations.optimizeMeshPicking(Vars.vrVars.groundMesh);
        Pickables.makeMeshMouseClickable({
            callBack: actOnStareTrigger,
            mesh: Vars.vrVars.groundMesh,
        });
        // Initially, no VR.
        Vars.vrVars.navMode = 3 /* NoVR */;
        // Setup triggers.
        setupTriggers();
        // Keep track up critical points in the scene (like stare points).
        Points.setup();
        // Create a div to intercept clicks if needed. Add clear div over canvas.
        setupCaptureMouseClicksOutsideBabylon();
        // Constantly monitor the position of the camera. If it's no longer over
        // the floor, move it back to its previous position.
        keepCameraOverFloor();
    }
    exports.setup = setup;
    /** @type {*} */
    let lastCameraPt;
    /** @type {string} */
    let lastCameraName = "";
    /**
     * Check and make sure the camera is over the ground. If not, move it back so
     * it is over the ground.
     * @returns void
     */
    function keepCameraOverFloor() {
        // lastCameraPt = Vars.scene.activeCamera.position.clone();
        lastCameraPt = CommonCamera.getCameraPosition();
        Vars.scene.registerBeforeRender(() => {
            // let cameraPt = Vars.scene.activeCamera.position.clone();
            let cameraPt = CommonCamera.getCameraPosition(); // cloned pt.
            let groundPointBelowCamera = Points.groundPointPickingInfo(cameraPt);
            if ((groundPointBelowCamera.pickedMesh === null) && (lastCameraName === Vars.scene.activeCamera.id)) {
                // You're not above the ground! This shouldn't happen, but it can
                // occasionally. Return the camera to its previous position. One
                // example is if you're using the controllers on a HTC vive to
                // navigate (forward/backward).
                // console.log("Reverting camera position..");
                // Vars.scene.activeCamera.position = lastCameraPt;
                CommonCamera.setCameraPosition(lastCameraPt);
            }
            else {
                lastCameraPt = cameraPt;
                lastCameraName = Vars.scene.activeCamera.id;
            }
            // console.log(groundPointBelowCamera);
        });
    }
    /**
     * Sets up additional triggers.
     * @returns void
     */
    function setupTriggers() {
        // Space always triggers
        let body = jQuery("body");
        body.keypress((e) => {
            if (e.charCode === 32) {
                // Space bar
                actOnStareTrigger();
            }
        });
        // Mouse clicks are handled elsewhere...
    }
    let lastTrigger = 0;
    /**
     * Triggers an action, based on the mesh you're currently looking at.
     * @returns void
     */
    function actOnStareTrigger() {
        // There is a refractory period to prevent rapid trigger fires.
        let curTime = new Date().getTime();
        if (curTime - lastTrigger < 250) {
            return;
        }
        else {
            lastTrigger = curTime;
        }
        // Click, space, or something. You need to decide how to act.
        switch (Pickables.getCategoryOfCurMesh()) {
            case 2 /* Ground */:
                // It's the ground, so teleport there.
                console.log("teleport");
                teleport();
                break;
            case 4 /* Molecule */:
                // It's a molecule, so increase the height.
                grow();
                break;
            case 3 /* Button */:
                // It's a button. Click function is attached to the mesh (see
                // GUI.ts).
                Pickables.curPickedMesh.clickFunc();
            default:
                // None.
                break;
        }
    }
    exports.actOnStareTrigger = actOnStareTrigger;
    /**
     * Teleport to a given location.
     * @param  {*}         [newLoc=undefined] The new location. Uses stare point
     *                                        if no location given.
     * @param  {Function}  [callBack=]        The callback function once teleport
     *                                        is done.
     * @returns void
     */
    function teleport(newLoc = undefined, callBack = undefined) {
        currentlyTeleporting = true;
        if (callBack === undefined) {
            callBack = () => { return; };
        }
        // Hide the bigger nav mesh. It will appear again elsewhere.
        Vars.vrHelper.gazeTrackerMesh.isVisible = false;
        // Animate the transition to the new location.
        /** @const {*} */
        const animationCameraTeleportation = new BABYLON.Animation("animationCameraTeleportation", "position", 90, BABYLON.Animation.ANIMATIONTYPE_VECTOR3, BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT);
        // The start location.
        let startLoc = CommonCamera.getCameraPosition();
        // Get the new location.
        if (newLoc === undefined) {
            // If it's not defined, use the current stare point.
            newLoc = new BABYLON.Vector3(Points.curStarePt.x, Points.curStarePt.y + Vars.cameraHeight, Points.curStarePt.z);
        }
        // Correct if VR camera.
        let eyeToCamVec = CommonCamera.getVecFromEyeToCamera();
        newLoc = newLoc.subtract(eyeToCamVec);
        startLoc = startLoc.subtract(eyeToCamVec);
        // Animate to new location.
        /** @const {Array<Object<string, *>>} */
        const animationCameraTeleportationKeys = [
            { "frame": 0, "value": startLoc },
            { "frame": Vars.TRANSPORT_DURATION, "value": newLoc },
        ];
        animationCameraTeleportation.setKeys(animationCameraTeleportationKeys);
        /** @const {*} */
        const activeCamera = Vars.scene.activeCamera;
        activeCamera.animations = [];
        activeCamera.animations.push(animationCameraTeleportation);
        Vars.scene.beginAnimation(activeCamera, 0, Vars.TRANSPORT_DURATION, false, 1, () => {
            // Animation finished callback.
            currentlyTeleporting = false;
            Vars.vrHelper.gazeTrackerMesh.isVisible = true;
            // Erase animation
            activeCamera.animations = [];
            callBack();
        });
    }
    /**
     * Teleport and grow. Fires if you click on a molecular mesh.
     * @returns void
     */
    function grow() {
        // let ptBelowStarePt = Points.groundPointPickingInfo(Points.curStarePt).pickedPoint;
        let ptBelowStarePt = Points.groundPointBelowStarePt;
        // Get the vector form the stare point to the camera.
        let cameraPos = CommonCamera.getCameraPosition();
        let vecStarePtCamera = Points.curStarePt.subtract(cameraPos);
        /** @type {number} */
        let vecStarePtDist = vecStarePtCamera.length();
        let newPt;
        if (0.1 * vecStarePtDist < Vars.MIN_DIST_TO_MOL_ON_TELEPORT) {
            // Teleporting 90% of the way would put you too close to the target.
            newPt = Points.curStarePt.subtract(vecStarePtCamera.normalize().scale(Vars.MIN_DIST_TO_MOL_ON_TELEPORT));
        }
        else if (0.1 * vecStarePtDist > Vars.MAX_DIST_TO_MOL_ON_TELEPORT) {
            // Teleporting 90% of the way would put you too far from the target.
            newPt = Points.curStarePt.subtract(vecStarePtCamera.normalize().scale(Vars.MAX_DIST_TO_MOL_ON_TELEPORT));
        }
        else if (0.1 * vecStarePtDist < Vars.MAX_DIST_TO_MOL_ON_TELEPORT) {
            // Teleporting 90% of the way would put you in the sweet spot. Do
            // that.
            newPt = cameraPos.add(vecStarePtCamera.scale(0.9));
        }
        // Now tweak the height to match the point exactly (not on the line
        // between camera and point).
        newPt.y = Points.curStarePt.y;
        // You need to make sure the new point isn't within the button sphere at
        // your feet. If not, you could get trapped.
        if (newPt.y - ptBelowStarePt.y < 0.5 * Vars.BUTTON_SPHERE_RADIUS + 0.1) {
            newPt.y = ptBelowStarePt.y + 0.5 * Vars.BUTTON_SPHERE_RADIUS + 0.1;
        }
        // Set the new height. 0.01 is important so elipse doesn't get caught on
        // new ground.
        Vars.setCameraHeight(Points.curStarePt.y - ptBelowStarePt.y);
        teleport(newPt, () => {
            // Make sure the collision elipsoid surrounding the non-VR camera
            // matches the new height.
            NonVRCamera.setCameraElipsoid();
        });
    }
    let captureMouseClicksDiv = undefined;
    let currentlyCapturingMouseClicks = false;
    /**
     * Setup the ability to capture clicks.
     * @returns void
     */
    function setupCaptureMouseClicksOutsideBabylon() {
        // Unfortunately, when you click on phones it takes away control from the
        // orientation sensor. Babylon.js claims to have fixed this, but I don't
        // think it is fixed: https://github.com/BabylonJS/Babylon.js/pull/6042
        // I'm going to detect if it's currently reading from the orientation
        // sensor and throw up a div to capture clicks if it is. A hackish
        // solution that works.
        // Setup div to intercept clicks if needed. Add clear div over canvas.
        captureMouseClicksDiv = jQuery("#capture-clicks");
        // captureMouseClicksDiv = jQuery("#renderCanvas");
        // Make it clickable.
        captureMouseClicksDiv.click(() => {
            console.log("clicked!");
            actOnStareTrigger();
        });
        // captureMouseClicksDiv.on("pointerdown", () => {
        //     alert("hello!");
        // });
        Vars.scene.registerBeforeRender(() => {
            checkCaptureMouseClicksOutsideBabylon();
        });
    }
    /**
     * Checks if you should currently be capturing clicks. TODO: Should you be
     * checking this with every render? I don't know that it can change, so maybe
     * you just need to check it once?
     * @returns void
     */
    function checkCaptureMouseClicksOutsideBabylon() {
        let deviceOrientation = Vars.scene.activeCamera.inputs.attached.deviceOrientation;
        let deviceBeingOriented;
        if (!deviceOrientation) {
            // On htc vive, deviceOrientation does not exist.
            deviceBeingOriented = false;
        }
        else {
            // Check other devices (whether in browser or in cardboard, etc).
            deviceBeingOriented = (deviceOrientation._alpha !== 0) ||
                (deviceOrientation._beta !== 0) ||
                (deviceOrientation._gamma !== 0);
        }
        if (deviceBeingOriented && !currentlyCapturingMouseClicks) {
            currentlyCapturingMouseClicks = true;
            captureMouseClicksDiv.show();
            // console.log("show");
        }
        else if (!deviceBeingOriented && currentlyCapturingMouseClicks) {
            currentlyCapturingMouseClicks = false;
            captureMouseClicksDiv.hide();
            // console.log("hide");
        }
        else {
            // console.log("confused");
            // console.log(deviceBeingOriented);
            // console.log(currentlyCapturingMouseClicks);
        }
    }
});

// This module includes functions to manage which meshes in the scene are
// pickable.
define('Navigation/Pickables',["require", "exports", "../Cameras/CommonCamera", "../Scene/Optimizations", "../Vars", "./Navigation"], function (require, exports, CommonCamera, Optimizations, Vars, Navigation) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let pickableMeshes = [];
    let pickableButtons = [];
    let pickableMolecules = [];
    /**
     * Sets the currently picked mesh.
     * @param  {*} mesh The mesh.
     */
    function setCurPickedMesh(mesh) { exports.curPickedMesh = mesh; }
    exports.setCurPickedMesh = setCurPickedMesh;
    /**
     * Sets up the pickables.
     * @returns void
     */
    function setup() {
        pickableMeshes.push(Vars.vrVars.groundMesh);
    }
    exports.setup = setup;
    /**
     * Adds a mesh to the list of pickable buttons.
     * @param  {*} mesh The mesh.
     * @returns void
     */
    function addPickableButton(mesh) {
        pickableMeshes.push(mesh);
        pickableButtons.push(mesh);
        Optimizations.optimizeMeshPicking(mesh);
        makeMeshMouseClickable({
            mesh,
            callBack: () => {
                // Here click the button rather than acting on the stare point
                // (default).
                mesh.clickFunc();
            },
        });
    }
    exports.addPickableButton = addPickableButton;
    /**
     * Adds a mesh to the list of pickable molecule meshes.
     * @param  {*} mesh The mesh.
     * @returns void
     */
    function addPickableMolecule(mesh) {
        pickableMeshes.push(mesh);
        pickableMolecules.push(mesh);
        Optimizations.optimizeMeshPicking(mesh);
        makeMeshMouseClickable({ mesh });
    }
    exports.addPickableMolecule = addPickableMolecule;
    /**
     * Determines if a given mesh is pickable.
     * @param  {*} mesh The mesh.
     * @returns boolean True if it is pickable. False otherwise.
     */
    function checkIfMeshPickable(mesh) {
        // Floor is always pickable, even if not visible.
        if (mesh.id === Vars.vrVars.groundMesh.id) {
            return true;
        }
        // If not visible, then not pickable. Note that something could be
        // entirely transparent (visibility is 0), but it will still intercept the
        // stare point. This is by design.
        if (!mesh.isVisible) {
            return false;
        }
        // if (mesh.visibility === 0) { return false; }
        // Otherwise, pick only if in the list.
        return pickableMeshes.indexOf(mesh) !== -1;
    }
    exports.checkIfMeshPickable = checkIfMeshPickable;
    /**
     * Get the category of the currently selected mesh.
     * @returns *
     */
    function getCategoryOfCurMesh() {
        if (exports.curPickedMesh === undefined) {
            return 1 /* None */;
        }
        else if (exports.curPickedMesh === Vars.vrVars.groundMesh) {
            return 2 /* Ground */;
        }
        else if (pickableButtons.indexOf(exports.curPickedMesh) !== -1) {
            return 3 /* Button */;
        }
        else if (pickableMolecules.indexOf(exports.curPickedMesh) !== -1) {
            return 4 /* Molecule */;
        }
        else if (exports.curPickedMesh === exports.padNavSphereAroundCamera) {
            return 5 /* padNavSphereAroundCamera */;
        }
        else {
            return 1 /* None */;
        }
    }
    exports.getCategoryOfCurMesh = getCategoryOfCurMesh;
    /**
     * Make it so a given mesh can be clicked with the mouse.
     * @param  {Object<string,*>} params The parameters. See interface above.
     * @returns void
     */
    function makeMeshMouseClickable(params) {
        if (params.callBack === undefined) {
            params.callBack = Navigation.actOnStareTrigger;
        }
        if (params.scene === undefined) {
            params.scene = Vars.scene;
        }
        if (params.mesh === undefined) {
            return;
        }
        params.mesh.actionManager = new BABYLON.ActionManager(params.scene);
        params.mesh.actionManager.registerAction(new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnPickTrigger, () => {
            // If it's in VR mode, there are no mouse clicks. This is
            // important to prevent a double click with controllers.
            if (Vars.vrVars.navMode !== 3 /* NoVR */) {
                // TODO: What about phones? Still clickable? May need to
                // modify above.
                return;
            }
            params.callBack();
        }));
    }
    exports.makeMeshMouseClickable = makeMeshMouseClickable;
    /**
     * Places a cube around the canmera so you can navegate even when not pointing
     * at a molecule or anything. Good for pad-based navigation, but not
     * teleportation.
     * @returns void
     */
    function makePadNavigationSphereAroundCamera() {
        exports.padNavSphereAroundCamera = BABYLON.Mesh.CreateSphere("padNavSphereAroundCamera", 4, Vars.MAX_TELEPORT_DIST - 1.0, Vars.scene);
        exports.padNavSphereAroundCamera.flipFaces(true);
        let mat = new BABYLON.StandardMaterial("padNavSphereAroundCameraMat", Vars.scene);
        mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        mat.specularColor = new BABYLON.Color3(0, 0, 0);
        mat.opacityTexture = null;
        exports.padNavSphereAroundCamera.material = mat;
        exports.padNavSphereAroundCamera.visibility = 0.0; // It's an invisible sphere.
        // Doing it this way so follows camera even if camera changes.
        Vars.scene.registerBeforeRender(() => {
            exports.padNavSphereAroundCamera.position = CommonCamera.getCameraPosition();
        });
        // It needs to be pickable
        pickableMeshes.push(exports.padNavSphereAroundCamera);
        // Pretend like it's a molecule. Teleportation will be disabled elsewhere.
        // addPickableMolecule(padNavSphereAroundCamera);
    }
    exports.makePadNavigationSphereAroundCamera = makePadNavigationSphereAroundCamera;
});

define('Cameras/VRControllers',["require", "exports", "../Navigation/Navigation", "../Navigation/Pickables", "../Navigation/Points", "../Vars", "./CommonCamera", "./VRCamera"], function (require, exports, Navigation, Pickables, Points, Vars, CommonCamera, VRCamera) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let lastTriggerTime = 0;
    let lastPadRotationTime = 0;
    let padMoveSpeedFactor = 0.0;
    let padRotateSpeedFactor = 0.0;
    let padPressed = false;
    /**
     * Sets up the enter and exit functions when controllers load. No unload
     * function, though I'd like one.
     * @returns void
     */
    function setup() {
        // Put a cube around the camera. This is to receive picker for pad-based
        // navigation, even if you're not pointing at a protein.
        Pickables.makePadNavigationSphereAroundCamera();
        // onControllersAttachedObservable doesn't work. I'd prefer that one...
        Vars.vrHelper.webVRCamera.onControllerMeshLoadedObservable.add((webVRController) => {
            // Update navMode
            // console.re.clear();
            // console.re.log("moo1");
            Vars.vrVars.navMode = 1 /* VRWithControllers */;
            console.log("controller loaded");
            VRCamera.setupGazeTracker();
            console.log("Isnt there on pickable or something");
            setupTrigger(webVRController);
            setupPad(webVRController);
        });
        // Doesn't appear to be a detach function...
    }
    exports.setup = setup;
    /**
     * Sets up the trigger button.
     * @param  {*} webVRController The web controller object.
     * @returns void
     */
    function setupTrigger(webVRController) {
        // Monitor for triggers. Only allow one to fire every once in a while.
        // When it does, teleport to that location.
        webVRController.onTriggerStateChangedObservable.add((state) => {
            if (!state["pressed"]) {
                // Only trigger if it's pressed.
                return;
            }
            /** @const {number} */
            const curTime = new Date().getTime();
            // console.log(curTime, lastTriggerTime, curTime - lastTriggerTime, Vars.VR_CONTROLLER_TRIGGER_DELAY_TIME);
            if (curTime - lastTriggerTime > Vars.VR_CONTROLLER_TRIGGER_DELAY_TIME) {
                // Enough time has passed...
                // console.log("triggered");
                lastTriggerTime = curTime;
                Navigation.actOnStareTrigger();
            }
        });
    }
    /**
     * Sets up the VR controller pads.
     * @param  {*} webVRController
     * @returns void
     */
    function setupPad(webVRController) {
        // console.re.log("moo2");
        // Also allow navigation via the pad (non teleporting).
        // console.log(webVRController);
        webVRController.onPadStateChangedObservable.add((state) => {
            // console.re.log("DEBUG: onPadStateChangedObservable");
            padPressed = state["pressed"];
            if ((padPressed) &&
                (Math.abs(padMoveSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET) &&
                (Math.abs(padRotateSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET)) {
                console.log("Would reset camera view if you didn't get an error below...");
                // Vars.vrHelper.webVRCamera.resetToCurrentRotation();
                return;
            }
        });
        // webVRController.onMainButtonStateChangedObservable.add((state) => {
        //     console.re.log("DEBUG: onMainButtonStateChangedObservable");
        // });
        // webVRController.onSecondaryButtonStateChangedObservable.add((state) => {
        //     console.re.log("DEBUG: onSecondaryButtonStateChangedObservable");
        // });
        // webVRController.onMenuButtonStateChangedObservable.add((state) => {
        //     console.re.log("DEBUG: onMenuButtonStateChangedObservable");
        // });
        webVRController.onPadValuesChangedObservable.add((state) => {
            // If it's not a press right in the middle, then save the y value for
            // moving foward/backward.
            /** @type {number} */
            padMoveSpeedFactor = state["y"];
            // Also save the x for turning. But here you can make people really
            // sick, so only trigger if on outer 4ths of pad (no accidents).
            /** @type {number} */
            padRotateSpeedFactor = state["x"];
            // First check if it's right in the middle. That's reset camera zone,
            // so cancel.
            if ((Math.abs(padRotateSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET) &&
                (Math.abs(padMoveSpeedFactor) < Vars.VR_CONTROLLER_PAD_RATIO_OF_MIDDLE_FOR_CAMERA_RESET)) {
                padMoveSpeedFactor = 0;
                padRotateSpeedFactor = 0;
                return;
            }
            // Unless you're pretty far to the left or right, don't count it.
            if (Math.abs(padRotateSpeedFactor) < 0.5) {
                padRotateSpeedFactor = 0.0;
            }
            else {
                // Scale the rotation speed factor
                padRotateSpeedFactor = padRotateSpeedFactor + ((padRotateSpeedFactor > 0) ? -0.5 : 0.5);
                padRotateSpeedFactor = 2.0 * padRotateSpeedFactor;
            }
        });
        // Check the pad state at every render and act accordingly.
        Vars.scene.registerBeforeRender(() => {
            if (padPressed) {
                moveCamera();
                rotateCamera();
            }
        });
    }
    /**
     * Moves the camera slightly forward. TODO: Shouldn't this be in
     * Navigation.ts?
     * @returns void
     */
    function moveCamera() {
        // No point in proceeding if you don't have a stare point.
        if (Points.curStarePt.equals(Points.pointWayOffScreen)) {
            return;
        }
        // Get the vector form the stare point to the camera. TODO: This is also
        // calculated elsewhere. Could put it in its own function or even cache it
        // for speed.
        let cameraPos = CommonCamera.getCameraPosition();
        let vecStarePtCamera = Points.curStarePt.subtract(cameraPos);
        vecStarePtCamera.normalize();
        let deltaVec = vecStarePtCamera.scale(padMoveSpeedFactor * Vars.PAD_MOVE_SPEED * Vars.scene.getAnimationRatio());
        // console.log(padMoveSpeedFactor, Vars.PAD_MOVE_SPEED, Vars.scene.getAnimationRatio(), deltaVec, vecStarePtCamera);
        CommonCamera.setCameraPosition(cameraPos.subtract(deltaVec));
    }
    /**
     * Rotates the VR camera slightly. TODO: Shouldn't this be in Navigation.ts?
     * @returns void
     */
    function rotateCamera() {
        if (padRotateSpeedFactor === 0) {
            // Why proceed if there is no rotation?
            return;
        }
        let nowTime = new Date().getTime();
        if (nowTime - lastPadRotationTime < Vars.VR_CONTROLLER_PAD_ROTATION_DELAY_TIME) {
            // Avoid rapid/continuous rotations. I tested this. It makes people
            // want to vomit.
            return;
        }
        lastPadRotationTime = nowTime;
        // Get the camera's current rotation.
        let curAngles = Vars.vrHelper.webVRCamera.rotationQuaternion.toEulerAngles();
        // Rotate it slightly about up axis.
        // curAngles.y += 0.1 * padRotateSpeedFactor * Vars.PAD_MOVE_SPEED * Vars.scene.getAnimationRatio();
        // curAngles.y = curAngles.y + Math.sign(padRotateSpeedFactor) * 0.0625 * Math.PI;
        // Rotates 45 degrees for rapid reorientation.
        curAngles.y = curAngles.y + Math.sign(padRotateSpeedFactor) * 0.25 * Math.PI;
        // Set camera to this new rotation.
        Vars.vrHelper.webVRCamera.rotationQuaternion = BABYLON.Quaternion.FromEulerVector(curAngles);
    }
});

// This module sets up the VR camera.
define('Cameras/VRCamera',["require", "exports", "../Navigation/Pickables", "../Scene/Optimizations", "../Vars", "./VRControllers"], function (require, exports, Pickables, Optimizations, Vars, VRControllers) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Sets up the VR camera.
     * @returns void
     */
    function setup() {
        // Setup different trigger VR functions (changes state, etc.)
        setupEnterAndExitVRCallbacks();
        VRControllers.setup();
    }
    exports.setup = setup;
    /**
     * Sets up the enter and exit VR functions. When enters, sets up VR. When
     * exists, downgrades to non-VR navigation.
     * @returns void
     */
    function setupEnterAndExitVRCallbacks() {
        Vars.vrHelper.onEnteringVRObservable.add((a, b) => {
            // When you enter VR. Not sure what a and b are. Both are objects.
            // Update navMode
            Vars.vrVars.navMode = 2 /* VRNoControllers */;
            // Setup teleportation. If uncommented, this is the one that comes
            // with BABYLON.js.
            // setupCannedVRTeleportation();
            setupGazeTracker();
            // Reset selected mesh.
            Pickables.setCurPickedMesh(undefined);
            // You need to recalculate the shadows. I've found you get back
            // shadows in VR otherwise.
            Optimizations.updateEnvironmentShadows();
            window["vrHelper"] = Vars.vrHelper;
        });
        // Vars.vrHelper.onAfterEnteringVRObservable.add(() => {
        //     // Make sure camera starts off at same location as babylon camera
        //     debugger;
        // });
        Vars.vrHelper.onExitingVRObservable.add(() => {
            // Update navMode
            Vars.vrVars.navMode = 3 /* NoVR */;
            // Reset selected mesh.
            Pickables.setCurPickedMesh(undefined);
            // Let's recalculate the shadows here again too, just to be on the
            // safe side.
            Optimizations.updateEnvironmentShadows();
        });
        // Vars.vrHelper.onNewMeshPicked.add((pickingInfo) => {
        //     // Callback receiving ray cast picking info
        //     Pickables.setCurPickedMesh(pickingInfo.pickedMesh);
        // });
        // Vars.vrHelper.onSelectedMeshUnselected.add((mesh) => {
        // Mesh has been unselected
        // Pickables.setCurPickedMesh(undefined);
        // Navigation.setCurStarePt(Navigation.pointWayOffScreen);
        // console.log(mesh, Pickables.curPickedMesh, Navigation.curStarePt);
        // console.log("GGGG");
        // });
    }
    /**
     * A placeholder mesh. Not technically empty, but pretty close.
     * @returns {*} The custom mesh (almost an empty).
     */
    function makeEmptyMesh() {
        /** @const {*} */
        const customMesh = new BABYLON.Mesh("vrNavTargetMesh", Vars.scene);
        /** @const {Array<number>} */
        const positions = [0, 0, 0];
        /** @const {Array<number>} */
        const indices = [0];
        /** @const {*} */
        const vertexData = new BABYLON.VertexData();
        vertexData.positions = positions;
        vertexData.indices = indices;
        vertexData.applyToMesh(customMesh);
        customMesh.isVisible = false;
        return customMesh;
    }
    /**
     * Sets up the VR gaze tracking mesh.
     * @returns void
     */
    function setupGazeTracker() {
        /**
         * @param {*}
         * @returns boolean
         */
        Vars.vrHelper.raySelectionPredicate = (mesh) => {
            // if (!mesh.isVisible) {
            //     return false;
            // }
            return Pickables.checkIfMeshPickable(mesh);
        };
        // Make an invisible mesh that will be positioned at location of gaze.
        Vars.vrHelper.gazeTrackerMesh = makeEmptyMesh();
        Vars.vrHelper.updateGazeTrackerScale = false; // Babylon 3.3 preview.
        Vars.vrHelper.displayGaze = true; // Does need to be true. Otherwise, position not updated.
        Vars.vrHelper.enableInteractions();
        // window.vrHelper = Vars.vrHelper;
    }
    exports.setupGazeTracker = setupGazeTracker;
});

define('UI/Menu3D/Button',["require", "exports", "../../Navigation/Pickables", "../../Vars", "./Menu3D"], function (require, exports, Pickables, Vars, Menu3D) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let btnScale = new BABYLON.Vector3(0.75, 0.75, 0.75);
    class ButtonWrapper {
        /**
         * The constructor.
         * @param  {Object<string,*>} params
         * @constructor
         */
        constructor(params) {
            // Make the button
            this.button = new BABYLON.GUI.HolographicButton(params.name);
            params.panel.addControl(this.button);
            // Make the possible materials (different colors).
            this.makeColorMats();
            // Change button color if appropriate.
            if (params.color !== undefined) {
                this.updateColor(params.color);
            }
            // Save the level.
            this.level = params.level;
            // Make a text block
            this.textBlock = new BABYLON.GUI.TextBlock();
            this.textBlock.color = "white";
            this.textBlock.resizeToFit = true;
            // Save the value and text, etc.
            this.value = params.default;
            this.trueTxt = params.trueTxt;
            this.falseTxt = params.falseTxt;
            this.clickFunc = params.clickFunc;
            // Update the text.
            this.updateTxt();
            this.button.scaling = btnScale.clone();
            // Make the button clickable. No. It is the sphere that will trigger this...
            // this.button.onPointerClickObservable.add((e) => {
            // this.toggled();
            // });
            // Make a mesh that surrounds the button. It actually triggers the
            // click.
            this.containingMesh = BABYLON.Mesh.CreateSphere(params.name + "-container-mesh", 2, Vars.BUTTON_SPHERE_RADIUS, Vars.scene);
            this.containingMesh.position = this.button.node.absolutePosition;
            this.containingMesh.visibility = 0;
            this.containingMesh.scaling = btnScale.clone();
            // Add a clicking function to the mesh.
            this.containingMesh.clickFunc = () => {
                this.toggled();
            };
            // Add the mesh to the list of ones that are pickable.
            Pickables.addPickableButton(this.containingMesh);
            if (params.initFunc !== undefined) {
                params.initFunc(this);
            }
        }
        /**
         * Updates the button color.
         * @param color string
         */
        updateColor(color) {
            switch (color) {
                case "default":
                    this.button.mesh.material = this.defaultMat;
                    break;
                case undefined: // Also default
                    this.button.mesh.material = this.defaultMat;
                    break;
                case "green":
                    this.button.mesh.material = this.greenMat;
                    break;
                case "yellow":
                    this.button.mesh.material = this.yellowMat;
                    break;
                case "red":
                    this.button.mesh.material = this.redMat;
                    break;
                default:
            }
        }
        /**
         * Determines if this button is visible.
         * @param  {boolean} [val=] Whether this button is visible.
         * @returns void
         */
        isVisible(val) {
            if (val === undefined) {
                // A getter
                return this.button.isVisible;
            }
            else {
                // A setter. Note that this doesn't affect visibility on meshes
                // (they could be entirely transparent).
                //     mesh.actionManager
                // .registerAction(
                // )
                this.button.isVisible = val;
                this.containingMesh.isVisible = val;
            }
        }
        /**
         * Toggle whether this button is visible.
         * @returns void
         */
        toggled() {
            // Play the sound.
            Menu3D.clickSound.setPosition(this.containingMesh.position.clone());
            Menu3D.clickSound.play();
            // Switch value.
            /** @type {boolean} */
            this.value = !this.value;
            // Fire the user-defined trigger.
            this.clickFunc(this);
            // Update the text.
            this.updateTxt();
        }
        /**
         * Sets the text on this button.
         * @param {string=} txt  The text to update. If undefined, gets it based
         *                       on the value, trueTxt, and falseTxt variables.
         * @returns void
         */
        updateTxt(txt) {
            if (txt === undefined) {
                this.textBlock.text = this.value ? this.trueTxt : this.falseTxt;
            }
            else {
                this.textBlock.text = txt;
                this.trueTxt = txt;
                this.falseTxt = txt;
            }
            this.textBlock.text = this.wrap(this.textBlock.text, 25);
            this.button.content.dispose();
            this.button.content = this.textBlock;
        }
        /**
         * Wrap the text to keep it from getting too long.
         * @param {stirng} s  The string to wrap.
         * @param {number} w  The width.
         * @returns {string} The wrapped text.
         */
        wrap(s, w) {
            return s.replace(new RegExp(`(?![^\\n]{1,${w}}$)([^\\n]{1,${w}})\\s`, "g"), "$1\n");
        }
        makeColorMats() {
            /** @const {number} */
            const colorDelta = 0.1;
            this.defaultMat = this.button.mesh.material;
            this.greenMat = this.button.mesh.material.clone();
            this.greenMat.albedoColor = new BABYLON.Color3(0.3, 0.35 + colorDelta, 0.4);
            this.yellowMat = this.button.mesh.material.clone();
            this.yellowMat.albedoColor = new BABYLON.Color3(0.3 + colorDelta, 0.35 + colorDelta, 0.4);
            this.redMat = this.button.mesh.material.clone();
            this.redMat.albedoColor = new BABYLON.Color3(0.3 + colorDelta, 0.35, 0.4);
        }
    }
    exports.ButtonWrapper = ButtonWrapper;
});

define('UI/OpenPopup',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let botstrapLoaded = false;
    /** @type {Function} */
    let modalFunc;
    /**
     * Opens a modal.
     * @param  {string} title  The tittle.
     * @param  {string} url    The URL.
     * @returns void
     */
    function openUrlModal(title, url) {
        // Load the css if needed.
        if (!botstrapLoaded) {
            botstrapLoaded = true;
            // Add the css
            document.head.insertAdjacentHTML("beforeend", "<link rel=stylesheet href=pages/css/bootstrap.min.css>");
            // Add the DOM for a modal
            document.body.insertAdjacentHTML("beforeend", `
            <!-- The Modal -->
            <div class="modal fade" id="myModal" role="dialog">
                <div class="modal-dialog" role="document">
                    <div class="modal-content">

                    <!-- Modal Header -->
                    <div class="modal-header">
                        <h4 class="modal-title">Modal Heading</h4>
                        <button type="button" class="close" data-dismiss="modal">&times;</button>
                    </div>

                    <!-- Modal body -->
                    <div class="modal-body">
                        <div class="embed-responsive embed-responsive-1by1">
                            <iframe class="embed-responsive-item" src=""></iframe>
                        </div>
                    </div>

                    <!-- Modal footer -->
                    <!-- <div class="modal-footer">
                        <button type="button" class="btn btn-primary" data-dismiss="modal">Close</button>
                    </div> -->
                </div>
            </div>
        `);
            // Add the javascript
            // jQuery.getScript( "pages/scripts/popper.min.js", ( data, textStatus, jqxhr ) => {
            jQuery.getScript("pages/scripts/bootstrap.min.js", (data, textStatus, jqxhr) => {
                modalFunc = jQuery.prototype.modal; // Save for later use.
                openUrlModalContinue(title, url);
            });
            // });
        }
        else {
            openUrlModalContinue(title, url);
        }
    }
    exports.openUrlModal = openUrlModal;
    /**
     * A follow-up function for opening the url modal.
     * @param  {string} title  The title.
     * @param  {string} url    The url.
     * @returns void
     */
    function openUrlModalContinue(title, url) {
        jQuery.prototype.modal = modalFunc;
        let myModal = jQuery("#myModal");
        myModal.find("h4.modal-title").html(title);
        myModal.find("iframe").attr("src", url);
        myModal.modal();
    }
});
// window["openUrlModal"] = openUrlModal;

// Functions common to all loaded molecules, regardless of source.
define('Mols/CommonLoader',["require", "exports", "../Navigation/Pickables", "../Scene/LoadAndSetup", "../Scene/Optimizations", "../Vars", "./Shadows"], function (require, exports, Pickables, LoadAndSetup, Optimizations, Vars, Shadows) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Run this before loading.
     * @returns void
     */
    function beforeLoading() {
        // Set up the shadow generator.
        Shadows.setupShadowGenerator();
        // Make UVs work
        BABYLON.OBJFileLoader.OPTIMIZE_WITH_UV = true;
    }
    exports.beforeLoading = beforeLoading;
    /**
     * @param  {Object<string,*>} sceneInfoData The data from scene_info.json.
     * @returns void
     */
    function afterLoading(sceneInfoData) {
        Shadows.setupShadowCatchers(); // Related to extras, so keep it here.
        // Do you need to make the ground glass instead of invisible? See
        // scene_info.json, which can have transparentGround: true.
        if ((sceneInfoData["transparentGround"] !== undefined) && (sceneInfoData["transparentGround"] === true)) {
            if (Vars.vrVars.groundMesh) {
                Vars.vrVars.groundMesh.visibility = 1;
                let transparentGround = new BABYLON.StandardMaterial("transparentGround", Vars.scene);
                transparentGround.diffuseColor = new BABYLON.Color3(1, 1, 1);
                transparentGround.specularColor = new BABYLON.Color3(0, 0, 0);
                transparentGround.emissiveColor = new BABYLON.Color3(0, 0, 0);
                transparentGround.alpha = Vars.TRANSPARENT_FLOOR_ALPHA;
                // transparentGround.ambientColor = new BABYLON.Color3(0.23, 0.98, 0.53);
                Vars.vrVars.groundMesh.material = transparentGround;
                // let glass = new BABYLON.PBRMaterial("glass", Vars.scene);
                // glass.reflectionTexture = hdrTexture;
                // glass.refractionTexture = hdrTexture;
                // glass.linkRefractionWithTransparency = true;
                // glass.indexOfRefraction = 0.52;
                // glass.alpha = 0; // Fully refractive material
                // Vars.vrVars.groundMesh.material = glass;
            }
            else {
                console.log("Warning: Vars.vrVars.groundMesh not defined.");
            }
        }
        // Finish up all scene preparations.
        LoadAndSetup.loadingAssetsDone();
    }
    exports.afterLoading = afterLoading;
    /**
     * Sets up a molecule mesh.
     * @param  {*}      mesh           The mesh.
     * @param  {string} objID          A string identifying this mesh.
     * @param  {*}      shadowQuality  The shadow quality. Like "Skip".
     * @param  {number} uniqIntID      A unique numerical id that identifies this
     *                                 mesh.
     * @returns void
     */
    function setupMesh(mesh, objID, shadowQuality, uniqIntID) {
        if ((mesh.material !== undefined) && (mesh.material !== null)) {
            // if (shadowQuality !== "Skip") {
            //     // So using shadows baked from blender.
            //     // Save the side orientation before removing mesh.
            //     let oldMatOrien = mesh.material.sideOrientation;
            //     // Remove existing material
            //     mesh.material.dispose();
            //     mesh.material = null;
            //     // Make sure not alpha blended.
            //     mesh.hasVertexAlpha = false;
            //     mesh.visibility = true;
            //     // Create new material
            //     let mat = new BABYLON.StandardMaterial("molMat" + uniqIntID.toString(), Vars.scene);
            //     mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
            //     mat.specularColor = new BABYLON.Color3(0, 0, 0);
            //     mat.opacityTexture = null;
            //     mat.sideOrientation = oldMatOrien;
            //     // mat.diffuseTexture.hasAlpha = false;
            //     let texName = objID + ".png";
            //     let tex = new BABYLON.Texture(  // lightmapTexture
            //         texName, Vars.scene,
            //     );
            //     tex.vScale = -1;
            //     mat.emissiveTexture = tex;
            //     mat.disableLighting = true;
            //     mat.sideOrientation = BABYLON.Material.ClockWiseSideOrientation;
            //     mat.backFaceCulling = false;
            //     // Add it to the mesh
            //     mesh.material = mat;
            //     // Freeze the material (improves optimization).
            //     Optimizations.freezeMeshProps(mesh);
            // } else {
            // Not using baked shadows. Add a small emission color so the dark
            // side of the protein isn't too dark.
            let lightingInf = Shadows.getBlurDarknessFromLightName();
            // Experience:
            // In Couch scene, background luminosity of 0.01 is good. There shadow darkness was 0.9625
            // In House scene, background luminosity of 0.0025 is good. There shadow darkness was 0.35.
            // Let's play around with a scheme for guessing at the right background luminosity.
            let backgroundLum = 0;
            /** @type {number} */
            let lightingInfDarkness = lightingInf.darkness;
            if (lightingInfDarkness > 0.95) {
                backgroundLum = 0.05;
            }
            else if (lightingInfDarkness < 0.4) {
                backgroundLum = 0.0025;
            }
            else {
                // Scaled
                // (0.95, 0.01)
                // (0.4, 0.0025)
                // let m = 0.013636363636363637;  // (0.01 - 0.0025) / (0.95 - 0.4);
                // let b = -0.0029545454545454545;  // 0.01 - 0.013636363636363637 * 0.95;
                backgroundLum = 0.013636363636363637 * lightingInfDarkness - 0.0029545454545454545;
            }
            // backgroundLum = 1;
            mesh.material.emissiveColor = new BABYLON.Color3(backgroundLum, backgroundLum, backgroundLum);
            // let ssao = new BABYLON.SSAORenderingPipeline("ssaopipeline", Vars.scene, 0.75);
            // Enable transparency (for fading in and out).
            // mesh.material.transparencyMode = BABYLON.PBRMaterial.PBRMATERIAL_ALPHABLEND;
            // Freeze the material (improves optimization).
            Optimizations.freezeMeshProps(mesh);
        }
        // }
        // This is required to position correctly.
        mesh.scaling.z = -1;
        if (uniqIntID > 0) {
            mesh.scaling.x = -1;
        }
        // Make it so it casts a shadow.
        if (Shadows.shadowGenerator) {
            Shadows.shadowGenerator.getShadowMap().renderList.push(mesh);
        }
        // Make it pickable
        Pickables.addPickableMolecule(mesh);
    }
    exports.setupMesh = setupMesh;
});

define('Mols/3DMol/VRMLParserWebWorker',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** @const {number} */
    const DATA_CHUNK_SIZE = 10000000;
    /** @type {Array<*>} */
    let dataToSendBack = [];
    let numRegex = new RegExp("(^|-| )[0-9\.]{1,8}", "g");
    let geoCenter = undefined;
    // Determine if we're in a webworker. See
    // https://stackoverflow.com/questions/7931182/reliably-detect-if-the-script-is-executing-in-a-web-worker
    let inWebWorker = false;
    if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
        inWebWorker = true;
    }
    // Get the data from the main thread, if webworker.
    if (inWebWorker) {
        self.onmessage = (e) => {
            /** @type {string} */
            let cmd = e.data["cmd"];
            let data = e.data["data"];
            /** @type {boolean} */
            let removeExtraPts = e.data["removeExtraPts"];
            if (cmd === "start") {
                // This will populate dataToSendBack
                loadValsFromVRML(data, removeExtraPts);
                cmd = "sendDataChunk";
            }
            if (cmd === "sendDataChunk") {
                let chunkToSend = dataToSendBack.shift();
                let status = (dataToSendBack.length === 0) ? "done" : "more";
                if (chunkToSend === undefined) {
                    // This happens if there's no mesh (i.e., ribbon on pure
                    // ligand).
                    status = "done";
                }
                postMessage({
                    "chunk": chunkToSend,
                    "status": status,
                });
            }
        };
    }
    /**
     * Load in values like coordinates and colors from the VRML string.
     * @param  {string}    vrmlStr         The string containing the VRML data.
     * @param  {boolean=}  removeExtraPts  Whether to remove extra points at the
     *                                     origin. Sticks representation from
     *                                     3DMoljs unfortunately generates these.
     *                                     They make it hard to center sticks-only
     *                                     representations.
     * @returns Array<Object<string, Array<number>>>   The model data.
     */
    function loadValsFromVRML(vrmlStr, removeExtraPts = false) {
        /** @type {Array<Objecet<string,*>>} */
        let modelData = [];
        // A given VRML file could have multiple IndexedFaceSets. Divide and
        // handle separately.
        let vrmlChunks = vrmlStr.split("geometry IndexedFaceSet {").splice(1);
        let vrmlChunksLen = vrmlChunks.length;
        for (let i = 0; i < vrmlChunksLen; i++) {
            let vrmlChunk = vrmlChunks[i];
            // Extract the coordinates from the vrml text
            let coors = strToCoors(betweenbookends("point [", "]", vrmlChunk));
            // Remove stray points (added to the origin) if necessary.
            if (removeExtraPts) {
                coors = removeStrayPoints(coors);
            }
            // Make sure string keys for closure compiler, since web worker is
            // external.
            modelData.push({
                "colors": strToColors(betweenbookends("color [", "]", vrmlChunk)),
                "coors": coors,
                "trisIdxs": strToTris(betweenbookends("coordIndex [", "]", vrmlChunk)),
            });
        }
        // Now that you've collected all the data, go back and translate all the
        // vertixes so Center the coordinates at the origin. Makes it easier to
        // pivot at geometric center.
        if (geoCenter === undefined) {
            geoCenter = getGeometricCenter(modelData);
        }
        modelData = translateBeforeBabylonImport(geoCenter, modelData);
        if (!inWebWorker) {
            return modelData;
        }
        else {
            // Now you need to chunk all the data. This is because you can only
            // transfer so much data back to the main thread at a time.
            dataToSendBack = [];
            let dataTypes = ["colors", "coors", "trisIdxs"];
            let dataTypesLen = dataTypes.length;
            /** @type {number} */
            let len = modelData.length;
            for (let modelIdx = 0; modelIdx < len; modelIdx++) {
                for (let i = 0; i < dataTypesLen; i++) {
                    /** @type {string} */
                    let dataType = dataTypes[i];
                    let chunks = chunk(modelData[modelIdx][dataType]);
                    let chunksLen = chunks.length;
                    for (let i2 = 0; i2 < chunksLen; i2++) {
                        let chunk = chunks[i2];
                        dataToSendBack.push([modelIdx, dataType, chunk]);
                    }
                }
            }
            return [];
        }
    }
    exports.loadValsFromVRML = loadValsFromVRML;
    /**
     * Fixes 0,0,0 points from the coordinates. 3DMoljs unfortunately adds these
     * to stick representations.
     * @param  {*} pts The coordinates. Float32Array.
     * @returns * Float32Array
     */
    function removeStrayPoints(pts) {
        console.log("Removing extra points.");
        /** @type {number} */
        let firstX = pts[0];
        /** @type {number} */
        let firstY = pts[1];
        /** @type {number} */
        let firstZ = pts[2];
        /** @type {number} */
        let coorsLen = pts.length;
        for (let coorIdx = 0; coorIdx < coorsLen; coorIdx = coorIdx + 3) {
            let idx2 = coorIdx + 1;
            let idx3 = coorIdx + 2;
            if ((pts[coorIdx] === 0) && (pts[idx2] === 0) && (pts[idx3] === 0)) {
                pts[coorIdx] = firstX;
                pts[idx2] = firstY;
                pts[idx3] = firstZ;
            }
        }
        return pts;
    }
    exports.removeStrayPoints = removeStrayPoints;
    /**
     * Divides an array into an array of arrays.
     * @param  {Array<*>} arr  The original array.
     * @returns {Array<Array<*>>}  The array of arrays.
     */
    function chunk(arr) {
        // See https://stackoverflow.com/questions/8495687/split-array-into-chunks
        let chunks = [];
        let i = 0;
        let n = arr.length;
        while (i < n) {
            chunks.push(arr.slice(i, i += DATA_CHUNK_SIZE));
        }
        return chunks;
    }
    /**
     * Converts coordinats in string format to list of numbers. Ordered per a
     * left-handed coordinate system.
     * @param  {string} str The coordinates in string format.
     * @returns * The list (actually a Float32Array... not sure how to type this.)
     */
    function strToCoors(str) {
        // Convert coordinates in string form to arrays.
        let coorStrs = str.match(numRegex);
        let coorLen = coorStrs.length;
        let coors = new Float32Array(coorLen);
        for (let i = 0; i < coorLen; i = i + 3) {
            // Note the order here. To convert to left-handed coor system. Note
            // also you must use array with push because you don't know ahead of
            // time how many coordinates there will be.
            coors[i] = +coorStrs[i + 2];
            coors[i + 1] = +coorStrs[i + 1];
            coors[i + 2] = +coorStrs[i];
        }
        // Now convert it to a typed array, which is much faster.
        return coors;
    }
    ;
    /**
     * Converts colors in string format to list of numbers. Similar to
     * strToCoors(), but for colors.
     * @param  {string} str The colors in string format.
     * @returns * The list (actually a Float32Array... not sure how to type this.)
     */
    function strToColors(str) {
        // Convert coordinates in string form to arrays.
        let colorStrs = str.match(numRegex);
        let colorStrsLen = colorStrs.length;
        let colors = new Float32Array(4 * colorStrsLen / 3);
        let colorLen = colors.length;
        for (let i = 0; i < colorLen; i = i + 4) {
            let i2 = 3 * i / 4;
            colors[i] = +colorStrs[i2];
            colors[i + 1] = +colorStrs[i2 + 1];
            colors[i + 2] = +colorStrs[i2 + 2];
            colors[i + 3] = 1.0;
        }
        // Now convert it to a typed array, which is much faster.
        return colors;
    }
    ;
    /**
     * Converts coordIndex in string format to list of numbers. Similar to
     * strToCoors(), but for indexes.
     * @param  {string} str The indexes in string format.
     * @returns * The list (actually a Uint32Array... not sure how to type this.)
     */
    function strToTris(str) {
        // Convert coordinates in string form to arrays.
        let indexStrs = str.match(numRegex);
        let indexStrsLen = indexStrs.length;
        let indexLen = 3 * indexStrsLen / 4;
        let indexes = new Uint32Array(indexLen);
        for (let i = 0; i < indexLen; i = i + 3) {
            let i2 = 4 * i / 3;
            indexes[i] = +indexStrs[i2];
            indexes[i + 1] = +indexStrs[i2 + 1];
            indexes[i + 2] = +indexStrs[i2 + 2];
        }
        return indexes;
    }
    ;
    /**
     * Gets the text betwen two strings.
     * @param  {string} bookend1 The first string.
     * @param  {string} bookend2 The second string.
     * @param  {string} str      The entire text to consider.
     * @returns string           The portion of str between bookend1 and bookend2.
     */
    function betweenbookends(bookend1, bookend2, str) {
        // Find the text between two bookends.
        let strArr = str.split(bookend1, 2);
        if (strArr.length <= 1) { // In case empty.
            return "";
        }
        strArr = strArr[1].split(bookend2, 2);
        let strBetween = strArr[0];
        return strBetween;
    }
    /**
     * Translate the coordinates before babylon import.
     * @param  {Array<number>}                         delta      The x, y, z to
     *                                                            translate.
     * @param  {Array<Object<string, Array<number>>>}  modelData  Information
     *                                                            about
     *                                                            coordinates,
     *                                                            colors, etc.
     * @returns Array<Object<string, Array<number>>>   Like model Data, but with
     *                                                 the coordinates translated.
     */
    function translateBeforeBabylonImport(delta, modelData) {
        let numModels = modelData.length;
        for (let modelIdx = 0; modelIdx < numModels; modelIdx++) {
            /** @type {number} */
            let coorsLen = modelData[modelIdx]["coors"].length;
            for (let coorIdx = 0; coorIdx < coorsLen; coorIdx = coorIdx + 3) {
                modelData[modelIdx]["coors"][coorIdx] = modelData[modelIdx]["coors"][coorIdx] - delta[0];
                modelData[modelIdx]["coors"][coorIdx + 1] = modelData[modelIdx]["coors"][coorIdx + 1] - delta[1];
                modelData[modelIdx]["coors"][coorIdx + 2] = modelData[modelIdx]["coors"][coorIdx + 2] - delta[2];
            }
        }
        return modelData;
    }
    /**
     * Calculate the geometric center of the coordinates.
     * @param  {Array<Object<string, Array<number>>>}  modelData  Information
     *                                                            about
     *                                                            coordinates,
     *                                                            colors, etc.
     * @returns * The x, y, z of the geometric center. Float32Array.
     */
    function getGeometricCenter(modelData) {
        // No coordinates... it's an empty mesh.
        if (modelData.length === 0) {
            return new Float32Array([0.0, 0.0, 0.0]);
        }
        /** @type {number} */
        let coorCountAllModels = modelData.map((m) => m["coors"].length).reduce((a, b) => a + b);
        if (coorCountAllModels === 0) {
            // No coordinates... it's an empty mesh.
            return new Float32Array([0.0, 0.0, 0.0]);
        }
        let xTotal = 0;
        let yTotal = 0;
        let zTotal = 0;
        let numModels = modelData.length;
        for (let modelIdx = 0; modelIdx < numModels; modelIdx++) {
            let modelDatum = modelData[modelIdx];
            let coors = modelDatum["coors"];
            /** @type {number} */
            let coorsLen = coors.length;
            for (let coorIdx = 0; coorIdx < coorsLen; coorIdx = coorIdx + 3) {
                xTotal = xTotal + coors[coorIdx];
                yTotal = yTotal + coors[coorIdx + 1];
                zTotal = zTotal + coors[coorIdx + 2];
            }
        }
        let numCoors = coorCountAllModels / 3.0;
        xTotal = xTotal / numCoors;
        yTotal = yTotal / numCoors;
        zTotal = zTotal / numCoors;
        return new Float32Array([xTotal, yTotal, zTotal]);
    }
});

// An module to manage VRML data obtained from 3Dmol.js. Assumes the 3Dmol.js
// javascript file is already loaded.
define('Mols/3DMol/VRML',["require", "exports", "../../UrlVars", "../../Vars", "../CommonLoader", "./PositionInScene", "./VRMLParserWebWorker"], function (require, exports, UrlVars, Vars, CommonLoader, PositionInScene, VRMLParserWebWorker) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /** @type {Array<Object<string,*>>} */
    let modelData = [];
    exports.molRotation = new BABYLON.Vector3(0, 0, 0);
    let element;
    /** @type {Object<string,string>} */
    let config;
    /** @type {string} */
    let vrmlStr;
    let vrmlParserWebWorker;
    let molTxt = "";
    let molTxtType = "pdb";
    let hasActiveSurface = false;
    /**
     * Setup the ability to work with 3Dmol.js.
     * @param  {Function} callBack  Runs once the iframe is loaded is loaded.
     * @returns void
     */
    function setup(callBack) {
        // Add a container for 3dmoljs.
        addDiv();
        // Make the viewer object.
        element = jQuery("#mol-container");
        config = { backgroundColor: "white" };
        exports.viewer = $3Dmol.createViewer(element, config);
        // jQuery("#mol-container canvas")["attr"]("style", extraStyle);
        window["viewer"] = exports.viewer; // For debugging.
        callBack();
    }
    exports.setup = setup;
    /**
     * Add (or readd) div 3DMoljs div.
     * @returns void
     */
    function addDiv() {
        let molContainer = jQuery("#mol-container");
        if (molContainer) {
            molContainer.remove();
        }
        let extraStyle = "display:none;";
        // let extraStyle = "width:150px; height:150px; z-index:150; position:fixed; top:0; left:0;";
        jQuery("body").append(`<div
        id="mol-container"
        class="mol-container"
        style="${extraStyle}"></div>`);
    }
    function resetAll() {
        if (hasActiveSurface) {
            hasActiveSurface = false;
            // I can't get rid of the surfaces without causing
            // problems. I'm just going to go nuclear and reload the
            // whole thing.
            exports.viewer = null;
            setup(() => {
                exports.viewer.addModel(molTxt, "pdb");
            });
        }
        exports.viewer.setStyle({}, {});
    }
    exports.resetAll = resetAll;
    /**
     * Load a file into the 3dmol object.
     * @param  {string}     url     The url.
     * @param  {Function} callBack  A callback function. The 3DMoljs molecule
     *                              object is the parameter.
     * @returns void
     */
    function loadPDBURL(url, callBack) {
        jQuery.ajax(url, {
            /**
             * When the url data is retrieved.
             * @param  {string} data  The remote data.
             * @returns void
             */
            "success": (data) => {
                // Setup the visualization
                /** @type {string} */
                molTxt = data; // In case you need to restart.
                molTxtType = "pdb";
                if (url.slice(url.length - 3).toLowerCase() === "sdf") {
                    molTxtType = "sdf";
                }
                let mdl = exports.viewer.addModel(data, molTxtType);
                // viewer.zoomTo();
                // render();  // Use default style.
                // viewer.render();
                callBack(mdl);
            },
            /**
             * If there's an error...
             * @param  {*}       hdr
             * @param  {*}       status
             * @param  {string}  err
             */
            "error": (hdr, status, err) => {
                console.error("Failed to load molecule " + url + ": " + err);
            },
        });
    }
    exports.loadPDBURL = loadPDBURL;
    /**
     * Set the style on the 3DMoljs viewer.
     * @param  {Object<string,*>} sels  A selection object.
     * @param  {Object<string,*>} rep   A representation object.
     * @returns void
     */
    function setStyle(sels, rep) {
        // If the selection looks like {"and":[{}, {...}]}, simplify it.
        if ((sels["and"] !== undefined) && // "and" is a key
            (Object.keys(sels).length === 1) && // it is the only key
            (JSON.stringify(sels["and"][0]) === "{}") && // it points to a list with {} as first item.
            (sels["and"].length === 2)) { // that list has only to elements
            sels = sels["and"][1];
        }
        exports.viewer.setStyle(sels, rep);
        exports.viewer.render();
    }
    exports.setStyle = setStyle;
    /**
     * Add a surface to the 3DMoljs viewer.
     * @param  {Object<string,*>} colorScheme  A colorscheme object.
     * @param  {Object<string,*>} sels         A selection object.
     * @param  {Function}         callBack     A callback function.
     * @returns void
     */
    function addSurface(colorScheme, sels, callBack) {
        hasActiveSurface = true;
        exports.viewer.addSurface($3Dmol.SurfaceType.MS, colorScheme, sels, undefined, undefined, () => {
            callBack();
        });
    }
    exports.addSurface = addSurface;
    /**
     * Sets the 3dmol.js style. Also generates a vrml string and values.
     * @param  {boolean}    updateData  Whether to update the underlying data with
     *                                  this visualization. True by default.
     * @param  {string}     repName     The representative name. Like "Surface".
     * @param  {Function=}  callBack    The callback function, with the new mesh
     *                                  as a parameter.
     * @returns void
     */
    function render(updateData, repName, callBack = () => { return; }) {
        // Make sure there are no waiting menus up and running. Happens some
        // times.
        Vars.engine.hideLoadingUI();
        // Render the style
        // viewer.render();
        if (updateData) {
            // Load the data.
            loadVRMLFrom3DMol(() => {
                loadValsFromVRML(repName, () => {
                    // Could modify coordinates before importing into babylon
                    // scene, so comment out below. Changed my mind the kinds of
                    // manipulations above should be performed on the mesh.
                    // Babylon is going to have better functions for this than I
                    // can come up with.
                    let newMesh = importIntoBabylonScene();
                    if (newMesh !== undefined) {
                        // It's undefined if, for example, trying to do cartoon on
                        // ligand.
                        PositionInScene.positionAll3DMolMeshInsideAnother(newMesh, Vars.scene.getMeshByName("protein_box"));
                        callBack(newMesh); // Cloned so it won't change with new rep in future.
                    }
                    // Clean up.
                    modelData = [];
                });
            });
        }
    }
    exports.render = render;
    /**
     * Loads the VRML string from the 3Dmol instance.
     * @param  {Function=}  callBack    The callback function.
     * @returns void
     */
    function loadVRMLFrom3DMol(callBack) {
        // Make the VRML string from that model.
        /** @type {string} */
        vrmlStr = exports.viewer.exportVRML();
        callBack();
    }
    /**
     * Load in values like coordinates and colors from the VRML string.
     * @param  {string}    repName   The representative name. Like "Surface".
     * @param  {Function}  callBack  A callback function.
     * @returns void
     */
    function loadValsFromVRML(repName, callBack) {
        // Clear previous model data.
        modelData = [];
        if (typeof (Worker) !== "undefined") {
            if (typeof (vrmlParserWebWorker) === "undefined") {
                vrmlParserWebWorker = new Worker("VRMLParserWebWorker.js");
            }
            vrmlParserWebWorker.onmessage = (event) => {
                // Msg back from web worker
                /** @type {Object<string,*>} */
                let resp = event.data;
                let chunk = resp["chunk"];
                /** @type {string} */
                let status = resp["status"];
                if (chunk !== undefined) {
                    /** @type {number} */
                    let modelIdx = chunk[0];
                    /** @type {string} */
                    let dataType = chunk[1];
                    let vals = chunk[2];
                    if (modelData.length === modelIdx) {
                        modelData.push({
                            "coors": new Float32Array(0),
                            "colors": new Float32Array(0),
                            "trisIdxs": new Uint32Array(0),
                        });
                    }
                    modelData[modelIdx][dataType] = typedArrayConcat(dataType === "trisIdxs" ? Uint32Array : Float32Array, [modelData[modelIdx][dataType], vals]);
                }
                switch (status) {
                    case "more":
                        // There's more data. Request it now.
                        vrmlParserWebWorker.postMessage({
                            "cmd": "sendDataChunk",
                            "data": undefined,
                        });
                        break;
                    case "done":
                        // No more data. Run the callback.
                        // console.log(modelData);
                        callBack();
                        break;
                    default:
                        console.log("Error here!");
                }
            };
            // Send message to web worker.
            vrmlParserWebWorker.postMessage({
                "cmd": "start",
                "data": vrmlStr,
                "removeExtraPts": (repName === "Stick"),
            });
        }
        else {
            // Sorry! No Web Worker support..
            modelData = VRMLParserWebWorker.loadValsFromVRML(vrmlStr);
            callBack();
        }
    }
    /**
     * Concatonates a list of typed arrays.
     * @param  {*}        resultConstructor  The type of array. E.g., Uint8Array.
     * @param  {Array<*>} listOfArrays       A list of typed arrays to
     *                                       concatonate.
     * @returns {*} The typed array.
     */
    function typedArrayConcat(resultConstructor, listOfArrays) {
        // See http://2ality.com/2015/10/concatenating-typed-arrays.html
        let totalLength = 0;
        /** @type {number} */
        let listOfArraysLen = listOfArrays.length;
        for (let i = 0; i < listOfArraysLen; i++) {
            /** @type {Array<*>} */
            let arr = listOfArrays[i];
            totalLength += arr.length;
        }
        let result = new resultConstructor(totalLength);
        let offset = 0;
        for (let i = 0; i < listOfArraysLen; i++) {
            /** @type {Array<*>} */
            let arr = listOfArrays[i];
            result.set(arr, offset);
            offset += arr.length;
        }
        return result;
    }
    /**
     * Creates a babylonjs object from the values and adds it to the babylonjs
     * scene.
     * @returns {*} The new mesh from the 3dmoljs instance.
     */
    function importIntoBabylonScene() {
        // The material to add to all meshes.
        let mat = new BABYLON.StandardMaterial("Material", Vars.scene);
        mat.diffuseColor = new BABYLON.Color3(1, 1, 1);
        mat.emissiveColor = new BABYLON.Color3(0, 0, 0);
        mat.specularColor = new BABYLON.Color3(0, 0, 0);
        // mat.sideOrientation = BABYLON.Mesh.FRONTSIDE;
        // mat.sideOrientation = BABYLON.Mesh.BACKSIDE;
        let meshes = [];
        /** @type {number} */
        let len = modelData.length;
        for (let modelIdx = 0; modelIdx < len; modelIdx++) {
            let modelDatum = modelData[modelIdx];
            // Calculate normals instead? It's not necessary. Doesn't chang over
            // 3dmoljs calculated normals.
            let norms = [];
            BABYLON.VertexData.ComputeNormals(modelDatum["coors"], modelDatum["trisIdxs"], norms);
            // Compile all that into vertex data.
            let vertexData = new BABYLON.VertexData();
            vertexData["positions"] = modelDatum["coors"]; // In quotes because from webworker (external)
            vertexData["indices"] = modelDatum["trisIdxs"];
            vertexData["normals"] = norms;
            vertexData["colors"] = modelDatum["colors"];
            // Delete the old mesh if it exists.
            // if (Vars.scene.getMeshByName("MeshFrom3DMol") !== null) {
            //     Vars.scene.getMeshByName("MeshFrom3DMol").dispose();
            // }
            // Make the new mesh
            let babylonMeshTmp = new BABYLON.Mesh("mesh_3dmol_tmp" + modelIdx, Vars.scene);
            vertexData.applyToMesh(babylonMeshTmp);
            // Add a material.
            babylonMeshTmp.material = mat;
            // babylonMeshTmp.showBoundingBox = true;
            meshes.push(babylonMeshTmp);
        }
        let babylonMesh;
        if (meshes.length > 0) {
            // Merge all these meshes.
            // https://doc.babylonjs.com/how_to/how_to_merge_meshes
            babylonMesh = BABYLON.Mesh.MergeMeshes(meshes, true, true); // dispose of source and allow 32 bit integers.
            // babylonMesh = meshes[0];
            babylonMesh.name = "MeshFrom3DMol" + Math.random().toString();
            babylonMesh.id = babylonMesh.name;
            // Work here
            CommonLoader.setupMesh(babylonMesh, babylonMesh.name, "Skip", 123456789);
        }
        return babylonMesh;
    }
    exports.importIntoBabylonScene = importIntoBabylonScene;
    /**
     * Rotate the molecular meshes.
     * @param  {string} axis    The axis. "x", "y", or "z".
     * @param  {number} amount  The amount. In radians, I think.
     * @returns void
     */
    function updateMolRotation(axis, amount) {
        exports.molRotation[axis] += amount;
        // Update URL too.
        UrlVars.setURL();
    }
    exports.updateMolRotation = updateMolRotation;
    /**
     * Sets the molRotation object externally. Does not actually rotate anything.
     * @param  {number} x
     * @param  {number} y
     * @param  {number} z
     * @returns void
     */
    function setMolRotation(x, y, z) {
        exports.molRotation = new BABYLON.Vector3(x, y, z);
    }
    exports.setMolRotation = setMolRotation;
});

define('WebRTC/WebRTCBase',["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class WebRTCBase {
        constructor() {
            // Some functions are common to both senders and receivers.
            this.peerId = null;
            this.peer = null;
            this.createPeerObj();
            this.setupWebRTCCloseFuncs();
        }
        createPeerObj() {
            // Create own peer object with connection to shared PeerJS server
            this.peer = new Peer(null, {
                debug: 2,
            });
        }
        setupWebRTCCloseFuncs() {
            this.peer.on("disconnected", () => {
                console.log("Connection lost. Please reconnect");
                // Workaround for peer.reconnect deleting previous id
                this.peer.id = this.peerId;
                this.peer._lastServerId = this.peerId;
                this.peer.reconnect();
            });
            this.peer.on("error", (err) => {
                console.log(err);
            });
        }
    }
    exports.WebRTCBase = WebRTCBase;
});

define('WebRTC/Student',["require", "exports", "../Cameras/CommonCamera", "./WebRTCBase", "../Vars"], function (require, exports, CommonCamera, WebRTCBase, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Student extends WebRTCBase.WebRTCBase {
        constructor(dataReceivedFunc) {
            super();
            this.conn = null; // The connection (just one).
            this.dataReceivedFunc = dataReceivedFunc;
            this.setupWebRTCCallbacks();
        }
        joinExistingSession(id) {
            // Close old connection
            if (this.conn) {
                this.conn.close();
            }
            // Create connection to destination peer specified in the input field
            this.conn = this.peer.connect(id, {
                reliable: true,
            });
            this.setConnectionCallbacks();
            this.conn.on("open", () => {
                console.log("Connected to: " + this.conn.peer);
            });
        }
        setupWebRTCCallbacks() {
            this.peer.on("close", () => {
                this.conn = null;
                console.log("Connection destroyed. Please refresh");
            });
        }
        setConnectionCallbacks() {
            // Handle incoming data (messages only since this is the signal
            // sender)
            this.conn.on("data", (data) => {
                this.dataReceivedFunc(data);
            });
            this.conn.on("close", () => {
                console.log("Connection closed");
            });
        }
    }
    exports.Student = Student;
    let stud;
    let targetCameraPosition = null;
    let targetCameraRotationQuaternion = null;
    function startFollowing(id) {
        targetCameraPosition = new Float32Array(CommonCamera.getCameraPosition().asArray());
        targetCameraRotationQuaternion = new Float32Array(CommonCamera.getCameraRotationQuaternion().asArray());
        let stud = new Student((data) => {
            console.log("stud1 got data", data);
            let type = data["type"];
            let val = data["val"];
            switch (type) {
                case "locrot":
                    targetCameraPosition = new Float32Array([val[0], val[1], val[2]]);
                    targetCameraRotationQuaternion = new Float32Array([val[3], val[4], val[5], val[6]]);
                    // CommonCamera.setCameraPosition(
                    //     new BABYLON.Vector3(val[0], val[1], val[2]),
                    // );
                    // CommonCamera.setCameraRotationQuaternion(
                    // new BABYLON.Quaternion(val[3], val[4], val[5], val[6]),
                    // );
                    break;
                default:
                    break;
            }
        });
        stud.joinExistingSession(id);
        // Start moving the camera in sync
        Vars.scene.registerBeforeRender(() => {
            let cameraLoc = new Float32Array(CommonCamera.getCameraPosition().asArray());
            let newPos = moveVecTowards(cameraLoc, targetCameraPosition, 2.0);
            let newPosAsVec = BABYLON.Vector3.FromArray(newPos);
            CommonCamera.setCameraPosition(newPosAsVec);
            let cameraRotQuat = new Float32Array(CommonCamera.getCameraRotationQuaternion().asArray());
            let newRot = moveVecTowards(cameraRotQuat, targetCameraRotationQuaternion, 0.261799 // 15 degrees
            );
            let newRotAsVec = BABYLON.Quaternion.FromArray(newRot);
            CommonCamera.setCameraRotationQuaternion(newRotAsVec);
            // CommonCamera.setCameraPosition(
            //     moveVecTowards(
            //         CommonCamera.getCameraPosition(),
            //         targetCameraPosition,
            //         0.05, 0.1
            //     )
            // );
        });
    }
    exports.startFollowing = startFollowing;
    function moveVecTowards(curVec, targetVec, closeVal) {
        let numEntries = curVec.length;
        // Now get the distance between curVec and this newPos.
        let deltaPos = new Float32Array(numEntries);
        for (let i = 0; i < numEntries; i++) {
            deltaPos[i] = targetVec[i] - curVec[i];
        }
        let fac = 0.02;
        let animRatio = Vars.scene.getAnimationRatio();
        // A variable that will contain the new position
        let newPos = new Float32Array(numEntries);
        // Scale the delta and add it to the curVec. That's the newPos.
        for (let i = 0; i < numEntries; i++) {
            newPos[i] = curVec[i] + animRatio * fac * deltaPos[i];
        }
        return newPos;
    }
    function moveVecTowardsOld2(curVec, targetVec, closeVal) {
        let numEntries = curVec.length;
        // A variable taht will contain the new position
        let newPos = new Float32Array(numEntries);
        // Now get the distance between curVec and this newPos.
        let deltaPos = new Float32Array(numEntries);
        for (let i = 0; i < numEntries; i++) {
            deltaPos[i] = targetVec[i] - curVec[i];
        }
        // Get the length of that vector (current to newPos/midpoint).
        let lenVec = 0;
        for (let i = 0; i < numEntries; i++) {
            lenVec += deltaPos[i] * deltaPos[i];
        }
        lenVec = Math.sqrt(lenVec);
        // Move faster when far away.
        let animRatio = Vars.scene.getAnimationRatio();
        let speed = animRatio * 0.98; // Fast
        if (lenVec < closeVal) {
            // Slow when you get faster.
            speed = 0.99;
        }
        // Start by guessing that the new point is half way between here and the
        // target.
        let speed2 = animRatio - speed;
        for (let i = 0; i < numEntries; i++) {
            newPos[i] = speed * curVec[i] + speed2 * targetVec[i];
        }
        // if (lenVec === 0) {
        //     // Already there. So skip.
        //     return curVec;
        // }
        // if (lenVec > closeDist) {
        //     // Too far away... it would be too big a jump. Move towards thew
        //     // target just a bit.
        //     let animRatio = Vars.scene.getAnimationRatio();
        //     for (let i = 0; i < numEntries; i++) {
        //         newPos[i] = curVec[i] + speed * animRatio * deltaPos[i] / lenVec;
        //     }
        // }
        return newPos;
    }
    function moveVecTowardsOld(curVec, targetVec, speed, closeDist) {
        let numEntries = curVec.length;
        let deltaPos = new Float32Array(numEntries);
        for (let i = 0; i < numEntries; i++) {
            deltaPos[i] = targetVec[i] - curVec[i];
        }
        let lenVec = 0;
        for (let i = 0; i < numEntries; i++) {
            lenVec += deltaPos[i] * deltaPos[i];
        }
        lenVec = Math.sqrt(lenVec);
        if (lenVec === 0) {
            return curVec;
        }
        if (lenVec < closeDist) {
            // You're so close. Just set it to the final position.
            return targetVec;
        }
        // Move towards thew target just a bit.
        let newPos = new Float32Array(numEntries);
        let animRatio = Vars.scene.getAnimationRatio();
        for (let i = 0; i < numEntries; i++) {
            newPos[i] = curVec[i] + speed * animRatio * deltaPos[i] / lenVec;
        }
        return newPos;
    }
});

define('UrlVars',["require", "exports", "./Mols/3DMol/ThreeDMol", "./Mols/3DMol/Visualize", "./Mols/3DMol/VRML", "./WebRTC/Student"], function (require, exports, ThreeDMol, Visualize, VRML, Student) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let stylesQueue = [];
    let webrtc;
    /**
     * Get all the url parameters from a url string.
     * @param  {string} url  The url srtring.
     * @returns Object<string,*> The parameters.
     */
    function getAllUrlParams(url) {
        // Adapted from
        // https://www.sitepoint.com/get-url-parameters-with-javascript/
        // get query string from url (optional) or window
        let queryString = url ? url.split("?")[1] : window.location.search.slice(1);
        // we'll store the parameters here
        let obj = {};
        // if query string exists
        if (queryString) {
            // stuff after # is not part of query string, so get rid of it
            queryString = queryString.split("#")[0];
            // split our query string into its component parts
            let arr = queryString.split("&");
            let arrLen = arr.length;
            for (let i = 0; i < arrLen; i++) {
                let a = arr[i];
                // separate the keys and the values
                let keyValPair = a.split("=");
                // set parameter name and value (use 'true' if empty)
                let paramName = keyValPair[0];
                let paramValue = (keyValPair[1] === undefined) ? true : keyValPair[1];
                obj[paramName] = paramValue;
            }
        }
        return obj;
    }
    /**
     * Round a number and represent it as a string.
     * @param  {number} x  The number.
     * @returns string The rounded string.
     */
    function round(x) {
        return (Math.round(100000 * x) / 100000).toString();
    }
    /**
     * Set the browser url to reflect the latest styles and rotations.
     * @returns void
     */
    function setURL() {
        let params = [];
        // Get the rotations.
        /** @type {number} */
        let x = VRML.molRotation.x;
        if (x !== 0) {
            params.push("x=" + round(x));
        }
        /** @type {number} */
        let y = VRML.molRotation.y;
        if (y !== 0) {
            params.push("y=" + round(y));
        }
        /** @type {number} */
        let z = VRML.molRotation.z;
        if (z !== 0) {
            params.push("z=" + round(z));
        }
        // Set the url.
        params.push("src=" + ThreeDMol.modelUrl);
        if (webrtc !== undefined) {
            params.push("webrtc=" + webrtc);
        }
        // Also get all the representations
        let i = 0;
        let styles = [];
        let keys = Object.keys(Visualize.styleMeshes);
        let len = keys.length;
        for (let i2 = 0; i2 < len; i2++) {
            let key = keys[i2];
            if (Visualize.styleMeshes[key].mesh.isVisible) {
                styles.push("style" + i.toString() + "=" + key);
                i++;
            }
        }
        // styles.reverse();  // order doens't matter anyway.
        params = params.concat(styles);
        // Update URL
        window.history.pushState({
        // "html": response.html,
        // "pageTitle": response.pageTitle,
        }, document.title, window.location.href.split("?")[0] + "?" + params.join("&"));
    }
    exports.setURL = setURL;
    /**
     * Gets info from the url parameters and saves/applies it, as appropriate.
     * Note that this gets what molecular styles need to be applied, but does not
     * apply them.
     * @returns void
     */
    function readUrlParams() {
        let params = getAllUrlParams(window.location.href);
        // Before anything, check if this is a webrtc session.
        webrtc = params["webrtc"];
        if (webrtc !== undefined) {
            Student.startFollowing(webrtc);
        }
        // Update the mesh rotations
        /** @type {number} */
        let x = params["x"];
        /** @type {number} */
        let y = params["y"];
        /** @type {number} */
        let z = params["z"];
        x = (x === undefined) ? 0 : +x;
        y = (y === undefined) ? 0 : +y;
        z = (z === undefined) ? 0 : +z;
        VRML.setMolRotation(x, y, z);
        // Set the url if it's present.
        /** @type {string} */
        let src = params["src"];
        if (src !== undefined) {
            if ((src.length === 4) && (src.indexOf(".") === -1)) {
                // Assume it's a pdb id
                src = "https://files.rcsb.org/view/" + src.toUpperCase() + ".pdb";
            }
            ThreeDMol.setModelUrl(src);
        }
        // Setup the styles as well.
        /** @type {Array<string>} */
        let keys = Object.keys(params);
        let len = keys.length;
        for (let i = 0; i < len; i++) {
            let key = keys[i];
            if (key.slice(0, 5) === "style") {
                let repInfo = extractRepInfoFromKey(params[key]);
                stylesQueue.push(repInfo);
            }
        }
        // If stylesQueue has nothing in it, set up a default rep.
        if (stylesQueue.length === 0) {
            stylesQueue.push([["Protein", "All"], "Cartoon", "Spectrum"]);
            stylesQueue.push([["Ligand", "All"], "Stick", "Element"]);
        }
        // stylesQueue.reverse();  // order doens't matter anyway.
    }
    exports.readUrlParams = readUrlParams;
    /**
     * Takes a string like All--Ligand--Stick--Element and converts it to [["All",
     * "Ligand"], "Stick", "Element"].
     * @param  {string} key The srting.
     * @returns Array<*>
     */
    function extractRepInfoFromKey(key) {
        let prts = key.split("--");
        let rep = decodeURIComponent(prts[prts.length - 2]);
        let colorScheme = decodeURIComponent(prts[prts.length - 1]);
        let sels = prts.slice(0, prts.length - 2).map((i) => {
            i = decodeURIComponent(i);
            if (i.slice(0, 1) === "{") {
                i = JSON.parse(i);
            }
            return i;
        });
        return [sels, rep, colorScheme];
    }
    exports.extractRepInfoFromKey = extractRepInfoFromKey;
    /**
     * Start loading all the molecular styles described in the url. A recursive
     * function.
     * @returns void
     */
    function startLoadingStyles() {
        if (stylesQueue.length > 0) {
            // There are some styles to still run.
            let style = stylesQueue.pop();
            Visualize.toggleRep(style[0], style[1], style[2], () => {
                // Try to get the next style.
                startLoadingStyles();
            });
        }
    }
    exports.startLoadingStyles = startLoadingStyles;
});

// Functions from loading molecules directly from a 3Dmol.js instance. See
// VRML.ts for additional functions related to the mesh itself.
define('Mols/3DMol/ThreeDMol',["require", "exports", "../../UI/Menu3D/Menu3D", "../../UI/Menu3D/Styles", "../../UI/OpenPopup", "../../UrlVars", "../CommonLoader", "./VRML"], function (require, exports, Menu3D, Styles, OpenPopup, UrlVars, CommonLoader, VRML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.atomicInfo = {};
    exports.modelUrl = "nanokid.sdf";
    /**
     * Setter for modelUrl.
     * @param  {string} url The new value.
     * @returns void
     */
    function setModelUrl(url) { exports.modelUrl = url; }
    exports.setModelUrl = setModelUrl;
    /**
     * Load in the extra molecule meshes.
     * @param  {Object<string,*>} sceneInfoData The data from scene_info.json.
     * @returns void
     */
    function setup(sceneInfoData) {
        // Load the 3DMoljs iframe.
        try {
            jQuery.getScript(
            // "https://3Dmol.csb.pitt.edu/build/3Dmol-min.js",
            "https://3Dmol.csb.pitt.edu/build/3Dmol.js", (data, textStatus, jqxhr) => {
                after3DMolJsLoaded(sceneInfoData);
            });
        }
        catch (err) {
            after3DMolJsLoaded(sceneInfoData);
        }
    }
    exports.setup = setup;
    /**
     * Runs after the 3Dmol.js library is loaded.
     * @param  {Object<string,*>} sceneInfoData The data from scene_info.json.
     * @returns void
     */
    function after3DMolJsLoaded(sceneInfoData) {
        VRML.setup(() => {
            UrlVars.readUrlParams();
            // let pdbUri = "https://files.rcsb.org/view/1XDN.pdb";
            VRML.loadPDBURL(exports.modelUrl, (mdl3DMol) => {
                // Update URL with location
                UrlVars.setURL();
                // Get additional selection information about the loaded molecule.
                // Like residue name.
                getAdditionalSels(mdl3DMol);
                // Now that the pdb is loaded, you need to update the menu.
                Styles.updateModelSpecificSelectionsInMenu(Menu3D.menuInf);
                // Now that the PDB is loaded, you can start loading styles.
                UrlVars.startLoadingStyles();
                // Show protein ribbon by default.
                // Visualize.toggleRep(["Protein", "All"], "Cartoon", "Spectrum");
                // Continue...
                CommonLoader.afterLoading(sceneInfoData);
                // If it's nanokid, open a popup to let them specify a url or
                // pdbid.
                if (exports.modelUrl === "nanokid.sdf") {
                    setTimeout(() => {
                        // Give them some time to admire nanokid... :)
                        OpenPopup.openUrlModal("Load Molecule", "pages/load.html");
                    }, 3000);
                }
            });
        });
    }
    /**
     * Generates additional possible selections from the properties of the atoms
     * themselves (like residue names).
     * @param  {*} mdl3DMol  A 3dmoljs molecule object.
     * @returns void
     */
    function getAdditionalSels(mdl3DMol) {
        // Get all the atoms.
        /** @type {Array<Object<string,*>>} */
        let atoms = mdl3DMol.selectedAtoms({});
        exports.atomicInfo = {
            "Atom Name": [],
            "Chain": [],
            "Element": [],
            "Residue Index": [],
            "Residue Name": [],
            "Secondary Structure": [],
        };
        /** @type {number} */
        let atomsLen = atoms.length;
        for (let i = 0; i < atomsLen; i++) {
            /** @type {Object<string,*>} */
            let atom = atoms[i];
            exports.atomicInfo["Atom Name"].push(atom["atom"]);
            exports.atomicInfo["Chain"].push(atom["chain"]);
            exports.atomicInfo["Element"].push(atom["elem"]);
            exports.atomicInfo["Residue Name"].push(atom["resn"]);
            exports.atomicInfo["Residue Index"].push(atom["resi"]);
            exports.atomicInfo["Secondary Structure"].push(atom["ss"]);
        }
        // We want just unique values.
        let lbls = Object.keys(exports.atomicInfo);
        let len = lbls.length;
        for (let i = 0; i < len; i++) {
            let lbl = lbls[i];
            exports.atomicInfo[lbl] = uniq(exports.atomicInfo[lbl]);
        }
    }
    /**
     * Get the unique values in an array.
     * @param  {Array<*>} arr  The array
     * @returns Array<*>  The array, with unique values.
     */
    function uniq(arr) {
        // see
        // https://stackoverflow.com/questions/11688692/how-to-create-a-list-of-unique-items-in-javascript
        let u = {};
        let a = [];
        /** @type {number} */
        let len = arr.length;
        for (let i = 0, l = len; i < l; ++i) {
            if (!u.hasOwnProperty(arr[i])) {
                a.push(arr[i]);
                u[arr[i]] = 1;
            }
        }
        return a;
    }
});

define('UI/Menu3D/Styles',["require", "exports", "../../Mols/3DMol/ThreeDMol", "../../Mols/3DMol/Visualize", "../../UrlVars", "./Menu3D"], function (require, exports, ThreeDMol, Visualize, UrlVars, Menu3D) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // Define all the possible components.
    let components = ["Protein", "Ligand", "Ligand Context", "Water", "Nucleic"];
    // For each of those components, get the possible selections.
    let selections = {
        "Ligand": ["All"],
        "Ligand Context": ["All"],
        "Nucleic": ["All"],
        "Protein": [
            "All", "Hydrophobic", "Hydrophilic", "Charged", "Aromatic",
        ],
        "Water": ["All"],
    };
    // For each of those components, specify the associated representations.
    let commonReps = ["Stick", "Sphere", "Surface"];
    let representations = {
        "Ligand": commonReps,
        "Ligand Context": ["Cartoon"].concat(commonReps),
        "Nucleic": commonReps,
        "Protein": ["Cartoon"].concat(commonReps),
        "Water": commonReps,
    };
    // You'll need to modify colorSchemeKeyWordTo3DMol in Visualize.ts too.
    let colors = [
        "White", "Red", "Blue", "Green", "Orange", "Yellow", "Purple",
    ];
    let colorSchemes = [
        "Element", "Amino Acid", "Chain", "Nucleic", "Spectrum",
    ];
    /**
     * Makes submenus required for the various style options (reps, colors, etc.).
     * @returns Object
     */
    function buildStylesSubMenu() {
        let menu = {
            "Components": {},
            "Selections": {},
            "Clear": () => {
                let fullKeys = Object.keys(Visualize.styleMeshes);
                let len = fullKeys.length;
                for (let i = 0; i < len; i++) {
                    let fullKey = fullKeys[i];
                    let styleMesh = Visualize.styleMeshes[fullKey];
                    styleMesh.mesh.isVisible = false;
                }
                Menu3D.openMainMenuFloorButton.toggled();
            },
            "Remove Existing": {},
        };
        // Add in the components (ligand, protein, etc).
        /** @type {number} */
        let componentsLen = components.length;
        for (let i = 0; i < componentsLen; i++) {
            let component = components[i];
            menu["Components"][component] = {};
            /** @type {number} */
            let selectionsComponentLen = selections[component].length;
            for (let i2 = 0; i2 < selectionsComponentLen; i2++) {
                let selection = selections[component][i2];
                menu["Components"][component][selection] = makeRepColorSchemeSubMenus({}, component, (rep, colorScheme) => {
                    Visualize.toggleRep([component, selection], rep, colorScheme);
                });
            }
        }
        return menu;
    }
    exports.buildStylesSubMenu = buildStylesSubMenu;
    /**
     * Populates the portion of the styles menu that lets the user remove old
     * styles.
     * @param  {Object<string,*>} menuInf
     * @returns void
     */
    function updatePastStylesInMenu(menuInf) {
        // Also add in existing styles so they can be removed.
        menuInf["Styles"]["Remove Existing"] = {};
        Menu3D.setupSubMenuNavButtons(menuInf["Styles"]["Remove Existing"], ["Styles", "Remove Existing"]);
        let repNames = Object.keys(Visualize.styleMeshes);
        /** @type {number} */
        let len = repNames.length;
        for (let i = 0; i < len; i++) {
            let repName = repNames[i];
            if (Visualize.styleMeshes[repName].mesh.isVisible === true) {
                let lbl = repName.replace(/--/g, " ");
                lbl = lbl.replace(/{/g, "").replace(/}/g, "").replace(/"/g, "");
                menuInf["Styles"]["Remove Existing"][lbl] = () => {
                    Menu3D.openMainMenuFloorButton.toggled();
                    setTimeout(() => {
                        /** @type {Array<*>} */
                        let repInfo = UrlVars.extractRepInfoFromKey(repName);
                        Visualize.toggleRep(repInfo[0], repInfo[1], "Hide");
                    }, 0);
                };
            }
        }
    }
    exports.updatePastStylesInMenu = updatePastStylesInMenu;
    /**
     * Populates the portion of the styles menu that has model-specific
     * selections.
     * @param  {Object<string,*>} menuInf
     * @returns void
     */
    function updateModelSpecificSelectionsInMenu(menuInf) {
        // Reset this part of the menu.
        menuInf["Styles"]["Selections"] = {};
        Menu3D.setupSubMenuNavButtons(menuInf["Styles"]["Selections"], ["Styles", "Selections"]);
        // Selection keywords
        let selKeywords = {
            "Atom Name": "atom",
            "Chain": "chain",
            "Element": "elem",
            "Residue Index": "resi",
            "Residue Name": "resn",
            "Secondary Structure": "ss",
        };
        let maxNumPerGroup = 14;
        /**
         * @param  {string}      component
         * @param  {Object<*,*>} menuBranch
         * @param  {Array<*>}    items
         * @param  {Array<string>} breadcrumbs
         */
        let addToMenuRecurse = (component, menuBranch, items, breadcrumbs) => {
            items.sort(
            /**
             * @param  {number} x
             * @param  {number} y
             * @returns number
             */
            (x, y) => {
                // If either is a string number, convert to number.
                /** @type {number} */
                x = isNaN(+x) ? x : +x;
                /** @type {number} */
                y = isNaN(+y) ? y : +y;
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
                return 0;
            });
            // So divide it into maxNumPerGroup groups.
            let chunks = chunkify(items, maxNumPerGroup);
            // Add the items and recurse if necessary.
            /** @type {number} */
            let chunksLen = chunks.length;
            for (let i = 0; i < chunksLen; i++) {
                /** @type {Array<*>} */
                let chunk = chunks[i];
                if (chunk.length === 1) {
                    // Just a single item, so make the rep/color submenus.
                    let item = chunk[0];
                    menuBranch[item] = {};
                    // MOOSE
                    menuBranch[item] = makeRepColorSchemeSubMenus(menuBranch[item], component, (rep, colorScheme) => {
                        /** @type {string} */
                        let selKeyword = selKeywords[component]; // See ThreeDMol.ts
                        let it = {};
                        it[selKeyword] = item;
                        Visualize.toggleRep([it], rep, colorScheme);
                    }, breadcrumbs.concat([item]));
                }
                else {
                    // Multiple items, so it's a category.
                    let lbl = "[" + chunk[0].toString() + "-" + chunk[chunk.length - 1].toString() + "]";
                    menuBranch[lbl] = {};
                    addToMenuRecurse(component, menuBranch[lbl], chunk, breadcrumbs.concat([lbl]));
                }
            }
            // Also add in things like back buttons.
            Menu3D.setupSubMenuNavButtons(menuBranch, breadcrumbs);
        };
        // Add in selections specific to this protein.
        let cs = Object.keys(ThreeDMol.atomicInfo);
        let len = cs.length;
        for (let i = 0; i < len; i++) {
            let component = cs[i];
            // component is like "Element"
            let sels = ThreeDMol.atomicInfo[component];
            menuInf["Styles"]["Selections"][component] = {};
            addToMenuRecurse(component, menuInf["Styles"]["Selections"][component], sels, ["Styles", "Selections", component]);
        }
    }
    exports.updateModelSpecificSelectionsInMenu = updateModelSpecificSelectionsInMenu;
    /**
     * Takes an array and divides it into subarrays that are roughly equally
     * spaced.
     * @param  {Array<*>} arr        The array.
     * @param  {number}   numChunks  The number of subarrays.
     * @returns Array<Array<*>>  An array of arrays.
     */
    function chunkify(arr, numChunks) {
        // see
        // https://stackoverflow.com/questions/8188548/splitting-a-js-array-into-n-arrays
        if (numChunks < 2) {
            return [arr];
        }
        let len = arr.length;
        let out = [];
        let i = 0;
        let size;
        if (len % numChunks === 0) {
            size = Math.floor(len / numChunks);
            while (i < len) {
                out.push(arr.slice(i, i += size));
            }
        }
        else {
            while (i < len) {
                size = Math.ceil((len - i) / numChunks--);
                out.push(arr.slice(i, i += size));
            }
        }
        return out;
    }
    /**
     * Adds representative and color submenus.
     * @param  {Object}        menuBranch      The branch to which to add these
     *                                         submenus.
     * @param  {string}        component       Like "Protein".
     * @param  {Function}      clickFunc       The function to run when the
     *                                         buttons of this submenu are
     *                                         clicked.
     * @param  {Array<string>} [breadcrumbs=]  If given, this is used to add
     *                                         buttons like the Back button.
     * @returns Object                         The submenu object, now updated.
     */
    function makeRepColorSchemeSubMenus(menuBranch, component, clickFunc, breadcrumbs) {
        // What representations can you use? Default to Protein because it
        // contains them all.
        /** @type Object<string,*> */
        let repsToUse = (representations[component] === undefined) ?
            representations["Protein"] :
            representations[component]; // Like ["Cartoon"]
        /** @type {number} */
        let repsToUseLen = repsToUse.length;
        for (let i = 0; i < repsToUseLen; i++) {
            /** @type {string} */
            let rep = repsToUse[i];
            menuBranch[rep] = {
                "Colors": {},
                "Color Schemes": {},
            };
            let colorSchemesLen = colorSchemes.length;
            for (let i = 0; i < colorSchemesLen; i++) {
                /** @type {string} */
                let colorScheme = colorSchemes[i];
                menuBranch[rep]["Color Schemes"][colorScheme] = () => {
                    clickFunc(rep, colorScheme);
                    Menu3D.openMainMenuFloorButton.toggled();
                };
            }
            /** @type {number} */
            let colorsLen = colors.length;
            for (let i = 0; i < colorsLen; i++) {
                /** @type {string} */
                let color = colors[i];
                menuBranch[rep]["Colors"][color] = () => {
                    clickFunc(rep, color);
                    Menu3D.openMainMenuFloorButton.toggled();
                };
            }
            menuBranch[rep]["Hide"] = () => {
                clickFunc(rep, "Hide");
                Menu3D.openMainMenuFloorButton.toggled();
            };
            // Also add in things like back buttons.
            if (breadcrumbs !== undefined) {
                let newCrumbs = breadcrumbs.concat([rep]);
                Menu3D.setupSubMenuNavButtons(menuBranch[rep], newCrumbs);
                newCrumbs = breadcrumbs.concat([rep, "Colors"]);
                let newBranch = menuBranch[rep]["Colors"];
                Menu3D.setupSubMenuNavButtons(newBranch, newCrumbs);
                newCrumbs = breadcrumbs.concat([rep, "Color Schemes"]);
                newBranch = menuBranch[rep]["Color Schemes"];
                Menu3D.setupSubMenuNavButtons(newBranch, newCrumbs);
            }
        }
        if (breadcrumbs !== undefined) {
            Menu3D.setupSubMenuNavButtons(menuBranch, breadcrumbs);
        }
        return menuBranch;
    }
});

// Functions to create a protein visualization using 3DMol.js
define('Mols/3DMol/Visualize',["require", "exports", "../../Scene/Optimizations", "../../UI/Menu3D/Menu3D", "../../UI/Menu3D/Styles", "../../UrlVars", "../../Vars", "./PositionInScene", "./VRML"], function (require, exports, Optimizations, Menu3D, Styles, UrlVars, Vars, PositionInScene, VRML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    // A place to keep track of all the styles. List of [key, vals]
    // let styles: any[] = [];
    let currentSurface = undefined;
    exports.styleMeshes = {};
    let selKeyWordTo3DMolSel = {
        // See VMD output TCL files for good ideas. You may nee to look at
        // Styles.ts too.
        "All": {},
        "Protein": { "resn": lAndU(["ALA", "ARG", "ASP", "ASN", "ASX", "CYS",
                "GLN", "GLU", "GLX", "GLY", "HIS", "HSP",
                "HYP", "ILE", "LEU", "LYS", "MET", "PCA",
                "PHE", "PRO", "TRP", "TYR", "VAL", "GLU",
                "SER", "THR", "MSE"]) },
        "Acidic": { "resn": lAndU(["ASP", "GLU"]) },
        "Cyclic": { "resn": lAndU(["HIS", "PHE", "PRO", "TRP", "TYR"]) },
        "Aliphatic": { "resn": lAndU(["ALA", "GLY", "ILE", "LEU", "VAL"]) },
        "Aromatic": { "resn": lAndU(["HIS", "PHE", "TRP", "TYR"]) },
        "Basic": { "resn": lAndU(["ARG", "HIS", "LYS", "HSP"]) },
        "Charged": { "resn": lAndU(["ASP", "GLU", "ARG", "HIS", "LYS", "HSP"]) },
        "Hydrophobic": { "resn": lAndU(["ALA", "LEU", "VAL", "ILE", "PRO", "PHE",
                "MET", "TRP"]) },
        "Neutral": { "resn": lAndU(["VAL", "PHE", "GLN", "TYR", "HIS", "CYS",
                "MET", "TRP", "ASX", "GLX", "PCA", "HYP"]) },
        "Nucleic": { "resn": lAndU(["ADE", "A", "GUA", "G", "CYT", "C", "THY",
                "T", "URA", "U"]) },
        "Purine": { "resn": lAndU(["ADE", "A", "GUA", "G"]) },
        "Pyrimidine": { "resn": lAndU(["CYT", "C", "THY", "T", "URA", "U"]) },
        "Ions": { "resn": lAndU(["AL", "BA", "CA", "CAL", "CD", "CES", "CLA",
                "CL", "CO", "CS", "CU", "CU1", "CUA", "HG",
                "IN", "IOD", "K", "MG", "MN3", "MO3", "MO4",
                "MO5", "MO6", "NA", "NAW", "OC7", "PB",
                "POT", "PT", "RB", "SOD", "TB", "TL", "WO4",
                "YB", "ZN", "ZN1", "ZN2"]) },
        "Water": { "resn": lAndU(["WAT", "HOH", "TIP", "TIP3"]) },
    };
    // Add in ligand
    selKeyWordTo3DMolSel["Ligand"] = { "not": { "or": [
                selKeyWordTo3DMolSel["Protein"],
                selKeyWordTo3DMolSel["Nucleic"],
                selKeyWordTo3DMolSel["Ions"],
                selKeyWordTo3DMolSel["Water"],
            ] } };
    // Add in all within ligand
    selKeyWordTo3DMolSel["Ligand Context"] = {
        "byres": true,
        "within": {
            "distance": 4.0,
            "sel": selKeyWordTo3DMolSel["Ligand"],
        },
    };
    console.log(JSON.stringify(selKeyWordTo3DMolSel["Ligand Context"]));
    let colorSchemeKeyWordTo3DMol = {
        "Amino Acid": { "colorscheme": "amino" },
        "Blue": { "color": "blue" },
        "Chain": { "colorscheme": "chain" },
        "Element": { "colorscheme": "default" },
        "Green": { "color": "green" },
        "Nucleic": { "colorscheme": "nucleic" },
        "Orange": { "color": "orange" },
        "Purple": { "color": "purple" },
        "Red": { "color": "red" },
        "Spectrum": { "color": "spectrum" },
        "White": { "color": "white" },
        "Yellow": { "color": "yellow" },
    };
    // Ligand?
    // All residus? Chains? Elements? Others here... https://3dmol.csb.pitt.edu/doc/types.html#AtomSpec
    /**
     * The toggleRep function. Starts the mesh-creation proecss.
     * @param  {Array<*>}            filters        Can include strings (lookup
     *                                              sel in selKeyWordTo3DMolSel).
     *                                              Or a 3DMoljs selection object.
     * @param  {string}              repName        The representative name. Like
     *                                              "Surface".
     * @param  {string}              colorScheme    The name of the color scheme.
     * @param  {Function|undefined}  finalCallback  Callback to run once the mesh
     *                                              is entirely done.
     * @returns void
     */
    function toggleRep(filters, repName, colorScheme, finalCallback = undefined) {
        // Get the key of this rep request.
        /** @type {Object<string,*>} */
        let keys = getKeys(filters, repName, colorScheme);
        if (finalCallback === undefined) {
            finalCallback = () => { return; };
        }
        // If it's "Hide", then just hide the mesh
        if (colorScheme === "Hide") {
            let fullKeys = Object.keys(exports.styleMeshes);
            let len = fullKeys.length;
            for (let i = 0; i < len; i++) {
                let fullKey = fullKeys[i];
                let styleMesh = exports.styleMeshes[fullKey];
                if (styleMesh.categoryKey === keys.categoryKey) {
                    styleMesh.mesh.isVisible = false;
                    console.log("Hiding existing mesh...");
                }
            }
            // Still need to position the meshes (hiding some reps could make others bigger).
            PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"));
            visChanged();
            return;
        }
        // Maybe the mesh has been generated previously. If so, just show that.
        if (exports.styleMeshes[keys.fullKey] !== undefined) {
            exports.styleMeshes[keys.fullKey].mesh.isVisible = true;
            console.log("showing existing mesh...");
            // Still need to position the meshes (hiding some reps could make others bigger).
            PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"));
            visChanged();
            return;
        }
        // You'll need to use 3DMoljs to generate the mesh, since it's never been
        // generated before. First remove all representations from existing
        // 3Dmoljs.
        // let viewer = VRML.viewer;
        // VRML.removeAllSurfaces();
        // VRML.setStyle({}, undefined);
        // console.log("Abovee causes an error...");
        VRML.resetAll();
        // VRML.viewer.render();
        // Make the new representation.
        /** @type {string} */
        let colorSccheme = colorSchemeKeyWordTo3DMol[colorScheme];
        let sels = { "and": filters.map((i) => {
                // "i" can be a keyword or a selection json itself.
                return (selKeyWordTo3DMolSel[i] !== undefined) ? selKeyWordTo3DMolSel[i] : i;
            }) };
        if (repName.toLowerCase() === "surface") {
            VRML.addSurface(colorSccheme, sels, () => {
                toggleRepContinued(keys, repName, finalCallback);
            });
        }
        else {
            let rep = {};
            rep[repName.toLowerCase()] = colorSccheme;
            VRML.setStyle(sels, rep);
            toggleRepContinued(keys, repName, finalCallback);
        }
    }
    exports.toggleRep = toggleRep;
    /**
     * Continues the toggleRep function.
     * @param  {Object<string,*>}    keys
     * @param  {string}              repName        The representative name. Like
     *                                              "Surface".
     * @param  {Function|undefined}  finalCallback  Callback to run once the mesh
     *                                              is entirely done.
     * @returns void
     */
    function toggleRepContinued(keys, repName, finalCallback) {
        VRML.render(true, repName, (newMesh) => {
            // Remove any other meshes that have the same category key (so could
            // be different color... that would be removed.)
            let ks = Object.keys(exports.styleMeshes);
            let len = ks.length;
            for (let i = 0; i < len; i++) {
                let key = ks[i];
                let styleMesh = exports.styleMeshes[key];
                if (styleMesh.categoryKey === keys.categoryKey) {
                    Optimizations.removeMeshEntirely(styleMesh.mesh);
                    delete exports.styleMeshes[key];
                    console.log("deleting old mesh...");
                }
            }
            // If the new mesh is a surface, make it so each triangle is two sided
            // and delete the surface from 3Dmoljs instance (cleanup).
            if (repName === "Surface") {
                newMesh.material.backFaceCulling = false;
                // if (currentSurface !== undefined) {
                // debugger;
                // VRML.viewer.removeSurface(currentSurface["surfid"]);
                // currentSurface = undefined;
                // }
            }
            // Add this new one.
            exports.styleMeshes[keys.fullKey] = {
                categoryKey: keys.categoryKey,
                mesh: newMesh,
            };
            visChanged();
            finalCallback();
            console.log("added new mesh");
        });
    }
    /**
     * Get keys to uniquelty describe a given representations.
     * @param  {Array<string|Object>} filters      Selections. Can be keywords or
     *                                             3dmoljs selection objects.
     * @param  {string}               repName      The name of the representation,
     *                                             e.g., "Cartoon".
     * @param  {string}               colorScheme  The color style keyword.
     * @returns {Object<string,*>}
     */
    function getKeys(filters, repName, colorScheme) {
        filters.sort();
        let filtersStr = filters.map((f) => {
            if (typeof f === "string") {
                return f;
            }
            else {
                return JSON.stringify(f);
            }
        }); // In case some JSON selections.
        return {
            categoryKey: filtersStr.join("--") + "--" + repName,
            fullKey: filtersStr.join("--") + "--" + repName + "--" + colorScheme,
        };
    }
    /**
     * Also adds upper and lower versions of elements in a list.
     * @param  {Array<string>} lst  The original list.
     * @returns {Array<string>}  The list with uppercase and lowercase items also added.
     */
    function lAndU(lst) {
        let newLst = lst.map((s) => s);
        let len = lst.length;
        for (let i = 0; i < len; i++) {
            let s = lst[i];
            newLst.push(s.toUpperCase());
            newLst.push(s.toLowerCase());
        }
        // See https://gomakethings.com/removing-duplicates-from-an-array-with-vanilla-javascript/
        newLst = newLst.filter((item, index) => {
            return newLst.indexOf(item) >= index;
        });
        return newLst;
    }
    /**
     * This runs whenever a visualization changes, no matter how it changes.
     * @returns void
     */
    function visChanged() {
        // Update the URL
        UrlVars.setURL();
        // Recalculate the past-styles section of the menu.
        Styles.updatePastStylesInMenu(Menu3D.menuInf);
    }
});

define('Mols/3DMol/PositionInScene',["require", "exports", "../../Scene/Optimizations", "../../Vars", "./Visualize", "./VRML"], function (require, exports, Optimizations, Vars, Visualize, VRML) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lastRotationBeforeAnimation = new BABYLON.Vector3(0, 0, 0);
    let lastRotationVec = undefined;
    let cachedDeltaYs = {};
    /**
     * Positions a given molecular mesh within a specified box.
     * @param  {*}         babylonMesh       The molecular mesh.
     * @param  {*}         otherBabylonMesh  The box.
     * @param  {boolean=}  animate           Whether to animate the mesh, to move
     *                                       it to the new position. Defaults to
     *                                       false.
     * @returns void
     */
    function positionAll3DMolMeshInsideAnother(babylonMesh, otherBabylonMesh, animate = false) {
        /** @type {Array<*>} */
        let allVisMolMeshes = getVisibleMolMeshes(babylonMesh);
        // Save all information about each of the visible meshes, for later
        // animation.
        if (lastRotationVec === undefined) {
            lastRotationVec = VRML.molRotation.clone();
        }
        let allVisMolMeshesInfo = allVisMolMeshes.map((m) => {
            return {
                mesh: m,
                position: m.position.clone(),
                rotation: lastRotationVec.clone(),
                scaling: m.scaling.clone(),
            };
        });
        lastRotationVec = VRML.molRotation.clone();
        if (allVisMolMeshes.length === 0) {
            // No meshes to show.
            return;
        }
        resetMeshes(allVisMolMeshes);
        // Render to update the meshes
        Vars.scene.render(); // Needed to get bounding box to recalculate.
        // Get the bounding box of the other mesh and it's dimensions
        // (protein_box).
        let targetBox = otherBabylonMesh.getBoundingInfo().boundingBox;
        let targetBoxDimens = Object.keys(targetBox.maximumWorld).map((k) => targetBox.maximumWorld[k] - targetBox.minimumWorld[k]);
        // Get the molecular model with the biggest volume.
        let maxVol = 0.0;
        let thisBox;
        /** @type {Array<number>} */
        let thisBoxDimens;
        let thisMesh; // biggest mesh
        /** @type {number} */
        let allVisMolMeshesLen = allVisMolMeshes.length;
        for (let i = 0; i < allVisMolMeshesLen; i++) {
            let allVisMolMesh = allVisMolMeshes[i];
            // Get the bounding box of this mesh.
            let thisBoxTmp = allVisMolMesh.getBoundingInfo().boundingBox;
            let thisBoxDimensTmp = Object.keys(thisBoxTmp.maximumWorld).map((k) => thisBoxTmp.maximumWorld[k] - thisBoxTmp.minimumWorld[k]);
            let volume = thisBoxDimensTmp[0] * thisBoxDimensTmp[1] * thisBoxDimensTmp[2];
            if (volume > maxVol) {
                maxVol = volume;
                thisBox = thisBoxTmp;
                thisBoxDimens = thisBoxDimensTmp;
                thisMesh = allVisMolMesh; // biggest mesh
            }
        }
        // Get the scales
        let scales = targetBoxDimens.map((targetBoxDimen, i) => targetBoxDimen / thisBoxDimens[i]);
        // Get the minimum scale
        let minScale = Math.min.apply(null, scales);
        let meshScaling = new BABYLON.Vector3(minScale, minScale, minScale);
        // Scale the meshes.
        for (let i = 0; i < allVisMolMeshesLen; i++) {
            let allVisMolMesh = allVisMolMeshes[i];
            allVisMolMesh.scaling = meshScaling;
        }
        Vars.scene.render(); // Needed to get bounding box to recalculate.
        // Translate the meshes.
        let meshTranslation = thisBox.centerWorld.subtract(targetBox.centerWorld);
        for (let i = 0; i < allVisMolMeshesLen; i++) {
            let allVisMolMesh = allVisMolMeshes[i];
            allVisMolMesh.position = allVisMolMesh.position.subtract(meshTranslation);
        }
        Vars.scene.render(); // Needed to get bounding box to recalculate.
        if (true) {
            let deltaY = moveMolMeshesToGround(thisMesh, targetBox);
            for (let i = 0; i < allVisMolMeshesLen; i++) {
                let allVisMolMesh = allVisMolMeshes[i];
                allVisMolMesh.position.y = allVisMolMesh.position.y - deltaY;
                allVisMolMesh.visibility = 1; // Hide while rotating.
            }
        }
        exports.lastRotationBeforeAnimation = allVisMolMeshesInfo[0].rotation.clone();
        // Now do the animations, if not moving from origin (as is the case if the
        // style just changed).
        if (animate === true) {
            let len = allVisMolMeshesInfo.length;
            for (let i = 0; i < len; i++) {
                let allVisMolMeshInfo = allVisMolMeshesInfo[i];
                let mesh = allVisMolMeshInfo.mesh;
                let pos = mesh.position.clone();
                let sca = mesh.scaling.clone();
                let rot = mesh.rotation.clone();
                let posX = makeBabylonAnim("posX", "position.x", allVisMolMeshInfo.position.x, pos.x);
                let posY = makeBabylonAnim("posY", "position.y", allVisMolMeshInfo.position.y, pos.y);
                let posZ = makeBabylonAnim("posZ", "position.z", allVisMolMeshInfo.position.z, pos.z);
                let scaX = makeBabylonAnim("scaX", "scaling.x", allVisMolMeshInfo.scaling.x, sca.x);
                let scaY = makeBabylonAnim("scaY", "scaling.y", allVisMolMeshInfo.scaling.y, sca.y);
                let scaZ = makeBabylonAnim("scaZ", "scaling.z", allVisMolMeshInfo.scaling.z, sca.z);
                let rotX = makeBabylonAnim("rotX", "rotation.x", allVisMolMeshInfo.rotation.x, rot.x);
                let rotY = makeBabylonAnim("rotY", "rotation.y", allVisMolMeshInfo.rotation.y, rot.y);
                let rotZ = makeBabylonAnim("rotZ", "rotation.z", allVisMolMeshInfo.rotation.z, rot.z);
                mesh.animations = [posX, posY, posZ, scaX, scaY, scaZ, rotX, rotY, rotZ];
                let anim = Vars.scene.beginAnimation(mesh, 0, 15, false, 1, () => {
                    // You need to recalculate the shadows.
                    Optimizations.updateEnvironmentShadows();
                });
            }
        }
        else {
            // Not animating. You need to recalculate the shadows.
            Optimizations.updateEnvironmentShadows();
        }
    }
    exports.positionAll3DMolMeshInsideAnother = positionAll3DMolMeshInsideAnother;
    /**
     * How much to move the mesh to position it on the ground.
     * @param  {*} biggestMolMesh The biggest molecular mesh.
     * @param  {Object} targetBox      The box within which to position the mesh.
     * @returns number  How much to move along the Y axis.
     */
    function moveMolMeshesToGround(biggestMolMesh, targetBox) {
        // The above will position the molecular mesh within the target mesh,
        // centering the two bounding boxes. That would be good for positioning
        // proteins in a bilayer, for example. Now let's move the meshes so they
        // are actually on the ground (all other meshes).
        // Check and see if the deltaY has already been calculated.
        let PI = Math.PI;
        let key = biggestMolMesh.name + "-" +
            (biggestMolMesh.rotation.x % PI).toFixed(3) + "-" +
            (biggestMolMesh.rotation.y % PI).toFixed(3) + "-" +
            (biggestMolMesh.rotation.z % PI).toFixed(3);
        if (cachedDeltaYs[key] !== undefined) {
            return cachedDeltaYs[key];
        }
        // Unfortunately, BABYLONjs rotates bounding boxes with the mesh. So the
        // minimum z per the bounding box doesn't correspond to EXACTLY the
        // minimum z of any vertex. Let's loop through the biggest mesh and find
        // its lowest vertex, because positioning over the ground needs to be more
        // exact.
        let verts = biggestMolMesh.getVerticesData(BABYLON.VertexBuffer.PositionKind);
        let thisMinY = 1000000.0;
        let vertsLength = verts.length;
        let thisMeshWorldMatrix = biggestMolMesh.getWorldMatrix();
        let amntToSkipToGet1000Pts = Math.max(1, 3 * Math.floor(vertsLength / 3000));
        for (let i = 0; i < vertsLength; i = i + amntToSkipToGet1000Pts) {
            let vec = new BABYLON.Vector3(verts[i], verts[i + 1], verts[i + 2]);
            vec = BABYLON.Vector3.TransformCoordinates(vec, thisMeshWorldMatrix);
            if (vec.y < thisMinY) {
                thisMinY = vec.y;
            }
        }
        // The min z of the target box should be ok.
        let targetMinY = targetBox.minimumWorld.y;
        let deltaY = thisMinY - targetMinY - 0.1;
        cachedDeltaYs[key] = deltaY;
        return deltaY;
    }
    /**
     * Gets a list of all the babylonjs molecular meshes that are visible.
     * @param  {*} babylonMesh  The mesh that was just added.
     * @returns Array<*>  A list of all visible meshes.
     */
    function getVisibleMolMeshes(babylonMesh) {
        let allVisMolMeshes = [];
        let molMeshIds = Object.keys(Visualize.styleMeshes);
        let len = molMeshIds.length;
        for (let i = 0; i < len; i++) {
            let molMeshId = molMeshIds[i];
            let allVisMolMesh = Visualize.styleMeshes[molMeshId].mesh;
            if (allVisMolMesh.isVisible === true) {
                allVisMolMeshes.push(allVisMolMesh);
            }
        }
        // Add the current one (just added).
        if (babylonMesh !== undefined) {
            allVisMolMeshes.push(babylonMesh);
        }
        return allVisMolMeshes;
    }
    /**
     * Resets things like the location and rotation of all visible meshes.
     * @param  {Object<*>} allVisMolMeshes  All the visible meshes.
     * @returns void
     */
    function resetMeshes(allVisMolMeshes) {
        // Reset the scaling, position, and rotation of all the visible molecular
        // meshes.
        let len = allVisMolMeshes.length;
        for (let i = 0; i < len; i++) {
            let allVisMolMesh = allVisMolMeshes[i];
            allVisMolMesh.animations = [];
            if (allVisMolMesh.isVisible === true) {
                // Make sure allVisMolMesh is not scaled or positioned. But
                // note that rotations are preserved.
                allVisMolMesh.scaling = new BABYLON.Vector3(1, 1, 1);
                allVisMolMesh.position = new BABYLON.Vector3(0, 0, 0);
                allVisMolMesh.rotation = VRML.molRotation;
                allVisMolMesh.visibility = 0; // Hide while rotating.
            }
        }
    }
    /**
     * Make a babylonjs animation. I found myself doing this a lot, so figured I'd
     * make a function.
     * @param  {string} name      The animation name.
     * @param  {string} prop      The property to animate.
     * @param  {number} startVal  The starting value.
     * @param  {number} endVal    The ending value.
     */
    function makeBabylonAnim(name, prop, startVal, endVal) {
        let anim = new BABYLON.Animation(name, prop, 60, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);
        anim.setKeys([
            { frame: 0, value: startVal },
            { frame: 15, value: endVal },
        ]);
        return anim;
    }
    ;
});

define('UI/Menu3D/Rotations',["require", "exports", "../../Mols/3DMol/PositionInScene", "../../Mols/3DMol/VRML", "../../Vars"], function (require, exports, PositionInScene, VRML, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Builds a submenu object describing how the models and be rotated.
     * @returns Object The submenu objct.
     */
    function buildRotationsSubMenu() {
        let amt = 15.0 * Math.PI / 180.0;
        return {
            "Undo Rotate": () => {
                let vec = PositionInScene.lastRotationBeforeAnimation;
                VRML.setMolRotation(vec.x, vec.y, vec.z);
                PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"), true);
            },
            "X Axis": () => {
                VRML.updateMolRotation("x", amt);
                PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"), true);
            },
            "Y Axis": () => {
                VRML.updateMolRotation("y", amt);
                PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"), true);
            },
            "Z Axis": () => {
                VRML.updateMolRotation("z", amt);
                PositionInScene.positionAll3DMolMeshInsideAnother(undefined, Vars.scene.getMeshByName("protein_box"), true);
            },
        };
    }
    exports.buildRotationsSubMenu = buildRotationsSubMenu;
});

define('UI/Menu3D/Menu3D',["require", "exports", "../../Cameras/CommonCamera", "../../Navigation/Points", "../../Vars", "./Button", "./Rotations", "./Styles"], function (require, exports, CommonCamera, VRPoints, Vars, Button, Rotations, Styles) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.clickSound = undefined;
    // These variables need to be initialized in setup(), to enable reloading if
    // necessary.
    /** @type {Array<*>} */
    let allButtons;
    let latestBreadcrumbsViewed;
    /** @type {Object<string>} */
    let sceneInfoData;
    let GUI3DMenuManager;
    let commonMenuAnchor;
    /**
     * Load the 3D GUI. Also reloads the GUI (destroys old version). Reloading is
     * useful when you add a new PDB, for example, and want to update the
     * selection options.
     * @param  {Object<string,*>=} data The data from scene_info.json. Saves on
     *                                  first use so it doesn't need to be
     *                                  subsequently specified.
     * @returns void
     */
    function setup(data) {
        // Initialize some variables
        allButtons = [];
        latestBreadcrumbsViewed = [];
        exports.menuInf = {
            "Styles": Styles.buildStylesSubMenu(),
            "Rotate": Rotations.buildRotationsSubMenu(),
            "Last": () => {
                console.log("Going to", latestBreadcrumbsViewed);
                showOnlyButtonsOfLevel(latestBreadcrumbsViewed);
            },
        };
        // Save the scene data so you can reference it in the future, if you
        // recreate the menu. If it's not defined, the use the saved data.
        if (data !== undefined) {
            sceneInfoData = data;
        }
        else {
            data = sceneInfoData;
        }
        // Only required to setup once.
        if (GUI3DMenuManager === undefined) {
            // Make a manager for the menu
            GUI3DMenuManager = new BABYLON.GUI.GUI3DManager(Vars.scene);
            // window["GUI3DMenuManager"] = GUI3DMenuManager;
        }
        setupMainMenu();
        // Only required to setup once.
        if (exports.openMainMenuFloorButton === undefined) {
            setupMainMenuToggleButton();
        }
        // Only required to setup once.
        if (exports.clickSound === undefined) {
            exports.clickSound = new BABYLON.Sound("click-button", "assets/staple-public-domain.mp3", Vars.scene, null, { loop: false, autoplay: false, spatialSound: true, volume: 0.1 });
        }
        // Simplify the menu (collapsing excessive parts).
        reduceSingleItemSubMenus();
    }
    exports.setup = setup;
    /**
     * Setup the main menu.
     * @returns void
     */
    function setupMainMenu() {
        // Get the descriptions
        // VRVoiceCommands.setMoleculeNameInfos(data);
        // Flatten the menu data.
        // menuInfFlat = groupMenuInfByLevel();
        // Here would also be a good place to add additional buttons such as voice
        // dictation. See setupAllSubMenuNavButtons for how this was done
        // previously.
        setupAllSubMenuNavButtons();
        commonMenuAnchor = new BABYLON.TransformNode(""); // this can be a mesh, too
        // createPanelIfNeeded(1);
        createPanelSixteenButtons();
        // for (let key in VRVoiceCommands.moleculeNameInfos) {
        //     if (VRVoiceCommands.moleculeNameInfos.hasOwnProperty(key)) {
        //         let inf = VRVoiceCommands.moleculeNameInfos[key];
        //         let desc = inf.description;
        //         allButtons.push(
        //             new ButtonWrapper({
        //                 clickFunc: (buttonWrapper) => {
        //                     VRVoiceCommands.showOrHideModel(
        //                         inf.modelName,
        //                         inf.representation,
        //                         !buttonWrapper.value,
        //                     );
        //                     // For reasons I don't understand, the radius on this
        //                     // cylinder (set below) doesn't take. Put it here to
        //                     // too make sure.
        //                     // cylinderPanelMainMenu.radius = Vars.MENU_RADIUS;
        //                     // cylinderPanelMainMenu.margin = Vars.MENU_MARGIN;
        //                 },
        //                 default: false,
        //                 falseTxt: desc + "\n(Hide)",
        //                 initFunc: (buttonWrapper) => {
        //                     buttonWrapper.isVisible(false);  // Buttons start off hidden.
        //                 },
        //                 name: "menu-visible-button-" + inf.modelName.replace(/ /g, "").replace(/\n/g, ""),
        //                 panel: cylinderPanelMainMenu,
        //                 trueTxt: desc + "\n(Show)",
        //             }),
        //         );
        //         // window.but = but;
        //     }
        // }
        // setupAllSubMenuNavButtons(cylinderPanelMainMenu, data);
    }
    /**
     * Creates a panel containing 16 buttons. These buttons are manipulated to
     * show different submenus.
     * @returns void
     */
    function createPanelSixteenButtons() {
        // let panel = new BABYLON.GUI.CylinderPanel();
        let panel = new BABYLON.GUI.SpherePanel();
        panel.radius = Vars.MENU_RADIUS;
        panel.margin = Vars.MENU_MARGIN;
        GUI3DMenuManager.addControl(panel);
        panel.blockLayout = true;
        // Add buttons
        for (let idx = 0; idx < 16; idx++) {
            let func = () => { return; };
            let txt = idx.toString();
            let color = "yellow";
            let levelInt = 1;
            allButtons.push(new Button.ButtonWrapper({
                clickFunc: (buttonWrapper) => {
                    func();
                    // For reasons I don't understand, the radius on this
                    // cylinder (set below) doesn't take. Put it here to
                    // too make sure.
                    // cylinderPanelMainMenu.radius = Vars.MENU_RADIUS;
                    // cylinderPanelMainMenu.margin = Vars.MENU_MARGIN;
                },
                default: false,
                falseTxt: txt,
                initFunc: (buttonWrapper) => {
                    buttonWrapper.isVisible(false); // Buttons start off hidden.
                },
                level: levelInt,
                name: "menu-visible-button-" + txt,
                panel: panel,
                trueTxt: txt,
                color,
            }));
        }
        // Set radius and such.
        panel.columns = 4;
        panel.linkToTransformNode(commonMenuAnchor);
        panel.blockLayout = false;
    }
    function applyFuncToAllMenuLevels(funcToApply) {
        /**
         * @param  {Object}           subMenu      The submenu data.
         * @param  {Array<string>}    breadcrumbs  They list of keys to get to
         *                                         this point in the menu.
         * @returns void
         */
        let recurse = (subMenu, breadcrumbs) => {
            funcToApply(subMenu, breadcrumbs);
            let keys = Object.keys(subMenu);
            let keysLen = keys.length;
            for (let i = 0; i < keysLen; i++) {
                let key = keys[i];
                let subMenuItems = subMenu[key];
                switch (typeof (subMenuItems)) {
                    case "object":
                        recurse(subMenuItems, breadcrumbs.concat([key]));
                        break;
                    default:
                        continue;
                }
            }
        };
        recurse(exports.menuInf, []);
    }
    /**
     * Set up submenu navigation buttons like back and close.
     * @returns void
     */
    function setupAllSubMenuNavButtons() {
        // Each of the submenus should have a back button and a close menu button.
        applyFuncToAllMenuLevels((subMenu, breadcrumbs) => {
            setupSubMenuNavButtons(subMenu, breadcrumbs);
        });
    }
    function setupSubMenuNavButtons(subMenu, breadcrumbs) {
        if (breadcrumbs.length > 0) {
            // No back button on top-level menu.
            subMenu["Back "] = () => {
                let newBreadcrumbs = breadcrumbs.slice(0, breadcrumbs.length - 1);
                showOnlyButtonsOfLevel(newBreadcrumbs);
            };
        }
        subMenu["Close Menu "] = () => {
            exports.openMainMenuFloorButton.toggled();
        };
    }
    exports.setupSubMenuNavButtons = setupSubMenuNavButtons;
    /**
     * Setup the toggle button on the floor that turns the main menu on and off.
     * @returns void
     */
    function setupMainMenuToggleButton() {
        // Also set up a manager at your feet. This turns the main manager on and
        // off.
        // gui3DMenuManagers[0] = new BABYLON.GUI.GUI3DManager(Vars.scene);
        let panelToggle = new BABYLON.GUI.StackPanel3D();
        GUI3DMenuManager.addControl(panelToggle);
        // Set up the button
        // let camera = Vars.scene.activeCamera;
        exports.openMainMenuFloorButton = new Button.ButtonWrapper({
            clickFunc: (buttonWrapper) => {
                if (!buttonWrapper.value) {
                    showOnlyButtonsOfLevel(undefined);
                }
                else {
                    showOnlyButtonsOfLevel([]);
                }
                commonMenuAnchor.position.copyFrom(CommonCamera.getCameraPosition());
                commonMenuAnchor.rotation.y = CommonCamera.getCameraRotationY(); //  + Math.PI * 0.5;
                // camera.rotation.y + Math.PI * 0.5;  // TODO: What about if VR camera?
            },
            default: false,
            falseTxt: "Show Menu",
            level: 0,
            name: "menu-visible-button",
            panel: panelToggle,
            trueTxt: "Hide Menu",
        });
        window["openMainMenuFloorButton"] = exports.openMainMenuFloorButton;
        // Set up the button anchor and move/rotate it.
        let mainMenuAnchorToggle = new BABYLON.TransformNode(""); // this can be a mesh, too
        panelToggle.linkToTransformNode(mainMenuAnchorToggle);
        mainMenuAnchorToggle.rotation.x = Math.PI * 0.5;
        // Update button position with each turn of the render loop.
        mainMenuAnchorToggle.position.copyFrom(VRPoints.groundPointBelowCamera);
        mainMenuAnchorToggle.position.y = mainMenuAnchorToggle.position.y + 0.1;
        mainMenuAnchorToggle.rotation.y = CommonCamera.getCameraRotationY();
        Vars.scene.registerBeforeRender(() => {
            // setInterval(() => {
            mainMenuAnchorToggle.position.copyFrom(VRPoints.groundPointBelowCamera); // Prob
            mainMenuAnchorToggle.position.y = mainMenuAnchorToggle.position.y + 0.1; // No prob
            mainMenuAnchorToggle.rotation.y = CommonCamera.getCameraRotationY(); // Prob
            // camera.rotation.y;  // TODO: What about VR camera.
            // }, 1000);
        });
    }
    /**
     * Shows the buttons associated with a specific submenu level.
     * @param  {Array<string>|undefined} breadcrumbs The breadcrumbs to get to the desired menu level.
     * @returns void
     */
    function showOnlyButtonsOfLevel(breadcrumbs) {
        if ((breadcrumbs !== undefined) && (breadcrumbs.length > 0)) {
            // Not the top-level menu or floor button, so enable "Last" button.
            latestBreadcrumbsViewed = breadcrumbs;
        }
        // Hide all the buttons.
        let allButtonsLen = allButtons.length;
        for (let i = 0; i < allButtonsLen; i++) {
            let btn = allButtons[i];
            btn.isVisible(false);
        }
        if (breadcrumbs === undefined) {
            // It's the button on the floor. Just needed to hide all buttons, so
            // now you're good.
            return;
        }
        // Find the submenu
        let subMenu = exports.menuInf;
        let breadcrumbsLen = breadcrumbs.length;
        for (let i = 0; i < breadcrumbsLen; i++) {
            let breadcrumb = breadcrumbs[i];
            subMenu = subMenu[breadcrumb];
        }
        // Get the names of the submenu items.
        let subMenuItemNames = Object.keys(subMenu);
        // Set some names aside as "special".
        let redBtns = ["Close Menu "];
        let yellowBtns = ["Back "];
        let specialBtns = redBtns.concat(yellowBtns);
        // Sort those names
        subMenuItemNames.sort((first, second) => {
            // See https://stackoverflow.com/questions/51165/how-to-sort-strings-in-javascript
            let firstIsSpecial = specialBtns.indexOf(first) !== -1;
            let secondIsSpecial = specialBtns.indexOf(second) !== -1;
            if (firstIsSpecial && !secondIsSpecial) {
                return 1;
            }
            else if (!firstIsSpecial && secondIsSpecial) {
                return -1;
            }
            else {
                return ("" + first).localeCompare(second);
            }
        });
        // Figure out what layout to use.
        let btnIdxOrder = [];
        if (subMenuItemNames.length <= 4) {
            btnIdxOrder = [7, 6, 5, 4];
        }
        else if (subMenuItemNames.length <= 8) {
            btnIdxOrder = [7, 6, 5, 4, 11, 10, 9, 8];
        }
        else if (subMenuItemNames.length <= 12) {
            btnIdxOrder = [3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8];
        }
        else {
            btnIdxOrder = [3, 2, 1, 0, 7, 6, 5, 4, 11, 10, 9, 8, 15, 14, 13, 12];
        }
        // Update and show the buttons.
        let len = subMenuItemNames.length;
        for (let i = 0; i < len; i++) {
            let subMenuItemName = subMenuItemNames[i];
            let subMenuItem = subMenu[subMenuItemName];
            let btnidx = btnIdxOrder[i];
            let btn = allButtons[btnidx];
            btn.updateTxt(subMenuItemName);
            switch (typeof (subMenuItem)) {
                case "object":
                    btn.clickFunc = () => {
                        showOnlyButtonsOfLevel(breadcrumbs.concat(subMenuItemName));
                    };
                    btn.updateColor("green");
                    break;
                case "function":
                    btn.clickFunc = subMenuItem;
                    btn.updateColor("default");
                    break;
                default:
                    break;
            }
            if (redBtns.indexOf(subMenuItemName) !== -1) {
                btn.updateColor("red");
            }
            else if (yellowBtns.indexOf(subMenuItemName) !== -1) {
                btn.updateColor("yellow");
            }
            // menuInfFlatThisOne.upLevel doesn't seem to be necessary.
            btn.isVisible(true);
        }
    }
    ;
    /**
     * If a given submenu has only one item, condense the menu.
     * @returns void
     */
    function reduceSingleItemSubMenus() {
        /**
         * @param  {Object}           subMenu      The submenu data.
         * @param  {Array<string>}    breadcrumbs  They list of keys to get to
         *                                         this point in the menu.
         * @returns void
         */
        let recurse = (subMenu, breadcrumbs) => {
            let keys = Object.keys(subMenu);
            // There should be three items in a one-item submenu, including back
            // and close.
            if (keys.length === 3) {
                let keysToKeep = keys.filter((k) => {
                    if (k === "Close Menu ") {
                        return false;
                    }
                    else if (k === "Back ") {
                        return false;
                    }
                    return true;
                });
                if (keysToKeep.length === 1) {
                    // Only one item remains. That's the one to collpase.
                    let keyToKeep = keysToKeep[0];
                    // Get the name of the new key (one up with keyToKeep added to
                    // end).
                    let lastKey = breadcrumbs[breadcrumbs.length - 1];
                    let newKey = lastKey + ": " + keyToKeep;
                    // Redefine the breadcrumbs
                    breadcrumbs = breadcrumbs.slice(0, breadcrumbs.length - 1).concat([newKey]);
                    // Go through the menu keys to get to the submenu above this
                    // one.
                    subMenu = exports.menuInf;
                    let breadcrumbsButLast = breadcrumbs.slice(0, breadcrumbs.length - 1);
                    let breadcrumbsButLastLen = breadcrumbsButLast.length;
                    for (let i = 0; i < breadcrumbsButLastLen; i++) {
                        let breadcrumb = breadcrumbsButLast[i];
                        subMenu = subMenu[breadcrumb];
                    }
                    // Rename if submenu.
                    subMenu[newKey] = subMenu[lastKey][keyToKeep];
                    delete subMenu[lastKey];
                    // Go into new submenu
                    subMenu = subMenu[newKey];
                    // Update keys
                    keys = Object.keys(subMenu);
                }
            }
            let keysLen = keys.length;
            for (let i = 0; i < keysLen; i++) {
                let key = keys[i];
                let subMenuItems = subMenu[key];
                switch (typeof (subMenuItems)) {
                    case "object":
                        recurse(subMenuItems, breadcrumbs.concat([key]));
                        break;
                    default:
                        continue;
                }
            }
        };
        recurse(exports.menuInf, []);
    }
});

define('Mols/Load',["require", "exports", "../Scene/Optimizations", "../UI/Menu3D/Menu3D", "../Vars", "./3DMol/ThreeDMol", "./CommonLoader"], function (require, exports, Optimizations, Menu3D, Vars, ThreeDMol, CommonLoader) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Load in the molecules.
     */
    function setup() {
        // If run in gltf mode, loads from gltf files (e.g., from biotite
        // environment). Otherwise, loads from url and other sources.
        CommonLoader.beforeLoading();
        jQuery.getJSON("scene_info.json", (data) => {
            // Deactivate menu if appropriate.
            if (data["menuActive"] === false) {
                Vars.vrVars.menuActive = false;
            }
            // Load using GLTF (e.g., from babylonjs).
            // if (data["objIDs"] !== undefined) {
            //     // The objIDs list contains IDs corresponding to gltf files.
            //    GLTF.setup(data);
            // } else {
            // So loading it from a pdb file via 3Dmoljs.
            ThreeDMol.setup(data);
            // }
            if (Vars.vrVars.menuActive) {
                Menu3D.setup(data);
            }
            // Update the shadows.
            Optimizations.updateEnvironmentShadows();
        });
    }
    exports.setup = setup;
});

define('UI/LoadingScreens',["require", "exports", "../Vars"], function (require, exports, Vars) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    let intervalID;
    /**
     * Removes the initial loading screen, to let the user know that the initial
     * javascript file is loading.
     * @returns void
     */
    function removeLoadingJavascriptScreen() {
        // Remove the initial loading javascript screen (not the babylonjs loading
        // screen... That's to come).
        document.getElementById("loading-container").outerHTML = "";
    }
    exports.removeLoadingJavascriptScreen = removeLoadingJavascriptScreen;
    /**
     * Update the text displayed on the babylonjs loading scene.
     * @param  {string} msg  The text to update.
     * @returns void
     */
    function babylonJSLoadingMsg(msg) {
        // Just to make sure there isn't a fight between the two ways of showing
        // babylonjs loading messages.
        stopFakeLoading();
        Vars.engine.displayLoadingUI(); // Keep it up while progressing...
        Vars.engine.loadingUIText = msg;
    }
    exports.babylonJSLoadingMsg = babylonJSLoadingMsg;
    /**
     * Starts the fake loading screen, to give the impression that things are
     * loading.
     * @param  {number} initialVal  The initial fake value (%).
     * @returns void
     */
    function startFakeLoading(initialVal) {
        let fakeVal = initialVal;
        clearInterval(intervalID);
        intervalID = setInterval(() => {
            fakeVal = fakeVal + 0.02 * (99 - fakeVal);
            Vars.engine.displayLoadingUI(); // Keep it up while progressing...
            Vars.engine.loadingUIText = "Loading the main scene... " + fakeVal.toFixed(0) + "%";
        }, 100);
    }
    exports.startFakeLoading = startFakeLoading;
    /**
     * Stop the fake-loading splash screen.
     * @returns void
     */
    function stopFakeLoading() {
        clearInterval(intervalID);
    }
    exports.stopFakeLoading = stopFakeLoading;
});

define('WebRTC/Lecturer',["require", "exports", "../Cameras/CommonCamera", "../UI/OpenPopup", "./WebRTCBase"], function (require, exports, CommonCamera, OpenPopup, WebRTCBase) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    class Lecturer extends WebRTCBase.WebRTCBase {
        // because this is the lecturer).
        constructor() {
            super();
            this.idReady = null;
            this.gotConn = null;
            this.conns = []; // The connections (there could be multiple ones
            let gotConnResolve;
            this.gotConn = new Promise((resolve, reject) => {
                gotConnResolve = resolve;
            });
            this.idReady = new Promise((idReadyResolve, reject) => {
                this.setupWebRTCCallbacks(idReadyResolve, gotConnResolve);
            });
        }
        sendData(data) {
            /** @type {number} */
            let connsLen = this.conns.length;
            for (let i = 0; i < connsLen; i++) {
                let conn = this.conns[i];
                conn.send(data);
                console.log(data + " sent");
            }
        }
        setupWebRTCCallbacks(idReadyResolve, gotConnResolve) {
            this.peer.on("open", (id) => {
                // Workaround for peer.reconnect deleting previous id
                if (this.peer.id === null) {
                    console.log("Received null id from peer open");
                    this.peer.id = this.peerId;
                }
                else {
                    this.peerId = this.peer.id;
                }
                idReadyResolve(this.peerId);
                console.log(this.peerId);
            });
            // Below only needed on lecturer. It's when a connection is received.
            this.peer.on("connection", (c) => {
                this.conns.push(c);
                gotConnResolve();
                console.log("Lecturer: added a connection");
            });
            this.peer.on("close", () => {
                /** @type {number} */
                let connsLen = this.conns.length;
                for (let i = 0; i < connsLen; i++) {
                    this.conns[i] = null;
                }
                console.log("Connection destroyed. Please refresh");
            });
        }
    }
    exports.Lecturer = Lecturer;
    function startBroadcast() {
        // Contact the peerjs server
        let lect = new Lecturer();
        lect.idReady.then((id) => {
            OpenPopup.openUrlModal("Mirroring URL", "pages/follow-the-leader.html?" +
                window.location.href.split("?", 2)[1] + "&webrtc=" + id);
        });
        // Every three seconds send the information about the representations.
        setInterval(() => {
            let pos = CommonCamera.getCameraPosition();
            let rotQua = CommonCamera.getCameraRotationQuaternion();
            console.log(pos, rotQua);
            let rotFac = 1.0;
            // if (Vars.vrVars.navMode === Navigation.NavMode.VRWithControllers) {
            // Strangely, activeCamera.leftCamera.rotationQuaternion faces the
            // opposite direction of activeCamera.rotationQuaternion, if VR
            // camera.
            // rotFac = -1.0;
            // }
            // console.log("Actually, up and down work. I think it's just rotation around up axis.");
            let val = [pos.x, pos.y, pos.z, rotFac * rotQua.x, rotFac * rotQua.y, rotFac * rotQua.z, rotFac * rotQua.w];
            lect.sendData({
                "type": "locrot",
                "val": val,
            });
        }, 100);
    }
    exports.startBroadcast = startBroadcast;
    window["startBroadcast"] = startBroadcast;
    function tmp() {
        console.log("moo");
    }
    exports.tmp = tmp;
});

// Sets up tweaks to the UI.
define('UI/UI2D',["require", "exports", "../UI/OpenPopup", "../Vars", "../WebRTC/Lecturer"], function (require, exports, OpenPopup, Vars, Lecturer) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Sets up the 2D button that can be used to launch VR.
     * @returns void
     */
    function setup() {
        addRunModeButtons();
    }
    exports.setup = setup;
    /**
     * Adds the 2D button to the DOM, makes it clickable.
     * @returns void
     */
    function addRunModeButtons() {
        // Adds some additional buttons to the UI. Source:
        // https://iconmonstr.com/fullscreen-thin-svg/
        jQuery("body").append(`
        <button
          title="Click to switch to full screen"
          id="fullscreen-button"
          class="ui-button"
          style="color:white;
                 width:80px;
                 right:20px;
                 position:absolute;
                 height:50px;
                 bottom:80px;
                 background-color:rgba(51,51,51,0.7);
                 border:none;
                 outline:none;
                 cursor:pointer;">
            <svg
              style="position:relative; left:0.5px;"
              width="48" height="48"
              xmlns="http://www.w3.org/2000/svg"
              xmlns:svg="http://www.w3.org/2000/svg"
              clip-rule="evenodd">
                <g class="layer">
                    <path d="m47.799999,43.649999l-47.699999,0l0,-39.749999l47.699999,0l0,39.749999zm-1.9875,-37.762499l-43.724999,0l0,35.774999l43.724999,0l0,-35.774999zm-7.95,13.9125l-1.9875,0l0,-6.441487l-22.341487,22.341487l6.441487,0l0,1.9875l-9.9375,0l0,-9.9375l1.9875,0l0,6.441487l22.341487,-22.341487l-6.441487,0l0,-1.9875l9.9375,0l0,9.9375z" fill="#ffffff" id="svg_1"/>
                </g>
            </svg>
        </button>

        <button
          title="Share (Follow-the-Leader)"
          id="follow-the-leader"
          class="ui-button"
          style="color:white;
                 width:80px;
                 right:20px;
                 position:absolute;
                 height:50px;
                 bottom:140px;
                 background-color:rgba(51,51,51,0.7);
                 border:none;
                 outline:none;
                 cursor:pointer;">
                 <svg version="1.2" baseProfile="tiny" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
	 x="0px" y="0px" width="48px" height="48px" viewBox="0 0 48 48" xml:space="preserve">
<path fill="none" stroke="#FFFFFF" stroke-width="1.5" d="M35.4,4.6c-3.2,0-5.8,2.4-5.8,5.8l0,0c0,0.5,0.2,1.1,0.5,1.4l-13.4,7.8
	c-1-1.4-2.6-1.8-4.1-1.8c-3.2,0-5.8,2.4-5.8,5.8l0,0c0,2.9,2.6,5.8,5.8,5.8l0,0c1.3,0,2.2-0.5,3.2-1.4l13.6,8.3
	c-0.3,0.4-0.3,0.9-0.3,1.4c0,3.4,2.7,5.8,5.9,5.8l0,0c3.2,0,5.6-2.4,5.6-5.8l0,0c0-2.9-2.4-5.9-5.6-5.9l0,0c-1.7,0-3.2,1.1-4.4,2
	l-13.1-7.3c0.5-0.9,0.7-2,0.7-2.9c0-0.5,0-1.4-0.2-2l13.3-7.3c1,0.9,2.5,1.5,4.1,1.5c3.2,0,5.9-2.5,5.9-5.4l0,0
	C41.3,6.9,38.5,4.6,35.4,4.6L35.4,4.6L35.4,4.6z"/>
</svg>
        </button>

        <button
          title="Click for help"
          id="help-button"
          class="ui-button"
          style="color:white;
                 width:80px;
                 right:20px;
                 position:absolute;
                 height:50px;
                 bottom:200px;
                 background-color:rgba(51,51,51,0.7);
                 border:none;
                 outline:none;
                 cursor:pointer;">
                 <svg version="1.2" baseProfile="tiny" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
	 x="0px" y="0px" width="48px" height="48px" viewBox="0 0 48 48" xml:space="preserve">
<path fill="none" stroke="#FFFFFF" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" stroke-miterlimit="10" d="
	M35.5,9.8c1.7,5.4-0.6,8-1.6,8.9c-1.9,1.9-4.5,4.7-5.8,7c-1.5,2.7-4.1,12-6.8,4.4c-3.2-9.1,1.3-11.6,3.5-13.4
	c1.5-1.3,3.4-4.3,0.5-5.3c-4-1.3-6.1,5.3-10.7,4c-3-0.8-3.2-4.1-2.2-6.6C15.4,1.7,32.5,0.6,35.5,9.8L35.5,9.8z"/>
<path fill="none" stroke="#FFFFFF" stroke-width="2" stroke-miterlimit="10" d="M28.3,39.6c0-5.5-8.5-5.5-8.5,0S28.3,45.1,28.3,39.6
	"/>
</svg>

        </button>
    `);
        /** @const {*} */
        const fullScreenButton = jQuery("#fullscreen-button");
        fullScreenButton.click(() => {
            Vars.engine.switchFullscreen(true);
            jQuery("#renderCanvas").focus(); // So keypress will work.
        });
        /** @const {*} */
        const helpButton = jQuery("#help-button");
        helpButton.click(() => {
            // window.open("pages/index.html", "_blank");
            OpenPopup.openUrlModal("Help", "pages/index.html");
        });
        /** @const {*} */
        const shareButton = jQuery("#follow-the-leader");
        shareButton.click(() => {
            Lecturer.startBroadcast();
        });
        // Also make VR button visible.
        document.getElementById("babylonVRiconbtn").style.opacity = "1.0"; // Non IE;
        document.getElementById("babylonVRiconbtn").style.filter = "alpha(opacity=1.0)"; // IE;
    }
    /**
     * A function to activate debug mode.
     * @returns void
     */
    function debugMode() {
        Vars.scene.debugLayer.show();
        setTimeout(() => {
            document.getElementById("inspector-host").style.zIndex = "15";
            document.getElementById("scene-explorer-host").style.zIndex = "15";
        }, 500);
    }
    window["debugMode"] = debugMode;
});

define('Scene/LoadAndSetup',["require", "exports", "../Cameras/Setup", "../Cameras/VRCamera", "../Mols/Load", "../Navigation/Navigation", "../Navigation/Pickables", "../UI/LoadingScreens", "../UI/UI2D", "../Vars", "../WebRTC/Lecturer", "./Optimizations"], function (require, exports, CamerasSetup, VRCamera, MolsLoad, Navigation, Pickables, LoadingScreens, UI2D, Vars, Lecturer, Optimizations) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Load the scene, setup the VR, etc.
     * @returns void
     */
    function load() {
        Vars.setup();
        // Remove the initial loading javascript screen (not the babylonjs loading
        // screen... That's to come).
        LoadingScreens.removeLoadingJavascriptScreen();
        // Because of this error, you need to setup VR before loading the babylon
        // scene:
        // https://forum.babylonjs.com/t/createdefaultvrexperience-android-chrome-vr-mode-change-material-unusual-error/2738/4
        vrSetupBeforeBabylonFileLoaded();
        babylonScene(() => {
            // Setup the cameras.
            CamerasSetup.setup();
            // Setup the general things that apply regardless of the mode used.
            // Here because it requires a ground mesh. Set up the floor mesh
            // (hidden).
            Navigation.setup();
            // Setup function to manage pickable objects (e.g., floor).
            Pickables.setup();
            // Sets up nav selection buttons in DOM.
            UI2D.setup();
            // Load extra objects
            MolsLoad.setup();
            // loadingAssetsDone(), below, will run once all assets loaded.
        });
        // Watch for browser/canvas resize events
        window.addEventListener("resize", () => {
            Vars.engine.resize();
        });
    }
    exports.load = load;
    function vrSetupBeforeBabylonFileLoaded() {
        // You'll need a navigation mesh.
        let navMeshToUse = BABYLON.Mesh.CreateSphere("navTargetMesh", 4, 0.1, Vars.scene);
        let navMeshMat = new BABYLON.StandardMaterial("myMaterial", Vars.scene);
        navMeshMat.diffuseColor = new BABYLON.Color3(1, 0, 1);
        navMeshToUse.material = navMeshMat;
        // Setup the VR here. Set up the parameters (filling in missing values,
        // for example). Also saves the modified params to the params module
        // variable. Note that this calls createDefaultVRExperience.
        Vars.setupVR({
            groundMeshName: "ground",
            navTargetMesh: navMeshToUse,
        });
        // Setup the VR camera
        VRCamera.setup();
        // Optimize the scene to make it run better.
        Optimizations.setup();
        // For debugging...
        // trackDebugSphere();
        window.Vars = Vars;
    }
    /**
     * Load the scene from the .babylon file.
     * @param  {Function} callBackFunc The callback function to run when loaded.
     * @returns void
     */
    function babylonScene(callBackFunc) {
        LoadingScreens.babylonJSLoadingMsg("Loading the main scene...");
        // TODO: Use LoadAssetContainerAsync instead?
        BABYLON.SceneLoader.LoadAssetContainer("scene/", "scene.babylon", Vars.scene, (container) => {
            LoadingScreens.startFakeLoading(90);
            Vars.scene.executeWhenReady(() => {
                container.addAllToScene();
                // There should be only one camera at this point, because the VR
                // stuff is in the callback. Make that that one camera is the
                // active one.
                // Vars.scene.activeCamera =  Vars.scene.cameras[0];
                // Make sure the active camera is the one loaded from the babylon
                // file. Should be the only one without the string VR in it.
                Vars.scene.activeCamera = Vars.scene.cameras.filter((c) => c.name.indexOf("VR") === -1)[0];
                // Attach camera to canvas inputs
                // Vars.scene.activeCamera.attachControl(Vars.canvas);
                keepOnlyLightWithShadowlightSubstr();
                hideObjectsUsedForSceneCreation();
                optimizeMeshesAndMakeClickable();
                callBackFunc();
            });
        }, (progress) => {
            if (progress["lengthComputable"]) {
                // Only to 90 to not give the impression that it's done loading.
                let percent = Math.round(90 * progress["loaded"] / progress["total"]);
                LoadingScreens.babylonJSLoadingMsg("ALoading the main scene... " + percent.toString() + "%");
            }
        });
    }
    /**
     * Only the light with shadowlight should be retained.
     * @returns void
     */
    function keepOnlyLightWithShadowlightSubstr() {
        // Delete all the lights but the first one that has the substring
        // shadowlight or shadow_light.
        let foundFirstShadowLight = false;
        let indexToUse = 0;
        while (Vars.scene.lights.length > 1) {
            let light = Vars.scene.lights[indexToUse];
            let lightName = light.name.toLowerCase();
            let isShadowLight = ((lightName.indexOf("shadowlight") !== -1) ||
                (lightName.indexOf("shadow_light") !== -1));
            if (!isShadowLight) {
                // It's not a shadow light. Delete it.
                Vars.scene.lights[indexToUse].dispose();
            }
            else if (foundFirstShadowLight) {
                // You've already found a shadow light. Delete additional
                // ones.
                Vars.scene.lights[indexToUse].dispose();
            }
            else {
                // Must be the first shadow light. Don't delete, but make
                // note of it.
                foundFirstShadowLight = true;
                indexToUse++;
            }
        }
    }
    /**
     * Hides meshes that are only used ofr scene creation.
     * @returns void
     */
    function hideObjectsUsedForSceneCreation() {
        // Hide objects used for scene creation.
        /** @type {number} */
        let len = Vars.scene.meshes.length;
        for (let meshIdx = 0; meshIdx < len; meshIdx++) {
            if (Vars.scene.meshes[meshIdx].name === "protein_box") {
                // Vars.scene.meshes[meshIdx].dispose();
                Vars.scene.getMeshByName("protein_box").isVisible = false;
                // scene.getMeshByName("protein_box").visibility
            }
        }
    }
    /**
     * Optimizes meshes and makes them clickable.
     * @returns void
     */
    function optimizeMeshesAndMakeClickable() {
        // Optimize and make meshes clickable. Also, make sure all meshes
        // are emmissive.
        /** @type {number} */
        let len = Vars.scene.meshes.length;
        for (let meshIdx = 0; meshIdx < len; meshIdx++) {
            if (Vars.scene.meshes[meshIdx].material) {
                let mesh = Vars.scene.meshes[meshIdx];
                // It needs to be emmisive (so always baked).
                if ((mesh.material.emissiveTexture === undefined) || (mesh.material.emissiveTexture === null)) {
                    mesh.material.emissiveTexture = mesh.material.diffuseTexture;
                    // Below seems important to comment out. .clone()
                    // above and .dispose() below doesn't work. Also,
                    // below = null and = undefined didn't work. No good
                    // solutions, so leave diffuse texture in place?
                    // mesh.material.diffuseTexture = undefined;
                    mesh.material.diffuseColor = new BABYLON.Color3(0, 0, 0);
                    mesh.material.specularColor = new BABYLON.Color3(0, 0, 0);
                    mesh.material.emissiveColor = new BABYLON.Color3(0, 0, 0);
                }
                // TODO: Using false below to not freeze materials.
                // They are white otherwise. Good to figure out why.
                Optimizations.freezeMeshProps(mesh, false);
                Pickables.makeMeshMouseClickable({
                    mesh,
                    scene: Vars.scene,
                });
            }
        }
    }
    function loadingAssetsDone() {
        // Give it a bit to let one render cycle go through. Hackish,
        // admittedly.
        setTimeout(Optimizations.updateEnvironmentShadows, 1000);
        // Stop showing the fake loading screen.
        LoadingScreens.stopFakeLoading();
        // Make sure the camera can see far enough.
        Vars.scene.activeCamera.maxZ = 250;
        // Make sure camera can see objects that are very close.
        Vars.scene.activeCamera.minZ = 0;
        // Start the render loop. Register a render loop to repeatedly render the
        // scene
        Vars.engine.runRenderLoop(() => {
            // try {
            Vars.scene.render();
            // }  catch {
            // console.log("ERROR!");
            // }
            // console.log("render");
        });
    }
    exports.loadingAssetsDone = loadingAssetsDone;
    Lecturer.tmp();
});


///<reference path="external/require/require.d.ts" />
require.config({
    // paths: {
    //     // jquery: 'https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min',
    //     jquery: '../js/jquery.min',
    //     bootstrap: '../js/bootstrap-3.3.7/dist/js/bootstrap.min'
    // },
    // shim: {
    //     bootstrap: {
    //         deps: ['jquery']
    //     }
    // },
    "urlArgs": "bust=" + (new Date()).getTime(),
});
// This require function starts the app
require(["Scene/LoadAndSetup"], (SceneLoad) => {
    SceneLoad.load(); // ("renderCanvas");
});

define("Start", function(){});

}());