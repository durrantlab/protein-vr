import bpy
import bmesh
import os
import random

class BakeAllObjs(bpy.types.Operator):
    """Tooltip"""
    bl_idname = "render.bake_all_objs"
    bl_label = "Bake All Objects"

    @classmethod
    def poll(cls, context):
        return context.active_object is not None

    def execute(self, context):
        self.setup()
        return {'FINISHED'}

    def remove_old_bake_tex_nodes(self):
        for obj in bpy.data.objects:
            for slot in obj.material_slots:
                mat = slot.material
                mat.use_nodes = True
                matnodes = mat.node_tree.nodes
                for node in matnodes:
                    if node.name.startswith("bake_tex_node_"):
                        matnodes.remove(node)

    def setup(self):
        scene = bpy.context.scene

        # Make sure in cycles mode.
        scene.render.engine = 'CYCLES'

        # Make sure object mode.
        self.switch_mode("OBJECT")

        # Use all processors
        scene.render.threads_mode = "AUTO"

        for i in range(scene.crc_multi_bakes_per_mesh):

            # Delete previously baked images
            for image in bpy.data.images:
                if image.name.startswith("bake_img_"):
                    bpy.data.images.remove(image)

            self.remove_old_bake_tex_nodes()

            # Go through objects.
            for obj in bpy.data.objects:
                if not obj.hide and not obj.hide_render and obj.type == "MESH":
                    # It's not hidden. Select the object.
                    self.sel_obj(obj)

                    # Make an image to bake to.
                    rand_id = random.randint(0, 10000000)
                    output_dir = os.path.dirname(bpy.data.filepath) + os.sep + obj.name + ".img_dir" + os.sep
                    if not os.path.exists(output_dir):
                        os.mkdir(output_dir)
                    img =  bpy.data.images.new(
                        output_dir + "bake_img_" + obj.name + "_img." + str(rand_id),
                        width=scene.crc_multi_bake_dimen, height=scene.crc_multi_bake_dimen
                    )
                    img.use_alpha = True
                    img.alpha_mode = 'STRAIGHT'
                    img.filepath_raw = output_dir + str(rand_id) + ".png"
                    img.file_format = 'PNG'

                    # If there is no material, create one.
                    if len(obj.material_slots) == 0:
                        mat = bpy.data.materials.new(name=obj.name + "_material")
                        obj.data.materials.append(mat)

                    # Go through all the material slots of this object.
                    for slot in obj.material_slots:
                        # Get the material and nodes.
                        mat = slot.material
                        mat.use_nodes = True
                        matnodes = mat.node_tree.nodes

                        # Add a texture node
                        tex_node = matnodes.new('ShaderNodeTexImage')
                        tex_node.image = img
                        tex_node.name = "bake_tex_node_" + obj.name

                        # Make sure only the texture node is selected/active.
                        for node in matnodes:
                            node.select = False
                        tex_node.select = True
                        matnodes.active = tex_node

                    # Now make sure the object has UV. If not, give it UV.
                    if not obj.data.uv_layers:
                        # No UV layers, so make one
                        self.switch_mode("EDIT")

                        # Select all vertexes
                        mesh = bmesh.from_edit_mesh(obj.data)
                        for v in mesh.verts:
                            v.select = True

                        # trigger viewport update
                        scene.objects.active = scene.objects.active

                        # Smart project
                        bpy.ops.uv.smart_project(angle_limit=66.0, island_margin=0.1, user_area_weight=0.0)
                        self.switch_mode("OBJECT")

                    # Bake the image
                    scene.cycles.samples = scene.crc_multi_bake_samples
                    scene.cycles.seed = rand_id
                    bpy.ops.object.bake(type='COMBINED')

                    # Save the image
                    img.save()


                    # try: bpy.ops.cycles.use_shading_nodes()
                    # except: continue  # It's a camera or something.




    def switch_mode(self, mode):
        try: bpy.ops.object.mode_set(mode=mode)
        except: pass

    def sel_obj(self, obj):
        bpy.ops.object.select_all(action='DESELECT')
        obj.select = True
        bpy.context.scene.objects.active = obj

class CRCMultiBake(bpy.types.Panel):
    """Creates a Panel in the scene context of the properties editor"""
    bl_label = "CRC Multi Bake"
    bl_idname = "SCENE_PT_layout"
    bl_space_type = 'PROPERTIES'
    bl_region_type = 'WINDOW'
    bl_context = "render"

    # my_float = bpy.props.FloatProperty(
    #     name="Some Floating Point",
    #     description="Desc"
    # )

    def draw(self, context):
        scene = context.scene

        layout = self.layout
        layout.prop(scene, "crc_multi_bake_dimen")
        layout.prop(scene, "crc_multi_bake_samples")
        layout.prop(scene, "crc_multi_bakes_per_mesh")

        row = layout.row()
        row.operator("render.bake_all_objs")

def register():
    bpy.utils.register_class(CRCMultiBake)
    bpy.utils.register_class(BakeAllObjs)

    bpy.types.Scene.crc_multi_bake_dimen = bpy.props.IntProperty(
        name = "Image Dimension", default=2048,
        description="The number of pixels along the side of a square image.",
    )

    bpy.types.Scene.crc_multi_bakes_per_mesh = bpy.props.IntProperty(
        name = "Bakes Per Mesh", default=5,
        description="The number of backed images to produce per mesh.",
    )

    bpy.types.Scene.crc_multi_bake_samples = bpy.props.IntProperty(
        name = "Samples", default=32,
        description="The number of samples to use when rendering.",
    )

def unregister():
    bpy.utils.unregister_class(CRCMultiBake)
    bpy.utils.unregister_class(BakeAllObjs)

if __name__ == "__main__":
    register()
